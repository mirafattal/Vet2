//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class APIClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addAdoptionWithOwner(body: AddAdoptionQuestWithOwnerDTO | undefined): Observable<AddAdoptionQuestWithOwnerDTO> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/addAdoptionWithOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdoptionWithOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdoptionWithOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddAdoptionQuestWithOwnerDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddAdoptionQuestWithOwnerDTO>;
        }));
    }

    protected processAddAdoptionWithOwner(response: HttpResponseBase): Observable<AddAdoptionQuestWithOwnerDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddAdoptionQuestWithOwnerDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllPendingStatus(): Observable<AdoptionQuestionnaireDto[]> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/GetAllPendingStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPendingStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPendingStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionQuestionnaireDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionQuestionnaireDto[]>;
        }));
    }

    protected processGetAllPendingStatus(response: HttpResponseBase): Observable<AdoptionQuestionnaireDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdoptionQuestionnaireDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    approveQuest(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/ApproveQuest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveQuest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveQuest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveQuest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    rejectQuest(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/RejectQuest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectQuest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectQuest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRejectQuest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param petId (optional) 
     * @return OK
     */
    countByPetId(petId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/countByPetId?";
        if (petId === null)
            throw new Error("The parameter 'petId' cannot be null.");
        else if (petId !== undefined)
            url_ += "petId=" + encodeURIComponent("" + petId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountByPetId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountByPetId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCountByPetId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param petForAdoptionId (optional) 
     * @return OK
     */
    getByPetID(petForAdoptionId: number | undefined): Observable<GetAllAdoptionQuestwithPetNameDto[]> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/GetByPetID?";
        if (petForAdoptionId === null)
            throw new Error("The parameter 'petForAdoptionId' cannot be null.");
        else if (petForAdoptionId !== undefined)
            url_ += "petForAdoptionId=" + encodeURIComponent("" + petForAdoptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPetID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPetID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllAdoptionQuestwithPetNameDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllAdoptionQuestwithPetNameDto[]>;
        }));
    }

    protected processGetByPetID(response: HttpResponseBase): Observable<GetAllAdoptionQuestwithPetNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllAdoptionQuestwithPetNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll(): Observable<AdoptionQuestionnaireDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionQuestionnaireDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionQuestionnaireDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AdoptionQuestionnaireDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionQuestionnaireDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById(id: number | undefined): Observable<AdoptionQuestionnaireDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionQuestionnaireDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionQuestionnaireDtoApiResponse>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AdoptionQuestionnaireDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionQuestionnaireDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add(body: AdoptionQuestionnaireDto | undefined): Observable<AdoptionQuestionnaireDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionQuestionnaireDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionQuestionnaireDtoApiResponse>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<AdoptionQuestionnaireDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionQuestionnaireDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: AdoptionQuestionnaireDto | undefined): Observable<AdoptionQuestionnaireDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionQuestionnaireDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionQuestionnaireDtoApiResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AdoptionQuestionnaireDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionQuestionnaireDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: AdoptionQuestionnaireDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionQuestionnaire/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll2(): Observable<AdoptionStatusDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionStatus/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionStatusDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionStatusDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll2(response: HttpResponseBase): Observable<AdoptionStatusDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionStatusDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById2(id: number | undefined): Observable<AdoptionStatusDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionStatus/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionStatusDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionStatusDtoApiResponse>;
        }));
    }

    protected processGetById2(response: HttpResponseBase): Observable<AdoptionStatusDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionStatusDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add2(body: AdoptionStatusDto | undefined): Observable<AdoptionStatusDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionStatus/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionStatusDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionStatusDtoApiResponse>;
        }));
    }

    protected processAdd2(response: HttpResponseBase): Observable<AdoptionStatusDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionStatusDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update2(body: AdoptionStatusDto | undefined): Observable<AdoptionStatusDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionStatus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdoptionStatusDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdoptionStatusDtoApiResponse>;
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<AdoptionStatusDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdoptionStatusDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById2(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionStatus/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById2(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete2(body: AdoptionStatusDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/AdoptionStatus/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete2(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getOwnerbyAnimalID(id: number | undefined): Observable<GetAnimalbyOwnerIDdto[]> {
        let url_ = this.baseUrl + "/api/Animal/GetOwnerbyAnimalID?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnerbyAnimalID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerbyAnimalID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAnimalbyOwnerIDdto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAnimalbyOwnerIDdto[]>;
        }));
    }

    protected processGetOwnerbyAnimalID(response: HttpResponseBase): Observable<GetAnimalbyOwnerIDdto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAnimalbyOwnerIDdto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @return OK
     */
    getAnimalbyId(animalId: number | undefined): Observable<AnimalDto[]> {
        let url_ = this.baseUrl + "/api/Animal/GetAnimalbyId?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "animalId=" + encodeURIComponent("" + animalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDto[]>;
        }));
    }

    protected processGetAnimalbyId(response: HttpResponseBase): Observable<AnimalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnimalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalTypeId (optional) 
     * @return OK
     */
    getbyAnimalTypeId(animalTypeId: number | undefined): Observable<AnimalDto[]> {
        let url_ = this.baseUrl + "/api/Animal/GetbyAnimalTypeId?";
        if (animalTypeId === null)
            throw new Error("The parameter 'animalTypeId' cannot be null.");
        else if (animalTypeId !== undefined)
            url_ += "animalTypeId=" + encodeURIComponent("" + animalTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyAnimalTypeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyAnimalTypeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDto[]>;
        }));
    }

    protected processGetbyAnimalTypeId(response: HttpResponseBase): Observable<AnimalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnimalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    counttotalpetpatients(): Observable<number> {
        let url_ = this.baseUrl + "/api/Animal/counttotalpetpatients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounttotalpetpatients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounttotalpetpatients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCounttotalpetpatients(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    counttotalhorsepatients(): Observable<number> {
        let url_ = this.baseUrl + "/api/Animal/counttotalhorsepatients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounttotalhorsepatients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounttotalhorsepatients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCounttotalhorsepatients(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @param imageUrl (optional) 
     * @param posterFile (optional) 
     * @return OK
     */
    updateimage(animalId: number | undefined, imageUrl: string | undefined, posterFile: FileParameter | undefined): Observable<AnimalImageDto[]> {
        let url_ = this.baseUrl + "/api/Animal/updateimage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (animalId === null || animalId === undefined)
            throw new Error("The parameter 'animalId' cannot be null.");
        else
            content_.append("AnimalId", animalId.toString());
        if (imageUrl === null || imageUrl === undefined)
            throw new Error("The parameter 'imageUrl' cannot be null.");
        else
            content_.append("ImageUrl", imageUrl.toString());
        if (posterFile === null || posterFile === undefined)
            throw new Error("The parameter 'posterFile' cannot be null.");
        else
            content_.append("posterFile", posterFile.data, posterFile.fileName ? posterFile.fileName : "posterFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateimage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateimage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalImageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalImageDto[]>;
        }));
    }

    protected processUpdateimage(response: HttpResponseBase): Observable<AnimalImageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnimalImageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param imagePath (optional) 
     * @return OK
     */
    downloadImageAnimal(imagePath: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Animal/DownloadImageAnimal?";
        if (imagePath === null)
            throw new Error("The parameter 'imagePath' cannot be null.");
        else if (imagePath !== undefined)
            url_ += "imagePath=" + encodeURIComponent("" + imagePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadImageAnimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadImageAnimal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadImageAnimal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param ownerId (optional) 
     * @return OK
     */
    getAllAnimalsByOwnerId(ownerId: number | undefined): Observable<AnimalDto[]> {
        let url_ = this.baseUrl + "/api/Animal/getAllAnimalsByOwnerId?";
        if (ownerId === null)
            throw new Error("The parameter 'ownerId' cannot be null.");
        else if (ownerId !== undefined)
            url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAnimalsByOwnerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAnimalsByOwnerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDto[]>;
        }));
    }

    protected processGetAllAnimalsByOwnerId(response: HttpResponseBase): Observable<AnimalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnimalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    searchAnimals(searchTerm: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<AnimalDtoPaginationResponseDto> {
        let url_ = this.baseUrl + "/api/Animal/searchAnimals?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchAnimals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchAnimals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDtoPaginationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDtoPaginationResponseDto>;
        }));
    }

    protected processSearchAnimals(response: HttpResponseBase): Observable<AnimalDtoPaginationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalDtoPaginationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = InvoiceDtoPaginationResponseDto.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return OK
     */
    searchAnimalOwner(searchTerm: string | undefined): Observable<AnimalSearchDto[]> {
        let url_ = this.baseUrl + "/api/Animal/searchAnimalOwner?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchAnimalOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchAnimalOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalSearchDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalSearchDto[]>;
        }));
    }

    protected processSearchAnimalOwner(response: HttpResponseBase): Observable<AnimalSearchDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnimalSearchDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return OK
     */
    search(searchTerm: string | undefined): Observable<AnimalSearchDto[]> {
        let url_ = this.baseUrl + "/api/Animal/search?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalSearchDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalSearchDto[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<AnimalSearchDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnimalSearchDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAnimalOwnerTable(): Observable<GetAnimalOwnerTable[]> {
        let url_ = this.baseUrl + "/api/Animal/GetAnimalOwnerTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalOwnerTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalOwnerTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAnimalOwnerTable[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAnimalOwnerTable[]>;
        }));
    }

    protected processGetAnimalOwnerTable(response: HttpResponseBase): Observable<GetAnimalOwnerTable[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAnimalOwnerTable.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll3(): Observable<AnimalDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Animal/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll3(response: HttpResponseBase): Observable<AnimalDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById3(id: number | undefined): Observable<AnimalDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Animal/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDtoApiResponse>;
        }));
    }

    protected processGetById3(response: HttpResponseBase): Observable<AnimalDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add3(body: AnimalDto | undefined): Observable<AnimalDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Animal/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDtoApiResponse>;
        }));
    }

    protected processAdd3(response: HttpResponseBase): Observable<AnimalDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update3(body: AnimalDto | undefined): Observable<AnimalDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Animal/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalDtoApiResponse>;
        }));
    }

    protected processUpdate3(response: HttpResponseBase): Observable<AnimalDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById3(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Animal/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById3(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete3(body: AnimalDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Animal/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete3(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll4(): Observable<AnimalTypeDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/AnimalType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalTypeDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalTypeDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll4(response: HttpResponseBase): Observable<AnimalTypeDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalTypeDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById4(id: number | undefined): Observable<AnimalTypeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AnimalType/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalTypeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalTypeDtoApiResponse>;
        }));
    }

    protected processGetById4(response: HttpResponseBase): Observable<AnimalTypeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalTypeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add4(body: AnimalTypeDto | undefined): Observable<AnimalTypeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AnimalType/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalTypeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalTypeDtoApiResponse>;
        }));
    }

    protected processAdd4(response: HttpResponseBase): Observable<AnimalTypeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalTypeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update4(body: AnimalTypeDto | undefined): Observable<AnimalTypeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/AnimalType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnimalTypeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnimalTypeDtoApiResponse>;
        }));
    }

    protected processUpdate4(response: HttpResponseBase): Observable<AnimalTypeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnimalTypeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById4(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/AnimalType/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById4(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete4(body: AnimalTypeDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/AnimalType/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete4(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    appointmentsforthisweek(): Observable<AppointmentDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/appointmentsforthisweek";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppointmentsforthisweek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppointmentsforthisweek(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto[]>;
        }));
    }

    protected processAppointmentsforthisweek(response: HttpResponseBase): Observable<AppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    appointmentsforthismonth(): Observable<AppointmentDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/appointmentsforthismonth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppointmentsforthismonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppointmentsforthismonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto[]>;
        }));
    }

    protected processAppointmentsforthismonth(response: HttpResponseBase): Observable<AppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @return OK
     */
    getappointmentbyanimalId(animalId: number | undefined): Observable<AppointmentDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/GetappointmentbyanimalId?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "animalId=" + encodeURIComponent("" + animalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetappointmentbyanimalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetappointmentbyanimalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto[]>;
        }));
    }

    protected processGetappointmentbyanimalId(response: HttpResponseBase): Observable<AppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param doctorId (optional) 
     * @param year (optional) 
     * @param month (optional) 
     * @return OK
     */
    availableSlots(doctorId: number | undefined, year: number | undefined, month: number | undefined): Observable<GetAvailableAppointmentsDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/availableSlots?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableSlots(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableSlots(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAvailableAppointmentsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAvailableAppointmentsDto[]>;
        }));
    }

    protected processAvailableSlots(response: HttpResponseBase): Observable<GetAvailableAppointmentsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAvailableAppointmentsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param doctorId (optional) 
     * @param year (optional) 
     * @param month (optional) 
     * @return OK
     */
    getManybookedAppointments(doctorId: number | undefined, year: number | undefined, month: number | undefined): Observable<AppointmentDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/GetManybookedAppointments?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManybookedAppointments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManybookedAppointments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto[]>;
        }));
    }

    protected processGetManybookedAppointments(response: HttpResponseBase): Observable<AppointmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppointmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bookAppointment(body: BookAppointmentDto | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Appointment/BookAppointment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookAppointment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processBookAppointment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAnimalAndAppoinThisWeek(): Observable<AppoiAnimalNameDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/GetAnimalAndAppoinThisWeek";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalAndAppoinThisWeek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalAndAppoinThisWeek(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppoiAnimalNameDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppoiAnimalNameDto[]>;
        }));
    }

    protected processGetAnimalAndAppoinThisWeek(response: HttpResponseBase): Observable<AppoiAnimalNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppoiAnimalNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAnimalAndAppoinThisMonth(): Observable<AppoiAnimalNameDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/GetAnimalAndAppoinThisMonth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalAndAppoinThisMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalAndAppoinThisMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppoiAnimalNameDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppoiAnimalNameDto[]>;
        }));
    }

    protected processGetAnimalAndAppoinThisMonth(response: HttpResponseBase): Observable<AppoiAnimalNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppoiAnimalNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAnimalAndAppoinNextMonth(): Observable<AppoiAnimalNameDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/GetAnimalAndAppoinNextMonth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalAndAppoinNextMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalAndAppoinNextMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppoiAnimalNameDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppoiAnimalNameDto[]>;
        }));
    }

    protected processGetAnimalAndAppoinNextMonth(response: HttpResponseBase): Observable<AppoiAnimalNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppoiAnimalNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param date (optional) 
     * @return OK
     */
    getAppointmentByDate(date: Date | undefined): Observable<GetAppointmentByDateDto[]> {
        let url_ = this.baseUrl + "/api/Appointment/GetAppointmentByDate?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentByDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAppointmentByDateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAppointmentByDateDto[]>;
        }));
    }

    protected processGetAppointmentByDate(response: HttpResponseBase): Observable<GetAppointmentByDateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAppointmentByDateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    countTotalAppointmentssofar(): Observable<number> {
        let url_ = this.baseUrl + "/api/Appointment/countTotalAppointmentssofar";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountTotalAppointmentssofar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountTotalAppointmentssofar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCountTotalAppointmentssofar(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll5(): Observable<AppointmentDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Appointment/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll5(response: HttpResponseBase): Observable<AppointmentDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById5(id: number | undefined): Observable<AppointmentDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Appointment/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDtoApiResponse>;
        }));
    }

    protected processGetById5(response: HttpResponseBase): Observable<AppointmentDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add5(body: AppointmentDto | undefined): Observable<AppointmentDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Appointment/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDtoApiResponse>;
        }));
    }

    protected processAdd5(response: HttpResponseBase): Observable<AppointmentDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update5(body: AppointmentDto | undefined): Observable<AppointmentDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Appointment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDtoApiResponse>;
        }));
    }

    protected processUpdate5(response: HttpResponseBase): Observable<AppointmentDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById5(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Appointment/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById5(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete5(body: AppointmentDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Appointment/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete5(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    auth(body: LoginRequestDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processAuth(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authh(body: LoginRequestDto | undefined): Observable<AuthResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/authh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResponseDtoApiResponse>;
        }));
    }

    protected processAuthh(response: HttpResponseBase): Observable<AuthResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginRequestDto | undefined): Observable<AuthResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResponseDtoApiResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param doctorId (optional) 
     * @param appointmentDate (optional) 
     * @return OK
     */
    getschedulebyStaffId(doctorId: number | undefined, appointmentDate: Date | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DoctorSchedule/GetschedulebyStaffId?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (appointmentDate === null)
            throw new Error("The parameter 'appointmentDate' cannot be null.");
        else if (appointmentDate !== undefined)
            url_ += "appointmentDate=" + encodeURIComponent(appointmentDate ? "" + appointmentDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetschedulebyStaffId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetschedulebyStaffId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetschedulebyStaffId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll6(): Observable<DoctorScheduleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSchedule/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorScheduleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorScheduleDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll6(response: HttpResponseBase): Observable<DoctorScheduleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorScheduleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById6(id: number | undefined): Observable<DoctorScheduleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSchedule/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorScheduleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorScheduleDtoApiResponse>;
        }));
    }

    protected processGetById6(response: HttpResponseBase): Observable<DoctorScheduleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorScheduleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add6(body: DoctorScheduleDto | undefined): Observable<DoctorScheduleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSchedule/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorScheduleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorScheduleDtoApiResponse>;
        }));
    }

    protected processAdd6(response: HttpResponseBase): Observable<DoctorScheduleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorScheduleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update6(body: DoctorScheduleDto | undefined): Observable<DoctorScheduleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSchedule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorScheduleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorScheduleDtoApiResponse>;
        }));
    }

    protected processUpdate6(response: HttpResponseBase): Observable<DoctorScheduleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorScheduleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById6(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSchedule/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById6(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete6(body: DoctorScheduleDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSchedule/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete6(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateSlots(body: SlotGenerationRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DoctorSlot/GenerateSlots";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateSlots(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateSlots(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateSlots(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param doctorId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getAvailableSlots(doctorId: number | undefined, startDate: string | undefined, endDate: string | undefined): Observable<DoctorSlotDto[]> {
        let url_ = this.baseUrl + "/api/DoctorSlot/GetAvailableSlots?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableSlots(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableSlots(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorSlotDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorSlotDto[]>;
        }));
    }

    protected processGetAvailableSlots(response: HttpResponseBase): Observable<DoctorSlotDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DoctorSlotDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param doctorId (optional) 
     * @return OK
     */
    availableDatesWithDoctorId(doctorId: number | undefined): Observable<Date[]> {
        let url_ = this.baseUrl + "/api/DoctorSlot/AvailableDatesWithDoctorId?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableDatesWithDoctorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableDatesWithDoctorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Date[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Date[]>;
        }));
    }

    protected processAvailableDatesWithDoctorId(response: HttpResponseBase): Observable<Date[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(new Date(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param doctorId (optional) 
     * @param date (optional) 
     * @return OK
     */
    availableTimesWithDoctorAndDate(doctorId: number | undefined, date: string | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/DoctorSlot/AvailableTimesWithDoctorAndDate?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableTimesWithDoctorAndDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableTimesWithDoctorAndDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processAvailableTimesWithDoctorAndDate(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll7(): Observable<DoctorSlotDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSlot/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorSlotDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorSlotDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll7(response: HttpResponseBase): Observable<DoctorSlotDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorSlotDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById7(id: number | undefined): Observable<DoctorSlotDtoApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSlot/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorSlotDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorSlotDtoApiResponse>;
        }));
    }

    protected processGetById7(response: HttpResponseBase): Observable<DoctorSlotDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorSlotDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add7(body: DoctorSlotDto | undefined): Observable<DoctorSlotDtoApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSlot/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorSlotDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorSlotDtoApiResponse>;
        }));
    }

    protected processAdd7(response: HttpResponseBase): Observable<DoctorSlotDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorSlotDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update7(body: DoctorSlotDto | undefined): Observable<DoctorSlotDtoApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSlot/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DoctorSlotDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DoctorSlotDtoApiResponse>;
        }));
    }

    protected processUpdate7(response: HttpResponseBase): Observable<DoctorSlotDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoctorSlotDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById7(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSlot/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById7(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete7(body: DoctorSlotDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/DoctorSlot/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete7(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll8(): Observable<InventoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Inventory/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll8(response: HttpResponseBase): Observable<InventoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById8(id: number | undefined): Observable<InventoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Inventory/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDtoApiResponse>;
        }));
    }

    protected processGetById8(response: HttpResponseBase): Observable<InventoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add8(body: InventoryDto | undefined): Observable<InventoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Inventory/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDtoApiResponse>;
        }));
    }

    protected processAdd8(response: HttpResponseBase): Observable<InventoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update8(body: InventoryDto | undefined): Observable<InventoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Inventory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDtoApiResponse>;
        }));
    }

    protected processUpdate8(response: HttpResponseBase): Observable<InventoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById8(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Inventory/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById8(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete8(body: InventoryDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Inventory/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete8(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    weeklyrevenue(): Observable<WeeklyRevenueDto[]> {
        let url_ = this.baseUrl + "/api/Invoice/weeklyrevenue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeeklyrevenue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeeklyrevenue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeeklyRevenueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeeklyRevenueDto[]>;
        }));
    }

    protected processWeeklyrevenue(response: HttpResponseBase): Observable<WeeklyRevenueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeeklyRevenueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    monthlyrevenue(): Observable<WeeklyRevenueDto[]> {
        let url_ = this.baseUrl + "/api/Invoice/monthlyrevenue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMonthlyrevenue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMonthlyrevenue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeeklyRevenueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeeklyRevenueDto[]>;
        }));
    }

    protected processMonthlyrevenue(response: HttpResponseBase): Observable<WeeklyRevenueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeeklyRevenueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    yearlyrevenue(): Observable<WeeklyRevenueDto[]> {
        let url_ = this.baseUrl + "/api/Invoice/yearlyrevenue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYearlyrevenue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYearlyrevenue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeeklyRevenueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeeklyRevenueDto[]>;
        }));
    }

    protected processYearlyrevenue(response: HttpResponseBase): Observable<WeeklyRevenueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeeklyRevenueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    weeklyTotalSumrevenue(): Observable<any> {
        let url_ = this.baseUrl + "/api/Invoice/weeklyTotalSumrevenue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeeklyTotalSumrevenue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeeklyTotalSumrevenue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processWeeklyTotalSumrevenue(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    monthlyTotalSumrevenue(): Observable<any> {
        let url_ = this.baseUrl + "/api/Invoice/monthlyTotalSumrevenue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMonthlyTotalSumrevenue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMonthlyTotalSumrevenue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processMonthlyTotalSumrevenue(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    yearlyTotalSumrevenue(): Observable<any> {
        let url_ = this.baseUrl + "/api/Invoice/yearlyTotalSumrevenue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYearlyTotalSumrevenue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYearlyTotalSumrevenue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processYearlyTotalSumrevenue(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param year (optional) 
     * @return OK
     */
    getRevenueforSpecificYear(year: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Invoice/GetRevenueforSpecificYear?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRevenueforSpecificYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRevenueforSpecificYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetRevenueforSpecificYear(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    yearlyrevenuecomparison(): Observable<any> {
        let url_ = this.baseUrl + "/api/Invoice/yearlyrevenuecomparison";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYearlyrevenuecomparison(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYearlyrevenuecomparison(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processYearlyrevenuecomparison(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    revenuemonthlybyday(): Observable<RevenueByDayDto[]> {
        let url_ = this.baseUrl + "/api/Invoice/Revenuemonthlybyday";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevenuemonthlybyday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevenuemonthlybyday(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RevenueByDayDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RevenueByDayDto[]>;
        }));
    }

    protected processRevenuemonthlybyday(response: HttpResponseBase): Observable<RevenueByDayDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RevenueByDayDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getInvoicesPaginated(pageNumber: number | undefined, pageSize: number | undefined): Observable<InvoiceDtoPaginationResponseDto> {
        let url_ = this.baseUrl + "/api/Invoice/getInvoicesPaginated?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDtoPaginationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDtoPaginationResponseDto>;
        }));
    }

    protected processGetInvoicesPaginated(response: HttpResponseBase): Observable<InvoiceDtoPaginationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDtoPaginationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    searchInvoice(searchTerm: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<InvoiceDtoPaginationResponseDto> {
        let url_ = this.baseUrl + "/api/Invoice/searchInvoice?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDtoPaginationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDtoPaginationResponseDto>;
        }));
    }

    protected processSearchInvoice(response: HttpResponseBase): Observable<InvoiceDtoPaginationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDtoPaginationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = InvoiceDtoPaginationResponseDto.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll9(): Observable<InvoiceDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Invoice/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll9(response: HttpResponseBase): Observable<InvoiceDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById9(id: number | undefined): Observable<InvoiceDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Invoice/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDtoApiResponse>;
        }));
    }

    protected processGetById9(response: HttpResponseBase): Observable<InvoiceDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add9(body: InvoiceDto | undefined): Observable<InvoiceDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Invoice/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDtoApiResponse>;
        }));
    }

    protected processAdd9(response: HttpResponseBase): Observable<InvoiceDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update9(body: InvoiceDto | undefined): Observable<InvoiceDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Invoice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDtoApiResponse>;
        }));
    }

    protected processUpdate9(response: HttpResponseBase): Observable<InvoiceDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById9(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Invoice/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById9(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete9(body: InvoiceDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Invoice/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete9(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @return OK
     */
    getmedicalrecordsbyanimalId(animalId: number | undefined): Observable<MedicalRecordDto[]> {
        let url_ = this.baseUrl + "/api/MedicalRecord/GetmedicalrecordsbyanimalId?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "animalId=" + encodeURIComponent("" + animalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmedicalrecordsbyanimalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmedicalrecordsbyanimalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicalRecordDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicalRecordDto[]>;
        }));
    }

    protected processGetmedicalrecordsbyanimalId(response: HttpResponseBase): Observable<MedicalRecordDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MedicalRecordDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return OK
     */
    updateMedical(id: number | undefined, body: MedicalRecordDto | undefined): Observable<MedicalRecordDto> {
        let url_ = this.baseUrl + "/api/MedicalRecord/updateMedical?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMedical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMedical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicalRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicalRecordDto>;
        }));
    }

    protected processUpdateMedical(response: HttpResponseBase): Observable<MedicalRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicalRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll10(): Observable<MedicalRecordDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/MedicalRecord/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicalRecordDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicalRecordDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll10(response: HttpResponseBase): Observable<MedicalRecordDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicalRecordDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById10(id: number | undefined): Observable<MedicalRecordDtoApiResponse> {
        let url_ = this.baseUrl + "/api/MedicalRecord/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicalRecordDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicalRecordDtoApiResponse>;
        }));
    }

    protected processGetById10(response: HttpResponseBase): Observable<MedicalRecordDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicalRecordDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add10(body: MedicalRecordDto | undefined): Observable<MedicalRecordDtoApiResponse> {
        let url_ = this.baseUrl + "/api/MedicalRecord/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicalRecordDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicalRecordDtoApiResponse>;
        }));
    }

    protected processAdd10(response: HttpResponseBase): Observable<MedicalRecordDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicalRecordDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update10(body: MedicalRecordDto | undefined): Observable<MedicalRecordDtoApiResponse> {
        let url_ = this.baseUrl + "/api/MedicalRecord/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MedicalRecordDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MedicalRecordDtoApiResponse>;
        }));
    }

    protected processUpdate10(response: HttpResponseBase): Observable<MedicalRecordDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicalRecordDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById10(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/MedicalRecord/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById10(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete10(body: MedicalRecordDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/MedicalRecord/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete10(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete10(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param ownerId (optional) 
     * @return OK
     */
    getAnimalsByOwnerId(ownerId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Owner/GetAnimalsByOwnerId?";
        if (ownerId === null)
            throw new Error("The parameter 'ownerId' cannot be null.");
        else if (ownerId !== undefined)
            url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnimalsByOwnerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnimalsByOwnerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAnimalsByOwnerId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @return OK
     */
    ownerbyanimalID(animalId: number | undefined): Observable<OwnerDto> {
        let url_ = this.baseUrl + "/api/Owner/ownerbyanimalID?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "animalId=" + encodeURIComponent("" + animalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOwnerbyanimalID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOwnerbyanimalID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto>;
        }));
    }

    protected processOwnerbyanimalID(response: HttpResponseBase): Observable<OwnerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addownerwithanimal(body: AddOwnerAndAnimalDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Owner/addownerwithanimal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddownerwithanimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddownerwithanimal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddownerwithanimal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param ownerId (optional) 
     * @return OK
     */
    deleteownerwithanimal(ownerId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Owner/deleteownerwithanimal?";
        if (ownerId === null)
            throw new Error("The parameter 'ownerId' cannot be null.");
        else if (ownerId !== undefined)
            url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteownerwithanimal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteownerwithanimal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteownerwithanimal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return OK
     */
    getOwnersbyName(name: string | undefined): Observable<OwnerDto[]> {
        let url_ = this.baseUrl + "/api/Owner/GetOwnersbyName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnersbyName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnersbyName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto[]>;
        }));
    }

    protected processGetOwnersbyName(response: HttpResponseBase): Observable<OwnerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OwnerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllOwnerNames(): Observable<OwnerDto[]> {
        let url_ = this.baseUrl + "/api/Owner/GetAllOwnerNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOwnerNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOwnerNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto[]>;
        }));
    }

    protected processGetAllOwnerNames(response: HttpResponseBase): Observable<OwnerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OwnerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    getOwnerIdByUserId(userId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Owner/getOwnerIdByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnerIdByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerIdByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetOwnerIdByUserId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return OK
     */
    searchOwnerNames(searchTerm: string | undefined): Observable<OwnerDto[]> {
        let url_ = this.baseUrl + "/api/Owner/SearchOwnerNames?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchOwnerNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchOwnerNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDto[]>;
        }));
    }

    protected processSearchOwnerNames(response: HttpResponseBase): Observable<OwnerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OwnerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll11(): Observable<OwnerDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Owner/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll11(response: HttpResponseBase): Observable<OwnerDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById11(id: number | undefined): Observable<OwnerDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Owner/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDtoApiResponse>;
        }));
    }

    protected processGetById11(response: HttpResponseBase): Observable<OwnerDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add11(body: OwnerDto | undefined): Observable<OwnerDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Owner/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDtoApiResponse>;
        }));
    }

    protected processAdd11(response: HttpResponseBase): Observable<OwnerDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update11(body: OwnerDto | undefined): Observable<OwnerDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Owner/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OwnerDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OwnerDtoApiResponse>;
        }));
    }

    protected processUpdate11(response: HttpResponseBase): Observable<OwnerDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OwnerDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById11(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Owner/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById11(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete11(body: OwnerDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Owner/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete11(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param petForAdoptionId (optional) 
     * @param breed (optional) 
     * @param species (optional) 
     * @param petBirthDate (optional) 
     * @param petCondition (optional) 
     * @param gender (optional) 
     * @param weight (optional) 
     * @param adoptionStatusId (optional) 
     * @param petName (optional) 
     * @param imageUrl (optional) 
     * @param posterFile (optional) 
     * @return OK
     */
    addPetwithImage(petForAdoptionId: number | undefined, breed: string | undefined, species: string | undefined, petBirthDate: Date | undefined, petCondition: string | undefined, gender: string | undefined, weight: number | undefined, adoptionStatusId: number | undefined, petName: string | undefined, imageUrl: string | undefined, posterFile: FileParameter | undefined): Observable<AddPetForAdoptionDto[]> {
        let url_ = this.baseUrl + "/api/PetForAdoption/addPetwithImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (petForAdoptionId === null || petForAdoptionId === undefined)
            throw new Error("The parameter 'petForAdoptionId' cannot be null.");
        else
            content_.append("PetForAdoptionId", petForAdoptionId.toString());
        if (breed === null || breed === undefined)
            throw new Error("The parameter 'breed' cannot be null.");
        else
            content_.append("Breed", breed.toString());
        if (species === null || species === undefined)
            throw new Error("The parameter 'species' cannot be null.");
        else
            content_.append("Species", species.toString());
        if (petBirthDate === null || petBirthDate === undefined)
            throw new Error("The parameter 'petBirthDate' cannot be null.");
        else
            content_.append("PetBirthDate", petBirthDate.toJSON());
        if (petCondition === null || petCondition === undefined)
            throw new Error("The parameter 'petCondition' cannot be null.");
        else
            content_.append("PetCondition", petCondition.toString());
        if (gender === null || gender === undefined)
            throw new Error("The parameter 'gender' cannot be null.");
        else
            content_.append("Gender", gender.toString());
        if (weight === null || weight === undefined)
            throw new Error("The parameter 'weight' cannot be null.");
        else
            content_.append("Weight", weight.toString());
        if (adoptionStatusId === null || adoptionStatusId === undefined)
            throw new Error("The parameter 'adoptionStatusId' cannot be null.");
        else
            content_.append("AdoptionStatusId", adoptionStatusId.toString());
        if (petName === null || petName === undefined)
            throw new Error("The parameter 'petName' cannot be null.");
        else
            content_.append("PetName", petName.toString());
        if (imageUrl === null || imageUrl === undefined)
            throw new Error("The parameter 'imageUrl' cannot be null.");
        else
            content_.append("ImageUrl", imageUrl.toString());
        if (posterFile === null || posterFile === undefined)
            throw new Error("The parameter 'posterFile' cannot be null.");
        else
            content_.append("posterFile", posterFile.data, posterFile.fileName ? posterFile.fileName : "posterFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPetwithImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPetwithImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddPetForAdoptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddPetForAdoptionDto[]>;
        }));
    }

    protected processAddPetwithImage(response: HttpResponseBase): Observable<AddPetForAdoptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddPetForAdoptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param imagePath (optional) 
     * @return OK
     */
    downloadImage(imagePath: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PetForAdoption/DownloadImage?";
        if (imagePath === null)
            throw new Error("The parameter 'imagePath' cannot be null.");
        else if (imagePath !== undefined)
            url_ += "imagePath=" + encodeURIComponent("" + imagePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllPetforAdoptionNames(): Observable<PetForAdoptionDto[]> {
        let url_ = this.baseUrl + "/api/PetForAdoption/GetAllPetforAdoptionNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPetforAdoptionNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPetforAdoptionNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetForAdoptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetForAdoptionDto[]>;
        }));
    }

    protected processGetAllPetforAdoptionNames(response: HttpResponseBase): Observable<PetForAdoptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PetForAdoptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAvailablePets(): Observable<PetForAdoptionDto[]> {
        let url_ = this.baseUrl + "/api/PetForAdoption/GetAvailablePets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailablePets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailablePets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetForAdoptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetForAdoptionDto[]>;
        }));
    }

    protected processGetAvailablePets(response: HttpResponseBase): Observable<PetForAdoptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PetForAdoptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param petId (optional) 
     * @return OK
     */
    markPetAsadopted(petId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PetForAdoption/markPetAsadopted?";
        if (petId === null)
            throw new Error("The parameter 'petId' cannot be null.");
        else if (petId !== undefined)
            url_ += "petId=" + encodeURIComponent("" + petId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkPetAsadopted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkPetAsadopted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkPetAsadopted(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param petId (optional) 
     * @return OK
     */
    deletePetWithQuest(petId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PetForAdoption/DeletePetWithQuest?";
        if (petId === null)
            throw new Error("The parameter 'petId' cannot be null.");
        else if (petId !== undefined)
            url_ += "petId=" + encodeURIComponent("" + petId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePetWithQuest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePetWithQuest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePetWithQuest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll12(): Observable<PetForAdoptionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/PetForAdoption/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetForAdoptionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetForAdoptionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll12(response: HttpResponseBase): Observable<PetForAdoptionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetForAdoptionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById12(id: number | undefined): Observable<PetForAdoptionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/PetForAdoption/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetForAdoptionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetForAdoptionDtoApiResponse>;
        }));
    }

    protected processGetById12(response: HttpResponseBase): Observable<PetForAdoptionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetForAdoptionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add12(body: PetForAdoptionDto | undefined): Observable<PetForAdoptionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/PetForAdoption/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetForAdoptionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetForAdoptionDtoApiResponse>;
        }));
    }

    protected processAdd12(response: HttpResponseBase): Observable<PetForAdoptionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetForAdoptionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update12(body: PetForAdoptionDto | undefined): Observable<PetForAdoptionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/PetForAdoption/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetForAdoptionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetForAdoptionDtoApiResponse>;
        }));
    }

    protected processUpdate12(response: HttpResponseBase): Observable<PetForAdoptionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetForAdoptionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById12(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/PetForAdoption/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById12(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete12(body: PetForAdoptionDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/PetForAdoption/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete12(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param staffId (optional) 
     * @return OK
     */
    getStaffNamebyId(staffId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Staff/GetStaffNamebyId?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "staffId=" + encodeURIComponent("" + staffId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffNamebyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffNamebyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetStaffNamebyId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getStaffNames(): Observable<GetStaffNamesdto[]> {
        let url_ = this.baseUrl + "/api/Staff/GetStaffNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStaffNamesdto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStaffNamesdto[]>;
        }));
    }

    protected processGetStaffNames(response: HttpResponseBase): Observable<GetStaffNamesdto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetStaffNamesdto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    staffwithroles(): Observable<StaffWithRoleDTO[]> {
        let url_ = this.baseUrl + "/api/Staff/Staffwithroles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStaffwithroles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStaffwithroles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffWithRoleDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffWithRoleDTO[]>;
        }));
    }

    protected processStaffwithroles(response: HttpResponseBase): Observable<StaffWithRoleDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaffWithRoleDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll13(): Observable<StaffDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Staff/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll13(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll13(response: HttpResponseBase): Observable<StaffDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById13(id: number | undefined): Observable<StaffDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Staff/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById13(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDtoApiResponse>;
        }));
    }

    protected processGetById13(response: HttpResponseBase): Observable<StaffDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add13(body: StaffDto | undefined): Observable<StaffDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Staff/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd13(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDtoApiResponse>;
        }));
    }

    protected processAdd13(response: HttpResponseBase): Observable<StaffDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update13(body: StaffDto | undefined): Observable<StaffDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Staff/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate13(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDtoApiResponse>;
        }));
    }

    protected processUpdate13(response: HttpResponseBase): Observable<StaffDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById13(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Staff/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById13(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById13(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete13(body: StaffDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Staff/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete13(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete13(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll14(): Observable<StaffRoleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/StaffRole/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll14(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffRoleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffRoleDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll14(response: HttpResponseBase): Observable<StaffRoleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffRoleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById14(id: number | undefined): Observable<StaffRoleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/StaffRole/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById14(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffRoleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffRoleDtoApiResponse>;
        }));
    }

    protected processGetById14(response: HttpResponseBase): Observable<StaffRoleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffRoleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add14(body: StaffRoleDto | undefined): Observable<StaffRoleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/StaffRole/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd14(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffRoleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffRoleDtoApiResponse>;
        }));
    }

    protected processAdd14(response: HttpResponseBase): Observable<StaffRoleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffRoleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update14(body: StaffRoleDto | undefined): Observable<StaffRoleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/StaffRole/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate14(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffRoleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffRoleDtoApiResponse>;
        }));
    }

    protected processUpdate14(response: HttpResponseBase): Observable<StaffRoleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffRoleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById14(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/StaffRole/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById14(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById14(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete14(body: StaffRoleDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/StaffRole/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete14(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete14(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: UserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserContoller/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll15(): Observable<UserDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/UserContoller/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll15(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll15(response: HttpResponseBase): Observable<UserDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById15(id: number | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/UserContoller/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById15(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processGetById15(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add15(body: UserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/UserContoller/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd15(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processAdd15(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update15(body: UserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/UserContoller/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate15(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUpdate15(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById15(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/UserContoller/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById15(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById15(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete15(body: UserDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/UserContoller/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete15(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete15(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @return OK
     */
    getvaccinationbyanimalId(animalId: number | undefined): Observable<VaccinationDto[]> {
        let url_ = this.baseUrl + "/api/Vaccination/GetvaccinationbyanimalId?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "animalId=" + encodeURIComponent("" + animalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetvaccinationbyanimalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetvaccinationbyanimalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VaccinationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VaccinationDto[]>;
        }));
    }

    protected processGetvaccinationbyanimalId(response: HttpResponseBase): Observable<VaccinationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VaccinationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param vaccinationTypeId (optional) 
     * @return OK
     */
    vaccinationwithvaccineType(vaccinationTypeId: number | undefined): Observable<VaccinationWithVaccineTypeDto> {
        let url_ = this.baseUrl + "/api/Vaccination/vaccinationwithvaccineType?";
        if (vaccinationTypeId === null)
            throw new Error("The parameter 'vaccinationTypeId' cannot be null.");
        else if (vaccinationTypeId !== undefined)
            url_ += "vaccinationTypeId=" + encodeURIComponent("" + vaccinationTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVaccinationwithvaccineType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVaccinationwithvaccineType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VaccinationWithVaccineTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VaccinationWithVaccineTypeDto>;
        }));
    }

    protected processVaccinationwithvaccineType(response: HttpResponseBase): Observable<VaccinationWithVaccineTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VaccinationWithVaccineTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param vaccinationId (optional) 
     * @return OK
     */
    getVaccineTypeIdbyVaccinationId(vaccinationId: number | undefined): Observable<VaccinationDto> {
        let url_ = this.baseUrl + "/api/Vaccination/getVaccineTypeIdbyVaccinationId?";
        if (vaccinationId === null)
            throw new Error("The parameter 'vaccinationId' cannot be null.");
        else if (vaccinationId !== undefined)
            url_ += "vaccinationId=" + encodeURIComponent("" + vaccinationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVaccineTypeIdbyVaccinationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVaccineTypeIdbyVaccinationId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VaccinationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VaccinationDto>;
        }));
    }

    protected processGetVaccineTypeIdbyVaccinationId(response: HttpResponseBase): Observable<VaccinationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VaccinationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll16(): Observable<VaccinationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Vaccination/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll16(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VaccinationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VaccinationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll16(response: HttpResponseBase): Observable<VaccinationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VaccinationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById16(id: number | undefined): Observable<VaccinationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Vaccination/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById16(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VaccinationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VaccinationDtoApiResponse>;
        }));
    }

    protected processGetById16(response: HttpResponseBase): Observable<VaccinationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VaccinationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add16(body: VaccinationDto | undefined): Observable<VaccinationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Vaccination/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd16(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VaccinationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VaccinationDtoApiResponse>;
        }));
    }

    protected processAdd16(response: HttpResponseBase): Observable<VaccinationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VaccinationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update16(body: VaccinationDto | undefined): Observable<VaccinationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Vaccination/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate16(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VaccinationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VaccinationDtoApiResponse>;
        }));
    }

    protected processUpdate16(response: HttpResponseBase): Observable<VaccinationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VaccinationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById16(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Vaccination/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById16(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById16(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete16(body: VaccinationDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Vaccination/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete16(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete16(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param xrayId (optional) 
     * @param imageUrl (optional) 
     * @param animalId (optional) 
     * @param createdDate (optional) 
     * @param posterFile (optional) 
     * @return OK
     */
    addXraywithImage(xrayId: number | undefined, imageUrl: string | undefined, animalId: number | undefined, createdDate: Date | undefined, posterFile: FileParameter | undefined): Observable<XrayImageDto[]> {
        let url_ = this.baseUrl + "/api/XrayImage/addXraywithImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (xrayId === null || xrayId === undefined)
            throw new Error("The parameter 'xrayId' cannot be null.");
        else
            content_.append("XrayId", xrayId.toString());
        if (imageUrl === null || imageUrl === undefined)
            throw new Error("The parameter 'imageUrl' cannot be null.");
        else
            content_.append("ImageUrl", imageUrl.toString());
        if (animalId === null || animalId === undefined)
            throw new Error("The parameter 'animalId' cannot be null.");
        else
            content_.append("AnimalId", animalId.toString());
        if (createdDate === null || createdDate === undefined)
            throw new Error("The parameter 'createdDate' cannot be null.");
        else
            content_.append("CreatedDate", createdDate.toJSON());
        if (posterFile === null || posterFile === undefined)
            throw new Error("The parameter 'posterFile' cannot be null.");
        else
            content_.append("posterFile", posterFile.data, posterFile.fileName ? posterFile.fileName : "posterFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddXraywithImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddXraywithImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XrayImageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XrayImageDto[]>;
        }));
    }

    protected processAddXraywithImage(response: HttpResponseBase): Observable<XrayImageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(XrayImageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param imagePath (optional) 
     * @return OK
     */
    downloadXrayImage(imagePath: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/XrayImage/DownloadXrayImage?";
        if (imagePath === null)
            throw new Error("The parameter 'imagePath' cannot be null.");
        else if (imagePath !== undefined)
            url_ += "imagePath=" + encodeURIComponent("" + imagePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadXrayImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadXrayImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadXrayImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @return OK
     */
    getXRayByAnimalId(animalId: number | undefined): Observable<XrayImageDto[]> {
        let url_ = this.baseUrl + "/api/XrayImage/getXRayByAnimalId?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "animalId=" + encodeURIComponent("" + animalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXRayByAnimalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXRayByAnimalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XrayImageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XrayImageDto[]>;
        }));
    }

    protected processGetXRayByAnimalId(response: HttpResponseBase): Observable<XrayImageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(XrayImageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll17(): Observable<XrayImageDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/XrayImage/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll17(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XrayImageDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XrayImageDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll17(response: HttpResponseBase): Observable<XrayImageDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XrayImageDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById17(id: number | undefined): Observable<XrayImageDtoApiResponse> {
        let url_ = this.baseUrl + "/api/XrayImage/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById17(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XrayImageDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XrayImageDtoApiResponse>;
        }));
    }

    protected processGetById17(response: HttpResponseBase): Observable<XrayImageDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XrayImageDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add17(body: XrayImageDto | undefined): Observable<XrayImageDtoApiResponse> {
        let url_ = this.baseUrl + "/api/XrayImage/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd17(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XrayImageDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XrayImageDtoApiResponse>;
        }));
    }

    protected processAdd17(response: HttpResponseBase): Observable<XrayImageDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XrayImageDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update17(body: XrayImageDto | undefined): Observable<XrayImageDtoApiResponse> {
        let url_ = this.baseUrl + "/api/XrayImage/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate17(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XrayImageDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XrayImageDtoApiResponse>;
        }));
    }

    protected processUpdate17(response: HttpResponseBase): Observable<XrayImageDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XrayImageDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById17(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/XrayImage/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById17(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById17(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete17(body: XrayImageDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/XrayImage/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete17(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete17(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param animalId (optional) 
     * @return OK
     */
    getLabbyanimalId(animalId: number | undefined): Observable<ZLabResultDto[]> {
        let url_ = this.baseUrl + "/api/ZLabResult/GetLabbyanimalId?";
        if (animalId === null)
            throw new Error("The parameter 'animalId' cannot be null.");
        else if (animalId !== undefined)
            url_ += "animalId=" + encodeURIComponent("" + animalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLabbyanimalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLabbyanimalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZLabResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZLabResultDto[]>;
        }));
    }

    protected processGetLabbyanimalId(response: HttpResponseBase): Observable<ZLabResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZLabResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addLabResult(body: ZLabResultDto | undefined): Observable<ZLabResultResponseDto> {
        let url_ = this.baseUrl + "/api/ZLabResult/AddLabResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLabResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLabResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZLabResultResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZLabResultResponseDto>;
        }));
    }

    protected processAddLabResult(response: HttpResponseBase): Observable<ZLabResultResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZLabResultResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll18(): Observable<ZLabResultDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/ZLabResult/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll18(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZLabResultDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZLabResultDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll18(response: HttpResponseBase): Observable<ZLabResultDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZLabResultDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById18(id: number | undefined): Observable<ZLabResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZLabResult/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById18(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZLabResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZLabResultDtoApiResponse>;
        }));
    }

    protected processGetById18(response: HttpResponseBase): Observable<ZLabResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZLabResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add18(body: ZLabResultDto | undefined): Observable<ZLabResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZLabResult/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd18(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZLabResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZLabResultDtoApiResponse>;
        }));
    }

    protected processAdd18(response: HttpResponseBase): Observable<ZLabResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZLabResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update18(body: ZLabResultDto | undefined): Observable<ZLabResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZLabResult/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate18(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZLabResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZLabResultDtoApiResponse>;
        }));
    }

    protected processUpdate18(response: HttpResponseBase): Observable<ZLabResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZLabResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById18(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZLabResult/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById18(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById18(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete18(body: ZLabResultDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZLabResult/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete18(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete18(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll19(): Observable<ZTestNormalRangeDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/ZTestNormalRange/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll19(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZTestNormalRangeDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZTestNormalRangeDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll19(response: HttpResponseBase): Observable<ZTestNormalRangeDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZTestNormalRangeDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById19(id: number | undefined): Observable<ZTestNormalRangeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZTestNormalRange/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById19(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZTestNormalRangeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZTestNormalRangeDtoApiResponse>;
        }));
    }

    protected processGetById19(response: HttpResponseBase): Observable<ZTestNormalRangeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZTestNormalRangeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add19(body: ZTestNormalRangeDto | undefined): Observable<ZTestNormalRangeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZTestNormalRange/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd19(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZTestNormalRangeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZTestNormalRangeDtoApiResponse>;
        }));
    }

    protected processAdd19(response: HttpResponseBase): Observable<ZTestNormalRangeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZTestNormalRangeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update19(body: ZTestNormalRangeDto | undefined): Observable<ZTestNormalRangeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZTestNormalRange/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate19(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZTestNormalRangeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZTestNormalRangeDtoApiResponse>;
        }));
    }

    protected processUpdate19(response: HttpResponseBase): Observable<ZTestNormalRangeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZTestNormalRangeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById19(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZTestNormalRange/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById19(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById19(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete19(body: ZTestNormalRangeDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZTestNormalRange/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete19(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete19(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    latestReviews(): Observable<ZZratingDto[]> {
        let url_ = this.baseUrl + "/api/ZZRating/latestReviews";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLatestReviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLatestReviews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZratingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZratingDto[]>;
        }));
    }

    protected processLatestReviews(response: HttpResponseBase): Observable<ZZratingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZZratingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll20(): Observable<ZZratingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/ZZRating/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll20(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZratingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZratingDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll20(response: HttpResponseBase): Observable<ZZratingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZratingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById20(id: number | undefined): Observable<ZZratingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZZRating/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById20(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZratingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZratingDtoApiResponse>;
        }));
    }

    protected processGetById20(response: HttpResponseBase): Observable<ZZratingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZratingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add20(body: ZZratingDto | undefined): Observable<ZZratingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZZRating/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd20(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZratingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZratingDtoApiResponse>;
        }));
    }

    protected processAdd20(response: HttpResponseBase): Observable<ZZratingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZratingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update20(body: ZZratingDto | undefined): Observable<ZZratingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZZRating/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate20(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZratingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZratingDtoApiResponse>;
        }));
    }

    protected processUpdate20(response: HttpResponseBase): Observable<ZZratingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZratingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById20(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZZRating/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById20(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById20(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete20(body: ZZratingDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZZRating/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete20(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete20(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAll21(): Observable<ZZVaccineTypeDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/ZZVaccineType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll21(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZVaccineTypeDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZVaccineTypeDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAll21(response: HttpResponseBase): Observable<ZZVaccineTypeDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZVaccineTypeDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById21(id: number | undefined): Observable<ZZVaccineTypeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZZVaccineType/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById21(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZVaccineTypeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZVaccineTypeDtoApiResponse>;
        }));
    }

    protected processGetById21(response: HttpResponseBase): Observable<ZZVaccineTypeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZVaccineTypeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add21(body: ZZVaccineTypeDto | undefined): Observable<ZZVaccineTypeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZZVaccineType/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd21(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZVaccineTypeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZVaccineTypeDtoApiResponse>;
        }));
    }

    protected processAdd21(response: HttpResponseBase): Observable<ZZVaccineTypeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZVaccineTypeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update21(body: ZZVaccineTypeDto | undefined): Observable<ZZVaccineTypeDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ZZVaccineType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate21(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZZVaccineTypeDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZZVaccineTypeDtoApiResponse>;
        }));
    }

    protected processUpdate21(response: HttpResponseBase): Observable<ZZVaccineTypeDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZZVaccineTypeDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteById21(id: number | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZZVaccineType/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById21(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteById21(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete21(body: ZZVaccineTypeDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ZZVaccineType/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete21(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDelete21(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AddAdoptionQuestWithOwnerDTO implements IAddAdoptionQuestWithOwnerDTO {
    adoptionQuestionnaireId?: number;
    userId?: number;
    occupation?: string | null;
    salary?: number;
    isMarried?: boolean;
    isHouseholdAware?: boolean;
    hasOwnedPetBefore?: boolean;
    petForAdoptionId?: number;
    reasonForAdoption?: string | null;
    createdAt?: Date;
    owner?: OwnerDto;

    constructor(data?: IAddAdoptionQuestWithOwnerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adoptionQuestionnaireId = _data["adoptionQuestionnaireId"] !== undefined ? _data["adoptionQuestionnaireId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.occupation = _data["occupation"] !== undefined ? _data["occupation"] : <any>null;
            this.salary = _data["salary"] !== undefined ? _data["salary"] : <any>null;
            this.isMarried = _data["isMarried"] !== undefined ? _data["isMarried"] : <any>null;
            this.isHouseholdAware = _data["isHouseholdAware"] !== undefined ? _data["isHouseholdAware"] : <any>null;
            this.hasOwnedPetBefore = _data["hasOwnedPetBefore"] !== undefined ? _data["hasOwnedPetBefore"] : <any>null;
            this.petForAdoptionId = _data["petForAdoptionId"] !== undefined ? _data["petForAdoptionId"] : <any>null;
            this.reasonForAdoption = _data["reasonForAdoption"] !== undefined ? _data["reasonForAdoption"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.owner = _data["owner"] ? OwnerDto.fromJS(_data["owner"]) : <any>null;
        }
    }

    static fromJS(data: any): AddAdoptionQuestWithOwnerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddAdoptionQuestWithOwnerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adoptionQuestionnaireId"] = this.adoptionQuestionnaireId !== undefined ? this.adoptionQuestionnaireId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["occupation"] = this.occupation !== undefined ? this.occupation : <any>null;
        data["salary"] = this.salary !== undefined ? this.salary : <any>null;
        data["isMarried"] = this.isMarried !== undefined ? this.isMarried : <any>null;
        data["isHouseholdAware"] = this.isHouseholdAware !== undefined ? this.isHouseholdAware : <any>null;
        data["hasOwnedPetBefore"] = this.hasOwnedPetBefore !== undefined ? this.hasOwnedPetBefore : <any>null;
        data["petForAdoptionId"] = this.petForAdoptionId !== undefined ? this.petForAdoptionId : <any>null;
        data["reasonForAdoption"] = this.reasonForAdoption !== undefined ? this.reasonForAdoption : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>null;
        return data;
    }
}

export interface IAddAdoptionQuestWithOwnerDTO {
    adoptionQuestionnaireId?: number;
    userId?: number;
    occupation?: string | null;
    salary?: number;
    isMarried?: boolean;
    isHouseholdAware?: boolean;
    hasOwnedPetBefore?: boolean;
    petForAdoptionId?: number;
    reasonForAdoption?: string | null;
    createdAt?: Date;
    owner?: OwnerDto;
}

export class AddOwnerAndAnimalDto implements IAddOwnerAndAnimalDto {
    ownerId?: number;
    fullName?: string | null;
    address?: string | null;
    ownerEmail?: string | null;
    phone?: string | null;
    ownerBirthDate?: Date;
    animals?: AnimalDto;

    constructor(data?: IAddOwnerAndAnimalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.ownerEmail = _data["ownerEmail"] !== undefined ? _data["ownerEmail"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.ownerBirthDate = _data["ownerBirthDate"] ? new Date(_data["ownerBirthDate"].toString()) : <any>null;
            this.animals = _data["animals"] ? AnimalDto.fromJS(_data["animals"]) : <any>null;
        }
    }

    static fromJS(data: any): AddOwnerAndAnimalDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddOwnerAndAnimalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["ownerEmail"] = this.ownerEmail !== undefined ? this.ownerEmail : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["ownerBirthDate"] = this.ownerBirthDate ? this.ownerBirthDate.toISOString() : <any>null;
        data["animals"] = this.animals ? this.animals.toJSON() : <any>null;
        return data;
    }
}

export interface IAddOwnerAndAnimalDto {
    ownerId?: number;
    fullName?: string | null;
    address?: string | null;
    ownerEmail?: string | null;
    phone?: string | null;
    ownerBirthDate?: Date;
    animals?: AnimalDto;
}

export class AddPetForAdoptionDto implements IAddPetForAdoptionDto {
    petForAdoptionId?: number;
    breed?: string | null;
    species?: string | null;
    petBirthDate?: Date;
    petCondition?: string | null;
    gender?: string | null;
    weight?: number;
    adoptionStatusId?: number;
    petName?: string | null;
    imageUrl?: string | null;

    constructor(data?: IAddPetForAdoptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petForAdoptionId = _data["petForAdoptionId"] !== undefined ? _data["petForAdoptionId"] : <any>null;
            this.breed = _data["breed"] !== undefined ? _data["breed"] : <any>null;
            this.species = _data["species"] !== undefined ? _data["species"] : <any>null;
            this.petBirthDate = _data["petBirthDate"] ? new Date(_data["petBirthDate"].toString()) : <any>null;
            this.petCondition = _data["petCondition"] !== undefined ? _data["petCondition"] : <any>null;
            this.gender = _data["gender"] !== undefined ? _data["gender"] : <any>null;
            this.weight = _data["weight"] !== undefined ? _data["weight"] : <any>null;
            this.adoptionStatusId = _data["adoptionStatusId"] !== undefined ? _data["adoptionStatusId"] : <any>null;
            this.petName = _data["petName"] !== undefined ? _data["petName"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): AddPetForAdoptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddPetForAdoptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petForAdoptionId"] = this.petForAdoptionId !== undefined ? this.petForAdoptionId : <any>null;
        data["breed"] = this.breed !== undefined ? this.breed : <any>null;
        data["species"] = this.species !== undefined ? this.species : <any>null;
        data["petBirthDate"] = this.petBirthDate ? formatDate(this.petBirthDate) : <any>null;
        data["petCondition"] = this.petCondition !== undefined ? this.petCondition : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["weight"] = this.weight !== undefined ? this.weight : <any>null;
        data["adoptionStatusId"] = this.adoptionStatusId !== undefined ? this.adoptionStatusId : <any>null;
        data["petName"] = this.petName !== undefined ? this.petName : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export interface IAddPetForAdoptionDto {
    petForAdoptionId?: number;
    breed?: string | null;
    species?: string | null;
    petBirthDate?: Date;
    petCondition?: string | null;
    gender?: string | null;
    weight?: number;
    adoptionStatusId?: number;
    petName?: string | null;
    imageUrl?: string | null;
}

export class AdoptionQuestionnaireDto implements IAdoptionQuestionnaireDto {
    adoptionQuestionnaireId?: number;
    userId?: number | null;
    occupation?: string | null;
    salary?: number;
    isMarried?: boolean;
    hasChildren?: boolean;
    isHouseholdAware?: boolean;
    hasOwnedPetBefore?: boolean;
    petForAdoptionId?: number;
    hasAllergiesAsthma?: boolean;
    whoWillBeReponsible?: string | null;
    leftAlone?: string | null;
    ifSick?: string | null;
    reasonForAdoption?: string | null;
    questionStatus?: string | null;
    createdAt?: Date;

    constructor(data?: IAdoptionQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adoptionQuestionnaireId = _data["adoptionQuestionnaireId"] !== undefined ? _data["adoptionQuestionnaireId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.occupation = _data["occupation"] !== undefined ? _data["occupation"] : <any>null;
            this.salary = _data["salary"] !== undefined ? _data["salary"] : <any>null;
            this.isMarried = _data["isMarried"] !== undefined ? _data["isMarried"] : <any>null;
            this.hasChildren = _data["hasChildren"] !== undefined ? _data["hasChildren"] : <any>null;
            this.isHouseholdAware = _data["isHouseholdAware"] !== undefined ? _data["isHouseholdAware"] : <any>null;
            this.hasOwnedPetBefore = _data["hasOwnedPetBefore"] !== undefined ? _data["hasOwnedPetBefore"] : <any>null;
            this.petForAdoptionId = _data["petForAdoptionId"] !== undefined ? _data["petForAdoptionId"] : <any>null;
            this.hasAllergiesAsthma = _data["hasAllergiesAsthma"] !== undefined ? _data["hasAllergiesAsthma"] : <any>null;
            this.whoWillBeReponsible = _data["whoWillBeReponsible"] !== undefined ? _data["whoWillBeReponsible"] : <any>null;
            this.leftAlone = _data["leftAlone"] !== undefined ? _data["leftAlone"] : <any>null;
            this.ifSick = _data["ifSick"] !== undefined ? _data["ifSick"] : <any>null;
            this.reasonForAdoption = _data["reasonForAdoption"] !== undefined ? _data["reasonForAdoption"] : <any>null;
            this.questionStatus = _data["questionStatus"] !== undefined ? _data["questionStatus"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): AdoptionQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdoptionQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adoptionQuestionnaireId"] = this.adoptionQuestionnaireId !== undefined ? this.adoptionQuestionnaireId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["occupation"] = this.occupation !== undefined ? this.occupation : <any>null;
        data["salary"] = this.salary !== undefined ? this.salary : <any>null;
        data["isMarried"] = this.isMarried !== undefined ? this.isMarried : <any>null;
        data["hasChildren"] = this.hasChildren !== undefined ? this.hasChildren : <any>null;
        data["isHouseholdAware"] = this.isHouseholdAware !== undefined ? this.isHouseholdAware : <any>null;
        data["hasOwnedPetBefore"] = this.hasOwnedPetBefore !== undefined ? this.hasOwnedPetBefore : <any>null;
        data["petForAdoptionId"] = this.petForAdoptionId !== undefined ? this.petForAdoptionId : <any>null;
        data["hasAllergiesAsthma"] = this.hasAllergiesAsthma !== undefined ? this.hasAllergiesAsthma : <any>null;
        data["whoWillBeReponsible"] = this.whoWillBeReponsible !== undefined ? this.whoWillBeReponsible : <any>null;
        data["leftAlone"] = this.leftAlone !== undefined ? this.leftAlone : <any>null;
        data["ifSick"] = this.ifSick !== undefined ? this.ifSick : <any>null;
        data["reasonForAdoption"] = this.reasonForAdoption !== undefined ? this.reasonForAdoption : <any>null;
        data["questionStatus"] = this.questionStatus !== undefined ? this.questionStatus : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        return data;
    }
}

export interface IAdoptionQuestionnaireDto {
    adoptionQuestionnaireId?: number;
    userId?: number | null;
    occupation?: string | null;
    salary?: number;
    isMarried?: boolean;
    hasChildren?: boolean;
    isHouseholdAware?: boolean;
    hasOwnedPetBefore?: boolean;
    petForAdoptionId?: number;
    hasAllergiesAsthma?: boolean;
    whoWillBeReponsible?: string | null;
    leftAlone?: string | null;
    ifSick?: string | null;
    reasonForAdoption?: string | null;
    questionStatus?: string | null;
    createdAt?: Date;
}

export class AdoptionQuestionnaireDtoApiResponse implements IAdoptionQuestionnaireDtoApiResponse {
    success?: boolean;
    data?: AdoptionQuestionnaireDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAdoptionQuestionnaireDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? AdoptionQuestionnaireDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AdoptionQuestionnaireDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdoptionQuestionnaireDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAdoptionQuestionnaireDtoApiResponse {
    success?: boolean;
    data?: AdoptionQuestionnaireDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class AdoptionQuestionnaireDtoIEnumerableApiResponse implements IAdoptionQuestionnaireDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AdoptionQuestionnaireDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAdoptionQuestionnaireDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AdoptionQuestionnaireDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AdoptionQuestionnaireDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdoptionQuestionnaireDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAdoptionQuestionnaireDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AdoptionQuestionnaireDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class AdoptionStatusDto implements IAdoptionStatusDto {
    adoptionStatusId?: number;
    adoptionStatusName?: string | null;

    constructor(data?: IAdoptionStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adoptionStatusId = _data["adoptionStatusId"] !== undefined ? _data["adoptionStatusId"] : <any>null;
            this.adoptionStatusName = _data["adoptionStatusName"] !== undefined ? _data["adoptionStatusName"] : <any>null;
        }
    }

    static fromJS(data: any): AdoptionStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdoptionStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adoptionStatusId"] = this.adoptionStatusId !== undefined ? this.adoptionStatusId : <any>null;
        data["adoptionStatusName"] = this.adoptionStatusName !== undefined ? this.adoptionStatusName : <any>null;
        return data;
    }
}

export interface IAdoptionStatusDto {
    adoptionStatusId?: number;
    adoptionStatusName?: string | null;
}

export class AdoptionStatusDtoApiResponse implements IAdoptionStatusDtoApiResponse {
    success?: boolean;
    data?: AdoptionStatusDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAdoptionStatusDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? AdoptionStatusDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AdoptionStatusDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdoptionStatusDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAdoptionStatusDtoApiResponse {
    success?: boolean;
    data?: AdoptionStatusDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class AdoptionStatusDtoIEnumerableApiResponse implements IAdoptionStatusDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AdoptionStatusDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAdoptionStatusDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AdoptionStatusDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AdoptionStatusDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdoptionStatusDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAdoptionStatusDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AdoptionStatusDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class AnimalDto implements IAnimalDto {
    animalId?: number;
    ownerId?: number;
    animalTypeId?: number;
    animalName?: string | null;
    species?: string | null;
    breed?: string | null;
    gender?: string | null;
    animalBirthDate?: Date;
    weight?: number;

    constructor(data?: IAnimalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.animalTypeId = _data["animalTypeId"] !== undefined ? _data["animalTypeId"] : <any>null;
            this.animalName = _data["animalName"] !== undefined ? _data["animalName"] : <any>null;
            this.species = _data["species"] !== undefined ? _data["species"] : <any>null;
            this.breed = _data["breed"] !== undefined ? _data["breed"] : <any>null;
            this.gender = _data["gender"] !== undefined ? _data["gender"] : <any>null;
            this.animalBirthDate = _data["animalBirthDate"] ? new Date(_data["animalBirthDate"].toString()) : <any>null;
            this.weight = _data["weight"] !== undefined ? _data["weight"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["animalTypeId"] = this.animalTypeId !== undefined ? this.animalTypeId : <any>null;
        data["animalName"] = this.animalName !== undefined ? this.animalName : <any>null;
        data["species"] = this.species !== undefined ? this.species : <any>null;
        data["breed"] = this.breed !== undefined ? this.breed : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["animalBirthDate"] = this.animalBirthDate ? this.animalBirthDate.toISOString() : <any>null;
        data["weight"] = this.weight !== undefined ? this.weight : <any>null;
        return data;
    }
}

export interface IAnimalDto {
    animalId?: number;
    ownerId?: number;
    animalTypeId?: number;
    animalName?: string | null;
    species?: string | null;
    breed?: string | null;
    gender?: string | null;
    animalBirthDate?: Date;
    weight?: number;
}

export class AnimalDtoApiResponse implements IAnimalDtoApiResponse {
    success?: boolean;
    data?: AnimalDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAnimalDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? AnimalDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAnimalDtoApiResponse {
    success?: boolean;
    data?: AnimalDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class AnimalDtoIEnumerableApiResponse implements IAnimalDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AnimalDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAnimalDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AnimalDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAnimalDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AnimalDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class AnimalDtoPaginationResponseDto implements IAnimalDtoPaginationResponseDto {
    data?: AnimalDto[] | null;
    totalRecords?: number;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IAnimalDtoPaginationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AnimalDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.totalRecords = _data["totalRecords"] !== undefined ? _data["totalRecords"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalDtoPaginationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalDtoPaginationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords !== undefined ? this.totalRecords : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IAnimalDtoPaginationResponseDto {
    data?: AnimalDto[] | null;
    totalRecords?: number;
    pageNumber?: number;
    pageSize?: number;
}

export class AnimalImageDto implements IAnimalImageDto {
    animalId?: number;
    imageUrl?: string | null;

    constructor(data?: IAnimalImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export interface IAnimalImageDto {
    animalId?: number;
    imageUrl?: string | null;
}

export class AnimalSearchDto implements IAnimalSearchDto {
    animalId?: number;
    animalName?: string | null;
    species?: string | null;
    breed?: string | null;
    ownerId?: number;
    fullName?: string | null;
    owner?: OwnerDto;

    constructor(data?: IAnimalSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.animalName = _data["animalName"] !== undefined ? _data["animalName"] : <any>null;
            this.species = _data["species"] !== undefined ? _data["species"] : <any>null;
            this.breed = _data["breed"] !== undefined ? _data["breed"] : <any>null;
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.owner = _data["owner"] ? OwnerDto.fromJS(_data["owner"]) : <any>null;
        }
    }

    static fromJS(data: any): AnimalSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["animalName"] = this.animalName !== undefined ? this.animalName : <any>null;
        data["species"] = this.species !== undefined ? this.species : <any>null;
        data["breed"] = this.breed !== undefined ? this.breed : <any>null;
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>null;
        return data;
    }
}

export interface IAnimalSearchDto {
    animalId?: number;
    animalName?: string | null;
    species?: string | null;
    breed?: string | null;
    ownerId?: number;
    fullName?: string | null;
    owner?: OwnerDto;
}

export class AnimalTypeDto implements IAnimalTypeDto {
    animalTypeId?: number;
    typeName?: string | null;

    constructor(data?: IAnimalTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.animalTypeId = _data["animalTypeId"] !== undefined ? _data["animalTypeId"] : <any>null;
            this.typeName = _data["typeName"] !== undefined ? _data["typeName"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["animalTypeId"] = this.animalTypeId !== undefined ? this.animalTypeId : <any>null;
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        return data;
    }
}

export interface IAnimalTypeDto {
    animalTypeId?: number;
    typeName?: string | null;
}

export class AnimalTypeDtoApiResponse implements IAnimalTypeDtoApiResponse {
    success?: boolean;
    data?: AnimalTypeDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAnimalTypeDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? AnimalTypeDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalTypeDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalTypeDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAnimalTypeDtoApiResponse {
    success?: boolean;
    data?: AnimalTypeDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class AnimalTypeDtoIEnumerableApiResponse implements IAnimalTypeDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AnimalTypeDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAnimalTypeDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AnimalTypeDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AnimalTypeDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AnimalTypeDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAnimalTypeDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AnimalTypeDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class AppoiAnimalNameDto implements IAppoiAnimalNameDto {
    appointmentId?: number;
    staffId?: number;
    appointmentDate?: Date;
    animalName?: string | null;
    fullName?: string | null;
    appointmentReason?: string | null;
    doctorSlotId?: number;
    slotStartTime?: string;

    constructor(data?: IAppoiAnimalNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appointmentId = _data["appointmentId"] !== undefined ? _data["appointmentId"] : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>null;
            this.animalName = _data["animalName"] !== undefined ? _data["animalName"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.appointmentReason = _data["appointmentReason"] !== undefined ? _data["appointmentReason"] : <any>null;
            this.doctorSlotId = _data["doctorSlotId"] !== undefined ? _data["doctorSlotId"] : <any>null;
            this.slotStartTime = _data["slotStartTime"] !== undefined ? _data["slotStartTime"] : <any>null;
        }
    }

    static fromJS(data: any): AppoiAnimalNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppoiAnimalNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentId"] = this.appointmentId !== undefined ? this.appointmentId : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>null;
        data["animalName"] = this.animalName !== undefined ? this.animalName : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["appointmentReason"] = this.appointmentReason !== undefined ? this.appointmentReason : <any>null;
        data["doctorSlotId"] = this.doctorSlotId !== undefined ? this.doctorSlotId : <any>null;
        data["slotStartTime"] = this.slotStartTime !== undefined ? this.slotStartTime : <any>null;
        return data;
    }
}

export interface IAppoiAnimalNameDto {
    appointmentId?: number;
    staffId?: number;
    appointmentDate?: Date;
    animalName?: string | null;
    fullName?: string | null;
    appointmentReason?: string | null;
    doctorSlotId?: number;
    slotStartTime?: string;
}

export class AppointmentDto implements IAppointmentDto {
    appointmentId?: number;
    animalId?: number;
    staffId?: number;
    appointmentDate?: Date;
    doctorSlotId?: number;
    appointmentReason?: string | null;
    createdAt?: Date;

    constructor(data?: IAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appointmentId = _data["appointmentId"] !== undefined ? _data["appointmentId"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>null;
            this.doctorSlotId = _data["doctorSlotId"] !== undefined ? _data["doctorSlotId"] : <any>null;
            this.appointmentReason = _data["appointmentReason"] !== undefined ? _data["appointmentReason"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): AppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentId"] = this.appointmentId !== undefined ? this.appointmentId : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>null;
        data["doctorSlotId"] = this.doctorSlotId !== undefined ? this.doctorSlotId : <any>null;
        data["appointmentReason"] = this.appointmentReason !== undefined ? this.appointmentReason : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        return data;
    }
}

export interface IAppointmentDto {
    appointmentId?: number;
    animalId?: number;
    staffId?: number;
    appointmentDate?: Date;
    doctorSlotId?: number;
    appointmentReason?: string | null;
    createdAt?: Date;
}

export class AppointmentDtoApiResponse implements IAppointmentDtoApiResponse {
    success?: boolean;
    data?: AppointmentDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAppointmentDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? AppointmentDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AppointmentDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAppointmentDtoApiResponse {
    success?: boolean;
    data?: AppointmentDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class AppointmentDtoIEnumerableApiResponse implements IAppointmentDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AppointmentDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAppointmentDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AppointmentDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AppointmentDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAppointmentDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AppointmentDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class AuthResponseDto implements IAuthResponseDto {
    token?: string | null;
    username?: string | null;
    userId?: number;
    fullName?: string | null;
    password?: string | null;
    email?: string | null;
    role?: string | null;

    constructor(data?: IAuthResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
        }
    }

    static fromJS(data: any): AuthResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data;
    }
}

export interface IAuthResponseDto {
    token?: string | null;
    username?: string | null;
    userId?: number;
    fullName?: string | null;
    password?: string | null;
    email?: string | null;
    role?: string | null;
}

export class AuthResponseDtoApiResponse implements IAuthResponseDtoApiResponse {
    success?: boolean;
    data?: AuthResponseDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IAuthResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? AuthResponseDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): AuthResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IAuthResponseDtoApiResponse {
    success?: boolean;
    data?: AuthResponseDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class BookAppointmentDto implements IBookAppointmentDto {
    appointmentId?: number;
    animalId?: number;
    staffId?: number;
    appointmentDate?: Date;
    doctorSlotId?: number;
    appointmentReason?: string | null;

    constructor(data?: IBookAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appointmentId = _data["appointmentId"] !== undefined ? _data["appointmentId"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>null;
            this.doctorSlotId = _data["doctorSlotId"] !== undefined ? _data["doctorSlotId"] : <any>null;
            this.appointmentReason = _data["appointmentReason"] !== undefined ? _data["appointmentReason"] : <any>null;
        }
    }

    static fromJS(data: any): BookAppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookAppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentId"] = this.appointmentId !== undefined ? this.appointmentId : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>null;
        data["doctorSlotId"] = this.doctorSlotId !== undefined ? this.doctorSlotId : <any>null;
        data["appointmentReason"] = this.appointmentReason !== undefined ? this.appointmentReason : <any>null;
        return data;
    }
}

export interface IBookAppointmentDto {
    appointmentId?: number;
    animalId?: number;
    staffId?: number;
    appointmentDate?: Date;
    doctorSlotId?: number;
    appointmentReason?: string | null;
}

export class BooleanApiResponse implements IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IBooleanApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] !== undefined ? _data["data"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): BooleanApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data !== undefined ? this.data : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    message?: string | null;
    errorMessage?: string | null;
}

export class DoctorScheduleDto implements IDoctorScheduleDto {
    doctorScheduleId?: number;
    dayOfWeek?: number;
    staffId?: number;
    startTimeSchedule?: string;
    endTimeSchedule?: string;

    constructor(data?: IDoctorScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.doctorScheduleId = _data["doctorScheduleId"] !== undefined ? _data["doctorScheduleId"] : <any>null;
            this.dayOfWeek = _data["dayOfWeek"] !== undefined ? _data["dayOfWeek"] : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.startTimeSchedule = _data["startTimeSchedule"] !== undefined ? _data["startTimeSchedule"] : <any>null;
            this.endTimeSchedule = _data["endTimeSchedule"] !== undefined ? _data["endTimeSchedule"] : <any>null;
        }
    }

    static fromJS(data: any): DoctorScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["doctorScheduleId"] = this.doctorScheduleId !== undefined ? this.doctorScheduleId : <any>null;
        data["dayOfWeek"] = this.dayOfWeek !== undefined ? this.dayOfWeek : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["startTimeSchedule"] = this.startTimeSchedule !== undefined ? this.startTimeSchedule : <any>null;
        data["endTimeSchedule"] = this.endTimeSchedule !== undefined ? this.endTimeSchedule : <any>null;
        return data;
    }
}

export interface IDoctorScheduleDto {
    doctorScheduleId?: number;
    dayOfWeek?: number;
    staffId?: number;
    startTimeSchedule?: string;
    endTimeSchedule?: string;
}

export class DoctorScheduleDtoApiResponse implements IDoctorScheduleDtoApiResponse {
    success?: boolean;
    data?: DoctorScheduleDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IDoctorScheduleDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? DoctorScheduleDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): DoctorScheduleDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorScheduleDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IDoctorScheduleDtoApiResponse {
    success?: boolean;
    data?: DoctorScheduleDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class DoctorScheduleDtoIEnumerableApiResponse implements IDoctorScheduleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: DoctorScheduleDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IDoctorScheduleDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DoctorScheduleDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): DoctorScheduleDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorScheduleDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IDoctorScheduleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: DoctorScheduleDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class DoctorSlotDto implements IDoctorSlotDto {
    doctorSlotId?: number;
    staffId?: number;
    slotDate?: Date | null;
    slotStartTime?: string | null;
    slotEndTime?: string | null;

    constructor(data?: IDoctorSlotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.doctorSlotId = _data["doctorSlotId"] !== undefined ? _data["doctorSlotId"] : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.slotDate = _data["slotDate"] ? new Date(_data["slotDate"].toString()) : <any>null;
            this.slotStartTime = _data["slotStartTime"] !== undefined ? _data["slotStartTime"] : <any>null;
            this.slotEndTime = _data["slotEndTime"] !== undefined ? _data["slotEndTime"] : <any>null;
        }
    }

    static fromJS(data: any): DoctorSlotDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorSlotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["doctorSlotId"] = this.doctorSlotId !== undefined ? this.doctorSlotId : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["slotDate"] = this.slotDate ? formatDate(this.slotDate) : <any>null;
        data["slotStartTime"] = this.slotStartTime !== undefined ? this.slotStartTime : <any>null;
        data["slotEndTime"] = this.slotEndTime !== undefined ? this.slotEndTime : <any>null;
        return data;
    }
}

export interface IDoctorSlotDto {
    doctorSlotId?: number;
    staffId?: number;
    slotDate?: Date | null;
    slotStartTime?: string | null;
    slotEndTime?: string | null;
}

export class DoctorSlotDtoApiResponse implements IDoctorSlotDtoApiResponse {
    success?: boolean;
    data?: DoctorSlotDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IDoctorSlotDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? DoctorSlotDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): DoctorSlotDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorSlotDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IDoctorSlotDtoApiResponse {
    success?: boolean;
    data?: DoctorSlotDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class DoctorSlotDtoIEnumerableApiResponse implements IDoctorSlotDtoIEnumerableApiResponse {
    success?: boolean;
    data?: DoctorSlotDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IDoctorSlotDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DoctorSlotDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): DoctorSlotDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorSlotDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IDoctorSlotDtoIEnumerableApiResponse {
    success?: boolean;
    data?: DoctorSlotDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class GetAllAdoptionQuestwithPetNameDto implements IGetAllAdoptionQuestwithPetNameDto {
    adoptionQuestionnaireId?: number;
    userId?: number | null;
    occupation?: string | null;
    salary?: number;
    isMarried?: boolean;
    hasChildren?: boolean;
    isHouseholdAware?: boolean;
    hasOwnedPetBefore?: boolean;
    petForAdoptionId?: number;
    hasAllergiesAsthma?: boolean;
    whoWillBeReponsible?: string | null;
    leftAlone?: string | null;
    ifSick?: string | null;
    reasonForAdoption?: string | null;
    questionStatus?: string | null;
    createdAt?: Date;
    petName?: string | null;

    constructor(data?: IGetAllAdoptionQuestwithPetNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adoptionQuestionnaireId = _data["adoptionQuestionnaireId"] !== undefined ? _data["adoptionQuestionnaireId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.occupation = _data["occupation"] !== undefined ? _data["occupation"] : <any>null;
            this.salary = _data["salary"] !== undefined ? _data["salary"] : <any>null;
            this.isMarried = _data["isMarried"] !== undefined ? _data["isMarried"] : <any>null;
            this.hasChildren = _data["hasChildren"] !== undefined ? _data["hasChildren"] : <any>null;
            this.isHouseholdAware = _data["isHouseholdAware"] !== undefined ? _data["isHouseholdAware"] : <any>null;
            this.hasOwnedPetBefore = _data["hasOwnedPetBefore"] !== undefined ? _data["hasOwnedPetBefore"] : <any>null;
            this.petForAdoptionId = _data["petForAdoptionId"] !== undefined ? _data["petForAdoptionId"] : <any>null;
            this.hasAllergiesAsthma = _data["hasAllergiesAsthma"] !== undefined ? _data["hasAllergiesAsthma"] : <any>null;
            this.whoWillBeReponsible = _data["whoWillBeReponsible"] !== undefined ? _data["whoWillBeReponsible"] : <any>null;
            this.leftAlone = _data["leftAlone"] !== undefined ? _data["leftAlone"] : <any>null;
            this.ifSick = _data["ifSick"] !== undefined ? _data["ifSick"] : <any>null;
            this.reasonForAdoption = _data["reasonForAdoption"] !== undefined ? _data["reasonForAdoption"] : <any>null;
            this.questionStatus = _data["questionStatus"] !== undefined ? _data["questionStatus"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.petName = _data["petName"] !== undefined ? _data["petName"] : <any>null;
        }
    }

    static fromJS(data: any): GetAllAdoptionQuestwithPetNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAdoptionQuestwithPetNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adoptionQuestionnaireId"] = this.adoptionQuestionnaireId !== undefined ? this.adoptionQuestionnaireId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["occupation"] = this.occupation !== undefined ? this.occupation : <any>null;
        data["salary"] = this.salary !== undefined ? this.salary : <any>null;
        data["isMarried"] = this.isMarried !== undefined ? this.isMarried : <any>null;
        data["hasChildren"] = this.hasChildren !== undefined ? this.hasChildren : <any>null;
        data["isHouseholdAware"] = this.isHouseholdAware !== undefined ? this.isHouseholdAware : <any>null;
        data["hasOwnedPetBefore"] = this.hasOwnedPetBefore !== undefined ? this.hasOwnedPetBefore : <any>null;
        data["petForAdoptionId"] = this.petForAdoptionId !== undefined ? this.petForAdoptionId : <any>null;
        data["hasAllergiesAsthma"] = this.hasAllergiesAsthma !== undefined ? this.hasAllergiesAsthma : <any>null;
        data["whoWillBeReponsible"] = this.whoWillBeReponsible !== undefined ? this.whoWillBeReponsible : <any>null;
        data["leftAlone"] = this.leftAlone !== undefined ? this.leftAlone : <any>null;
        data["ifSick"] = this.ifSick !== undefined ? this.ifSick : <any>null;
        data["reasonForAdoption"] = this.reasonForAdoption !== undefined ? this.reasonForAdoption : <any>null;
        data["questionStatus"] = this.questionStatus !== undefined ? this.questionStatus : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["petName"] = this.petName !== undefined ? this.petName : <any>null;
        return data;
    }
}

export interface IGetAllAdoptionQuestwithPetNameDto {
    adoptionQuestionnaireId?: number;
    userId?: number | null;
    occupation?: string | null;
    salary?: number;
    isMarried?: boolean;
    hasChildren?: boolean;
    isHouseholdAware?: boolean;
    hasOwnedPetBefore?: boolean;
    petForAdoptionId?: number;
    hasAllergiesAsthma?: boolean;
    whoWillBeReponsible?: string | null;
    leftAlone?: string | null;
    ifSick?: string | null;
    reasonForAdoption?: string | null;
    questionStatus?: string | null;
    createdAt?: Date;
    petName?: string | null;
}

export class GetAnimalOwnerTable implements IGetAnimalOwnerTable {
    animalId?: number;
    ownerId?: number;
    animalTypeId?: number;
    animalName?: string | null;
    species?: string | null;
    breed?: string | null;
    gender?: string | null;
    animalBirthDate?: Date;
    weight?: number;
    userId?: number;
    fullName?: string | null;
    address?: string | null;
    ownerEmail?: string | null;
    ownerBirthDate?: Date;
    phone?: string | null;

    constructor(data?: IGetAnimalOwnerTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.animalTypeId = _data["animalTypeId"] !== undefined ? _data["animalTypeId"] : <any>null;
            this.animalName = _data["animalName"] !== undefined ? _data["animalName"] : <any>null;
            this.species = _data["species"] !== undefined ? _data["species"] : <any>null;
            this.breed = _data["breed"] !== undefined ? _data["breed"] : <any>null;
            this.gender = _data["gender"] !== undefined ? _data["gender"] : <any>null;
            this.animalBirthDate = _data["animalBirthDate"] ? new Date(_data["animalBirthDate"].toString()) : <any>null;
            this.weight = _data["weight"] !== undefined ? _data["weight"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.ownerEmail = _data["ownerEmail"] !== undefined ? _data["ownerEmail"] : <any>null;
            this.ownerBirthDate = _data["ownerBirthDate"] ? new Date(_data["ownerBirthDate"].toString()) : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
        }
    }

    static fromJS(data: any): GetAnimalOwnerTable {
        data = typeof data === 'object' ? data : {};
        let result = new GetAnimalOwnerTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["animalTypeId"] = this.animalTypeId !== undefined ? this.animalTypeId : <any>null;
        data["animalName"] = this.animalName !== undefined ? this.animalName : <any>null;
        data["species"] = this.species !== undefined ? this.species : <any>null;
        data["breed"] = this.breed !== undefined ? this.breed : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["animalBirthDate"] = this.animalBirthDate ? this.animalBirthDate.toISOString() : <any>null;
        data["weight"] = this.weight !== undefined ? this.weight : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["ownerEmail"] = this.ownerEmail !== undefined ? this.ownerEmail : <any>null;
        data["ownerBirthDate"] = this.ownerBirthDate ? this.ownerBirthDate.toISOString() : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        return data;
    }
}

export interface IGetAnimalOwnerTable {
    animalId?: number;
    ownerId?: number;
    animalTypeId?: number;
    animalName?: string | null;
    species?: string | null;
    breed?: string | null;
    gender?: string | null;
    animalBirthDate?: Date;
    weight?: number;
    userId?: number;
    fullName?: string | null;
    address?: string | null;
    ownerEmail?: string | null;
    ownerBirthDate?: Date;
    phone?: string | null;
}

export class GetAnimalbyOwnerIDdto implements IGetAnimalbyOwnerIDdto {
    ownerId?: number;
    animals?: AnimalDto[] | null;

    constructor(data?: IGetAnimalbyOwnerIDdto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            if (Array.isArray(_data["animals"])) {
                this.animals = [] as any;
                for (let item of _data["animals"])
                    this.animals!.push(AnimalDto.fromJS(item));
            }
            else {
                this.animals = <any>null;
            }
        }
    }

    static fromJS(data: any): GetAnimalbyOwnerIDdto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAnimalbyOwnerIDdto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        if (Array.isArray(this.animals)) {
            data["animals"] = [];
            for (let item of this.animals)
                data["animals"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAnimalbyOwnerIDdto {
    ownerId?: number;
    animals?: AnimalDto[] | null;
}

export class GetAppointmentByDateDto implements IGetAppointmentByDateDto {
    appointmentId?: number;
    appointmentDate?: Date;
    slotStartTime?: string;
    appointmentReason?: string | null;
    staffId?: number;
    animalId?: number;
    animalName?: string | null;
    fullName?: string | null;
    staffName?: string | null;

    constructor(data?: IGetAppointmentByDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appointmentId = _data["appointmentId"] !== undefined ? _data["appointmentId"] : <any>null;
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>null;
            this.slotStartTime = _data["slotStartTime"] !== undefined ? _data["slotStartTime"] : <any>null;
            this.appointmentReason = _data["appointmentReason"] !== undefined ? _data["appointmentReason"] : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.animalName = _data["animalName"] !== undefined ? _data["animalName"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.staffName = _data["staffName"] !== undefined ? _data["staffName"] : <any>null;
        }
    }

    static fromJS(data: any): GetAppointmentByDateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppointmentByDateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentId"] = this.appointmentId !== undefined ? this.appointmentId : <any>null;
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>null;
        data["slotStartTime"] = this.slotStartTime !== undefined ? this.slotStartTime : <any>null;
        data["appointmentReason"] = this.appointmentReason !== undefined ? this.appointmentReason : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["animalName"] = this.animalName !== undefined ? this.animalName : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["staffName"] = this.staffName !== undefined ? this.staffName : <any>null;
        return data;
    }
}

export interface IGetAppointmentByDateDto {
    appointmentId?: number;
    appointmentDate?: Date;
    slotStartTime?: string;
    appointmentReason?: string | null;
    staffId?: number;
    animalId?: number;
    animalName?: string | null;
    fullName?: string | null;
    staffName?: string | null;
}

export class GetAvailableAppointmentsDto implements IGetAvailableAppointmentsDto {
    appointmentDate?: Date;

    constructor(data?: IGetAvailableAppointmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appointmentDate = _data["appointmentDate"] ? new Date(_data["appointmentDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): GetAvailableAppointmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAvailableAppointmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentDate"] = this.appointmentDate ? this.appointmentDate.toISOString() : <any>null;
        return data;
    }
}

export interface IGetAvailableAppointmentsDto {
    appointmentDate?: Date;
}

export class GetStaffNamesdto implements IGetStaffNamesdto {
    staffId?: number;
    fullName?: string | null;

    constructor(data?: IGetStaffNamesdto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
        }
    }

    static fromJS(data: any): GetStaffNamesdto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStaffNamesdto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        return data;
    }
}

export interface IGetStaffNamesdto {
    staffId?: number;
    fullName?: string | null;
}

export class InventoryDto implements IInventoryDto {
    itemId?: number;
    itemName?: string | null;
    quantity?: number;
    lastRestocked?: Date;
    unitPrice?: number;

    constructor(data?: IInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"] !== undefined ? _data["itemId"] : <any>null;
            this.itemName = _data["itemName"] !== undefined ? _data["itemName"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.lastRestocked = _data["lastRestocked"] ? new Date(_data["lastRestocked"].toString()) : <any>null;
            this.unitPrice = _data["unitPrice"] !== undefined ? _data["unitPrice"] : <any>null;
        }
    }

    static fromJS(data: any): InventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId !== undefined ? this.itemId : <any>null;
        data["itemName"] = this.itemName !== undefined ? this.itemName : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["lastRestocked"] = this.lastRestocked ? this.lastRestocked.toISOString() : <any>null;
        data["unitPrice"] = this.unitPrice !== undefined ? this.unitPrice : <any>null;
        return data;
    }
}

export interface IInventoryDto {
    itemId?: number;
    itemName?: string | null;
    quantity?: number;
    lastRestocked?: Date;
    unitPrice?: number;
}

export class InventoryDtoApiResponse implements IInventoryDtoApiResponse {
    success?: boolean;
    data?: InventoryDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IInventoryDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? InventoryDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): InventoryDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IInventoryDtoApiResponse {
    success?: boolean;
    data?: InventoryDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class InventoryDtoIEnumerableApiResponse implements IInventoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: InventoryDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IInventoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(InventoryDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): InventoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IInventoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: InventoryDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class InvoiceDto implements IInvoiceDto {
    invoiceId?: number;
    ownerName?: string | null;
    ownerNumber?: string | null;
    totalAmount?: number;
    paymentDate?: Date;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
            this.ownerName = _data["ownerName"] !== undefined ? _data["ownerName"] : <any>null;
            this.ownerNumber = _data["ownerNumber"] !== undefined ? _data["ownerNumber"] : <any>null;
            this.totalAmount = _data["totalAmount"] !== undefined ? _data["totalAmount"] : <any>null;
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId !== undefined ? this.invoiceId : <any>null;
        data["ownerName"] = this.ownerName !== undefined ? this.ownerName : <any>null;
        data["ownerNumber"] = this.ownerNumber !== undefined ? this.ownerNumber : <any>null;
        data["totalAmount"] = this.totalAmount !== undefined ? this.totalAmount : <any>null;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>null;
        return data;
    }
}

export interface IInvoiceDto {
    invoiceId?: number;
    ownerName?: string | null;
    ownerNumber?: string | null;
    totalAmount?: number;
    paymentDate?: Date;
}

export class InvoiceDtoApiResponse implements IInvoiceDtoApiResponse {
    success?: boolean;
    data?: InvoiceDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IInvoiceDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? InvoiceDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): InvoiceDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IInvoiceDtoApiResponse {
    success?: boolean;
    data?: InvoiceDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class InvoiceDtoIEnumerableApiResponse implements IInvoiceDtoIEnumerableApiResponse {
    success?: boolean;
    data?: InvoiceDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IInvoiceDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(InvoiceDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): InvoiceDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IInvoiceDtoIEnumerableApiResponse {
    success?: boolean;
    data?: InvoiceDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class InvoiceDtoPaginationResponseDto implements IInvoiceDtoPaginationResponseDto {
    data?: InvoiceDto[] | null;
    totalRecords?: number;
    pageNumber?: number;
    pageSize?: number;

    constructor(data?: IInvoiceDtoPaginationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(InvoiceDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.totalRecords = _data["totalRecords"] !== undefined ? _data["totalRecords"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
        }
    }

    static fromJS(data: any): InvoiceDtoPaginationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDtoPaginationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords !== undefined ? this.totalRecords : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        return data;
    }
}

export interface IInvoiceDtoPaginationResponseDto {
    data?: InvoiceDto[] | null;
    totalRecords?: number;
    pageNumber?: number;
    pageSize?: number;
}

export class LoginRequestDto implements ILoginRequestDto {
    username?: string | null;
    password?: string | null;

    constructor(data?: ILoginRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginRequestDto {
    username?: string | null;
    password?: string | null;
}

export class MedicalRecordDto implements IMedicalRecordDto {
    medicalRecordId?: number;
    animalId?: number;
    staffId?: number;
    diagnosis?: string | null;
    treatment?: string | null;
    surgeryDetails?: string | null;
    prescribedMedication?: string | null;
    createdAt?: Date;

    constructor(data?: IMedicalRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.medicalRecordId = _data["medicalRecordId"] !== undefined ? _data["medicalRecordId"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.diagnosis = _data["diagnosis"] !== undefined ? _data["diagnosis"] : <any>null;
            this.treatment = _data["treatment"] !== undefined ? _data["treatment"] : <any>null;
            this.surgeryDetails = _data["surgeryDetails"] !== undefined ? _data["surgeryDetails"] : <any>null;
            this.prescribedMedication = _data["prescribedMedication"] !== undefined ? _data["prescribedMedication"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): MedicalRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["medicalRecordId"] = this.medicalRecordId !== undefined ? this.medicalRecordId : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["diagnosis"] = this.diagnosis !== undefined ? this.diagnosis : <any>null;
        data["treatment"] = this.treatment !== undefined ? this.treatment : <any>null;
        data["surgeryDetails"] = this.surgeryDetails !== undefined ? this.surgeryDetails : <any>null;
        data["prescribedMedication"] = this.prescribedMedication !== undefined ? this.prescribedMedication : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        return data;
    }
}

export interface IMedicalRecordDto {
    medicalRecordId?: number;
    animalId?: number;
    staffId?: number;
    diagnosis?: string | null;
    treatment?: string | null;
    surgeryDetails?: string | null;
    prescribedMedication?: string | null;
    createdAt?: Date;
}

export class MedicalRecordDtoApiResponse implements IMedicalRecordDtoApiResponse {
    success?: boolean;
    data?: MedicalRecordDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IMedicalRecordDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? MedicalRecordDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): MedicalRecordDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalRecordDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IMedicalRecordDtoApiResponse {
    success?: boolean;
    data?: MedicalRecordDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class MedicalRecordDtoIEnumerableApiResponse implements IMedicalRecordDtoIEnumerableApiResponse {
    success?: boolean;
    data?: MedicalRecordDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IMedicalRecordDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MedicalRecordDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): MedicalRecordDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalRecordDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IMedicalRecordDtoIEnumerableApiResponse {
    success?: boolean;
    data?: MedicalRecordDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class OwnerDto implements IOwnerDto {
    ownerId?: number;
    userId?: number;
    fullName?: string | null;
    address?: string | null;
    ownerEmail?: string | null;
    phone?: string | null;
    ownerBirthDate?: Date;

    constructor(data?: IOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ownerId = _data["ownerId"] !== undefined ? _data["ownerId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.ownerEmail = _data["ownerEmail"] !== undefined ? _data["ownerEmail"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.ownerBirthDate = _data["ownerBirthDate"] ? new Date(_data["ownerBirthDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): OwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId !== undefined ? this.ownerId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["ownerEmail"] = this.ownerEmail !== undefined ? this.ownerEmail : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["ownerBirthDate"] = this.ownerBirthDate ? this.ownerBirthDate.toISOString() : <any>null;
        return data;
    }
}

export interface IOwnerDto {
    ownerId?: number;
    userId?: number;
    fullName?: string | null;
    address?: string | null;
    ownerEmail?: string | null;
    phone?: string | null;
    ownerBirthDate?: Date;
}

export class OwnerDtoApiResponse implements IOwnerDtoApiResponse {
    success?: boolean;
    data?: OwnerDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IOwnerDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? OwnerDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): OwnerDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IOwnerDtoApiResponse {
    success?: boolean;
    data?: OwnerDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class OwnerDtoIEnumerableApiResponse implements IOwnerDtoIEnumerableApiResponse {
    success?: boolean;
    data?: OwnerDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IOwnerDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OwnerDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): OwnerDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IOwnerDtoIEnumerableApiResponse {
    success?: boolean;
    data?: OwnerDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class PetForAdoptionDto implements IPetForAdoptionDto {
    petForAdoptionId?: number;
    petName?: string | null;
    breed?: string | null;
    species?: string | null;
    petBirthDate?: Date;
    petCondition?: string | null;
    gender?: string | null;
    weight?: number;
    adoptionStatusId?: number;
    imageUrl?: string | null;

    constructor(data?: IPetForAdoptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petForAdoptionId = _data["petForAdoptionId"] !== undefined ? _data["petForAdoptionId"] : <any>null;
            this.petName = _data["petName"] !== undefined ? _data["petName"] : <any>null;
            this.breed = _data["breed"] !== undefined ? _data["breed"] : <any>null;
            this.species = _data["species"] !== undefined ? _data["species"] : <any>null;
            this.petBirthDate = _data["petBirthDate"] ? new Date(_data["petBirthDate"].toString()) : <any>null;
            this.petCondition = _data["petCondition"] !== undefined ? _data["petCondition"] : <any>null;
            this.gender = _data["gender"] !== undefined ? _data["gender"] : <any>null;
            this.weight = _data["weight"] !== undefined ? _data["weight"] : <any>null;
            this.adoptionStatusId = _data["adoptionStatusId"] !== undefined ? _data["adoptionStatusId"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): PetForAdoptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PetForAdoptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petForAdoptionId"] = this.petForAdoptionId !== undefined ? this.petForAdoptionId : <any>null;
        data["petName"] = this.petName !== undefined ? this.petName : <any>null;
        data["breed"] = this.breed !== undefined ? this.breed : <any>null;
        data["species"] = this.species !== undefined ? this.species : <any>null;
        data["petBirthDate"] = this.petBirthDate ? formatDate(this.petBirthDate) : <any>null;
        data["petCondition"] = this.petCondition !== undefined ? this.petCondition : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["weight"] = this.weight !== undefined ? this.weight : <any>null;
        data["adoptionStatusId"] = this.adoptionStatusId !== undefined ? this.adoptionStatusId : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export interface IPetForAdoptionDto {
    petForAdoptionId?: number;
    petName?: string | null;
    breed?: string | null;
    species?: string | null;
    petBirthDate?: Date;
    petCondition?: string | null;
    gender?: string | null;
    weight?: number;
    adoptionStatusId?: number;
    imageUrl?: string | null;
}

export class PetForAdoptionDtoApiResponse implements IPetForAdoptionDtoApiResponse {
    success?: boolean;
    data?: PetForAdoptionDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IPetForAdoptionDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? PetForAdoptionDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): PetForAdoptionDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetForAdoptionDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IPetForAdoptionDtoApiResponse {
    success?: boolean;
    data?: PetForAdoptionDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class PetForAdoptionDtoIEnumerableApiResponse implements IPetForAdoptionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PetForAdoptionDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IPetForAdoptionDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PetForAdoptionDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): PetForAdoptionDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetForAdoptionDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IPetForAdoptionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PetForAdoptionDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export class RevenueByDayDto implements IRevenueByDayDto {
    day?: string | null;
    amount?: number;

    constructor(data?: IRevenueByDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"] !== undefined ? _data["day"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): RevenueByDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevenueByDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day !== undefined ? this.day : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export interface IRevenueByDayDto {
    day?: string | null;
    amount?: number;
}

export class SlotGenerationRequestDto implements ISlotGenerationRequestDto {
    doctorId?: number;
    dayOfWeek?: number[] | null;
    startDate?: Date;
    endDate?: Date;
    startTimeSchedule?: string;
    endTimeSchedule?: string;

    constructor(data?: ISlotGenerationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.doctorId = _data["doctorId"] !== undefined ? _data["doctorId"] : <any>null;
            if (Array.isArray(_data["dayOfWeek"])) {
                this.dayOfWeek = [] as any;
                for (let item of _data["dayOfWeek"])
                    this.dayOfWeek!.push(item);
            }
            else {
                this.dayOfWeek = <any>null;
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
            this.startTimeSchedule = _data["startTimeSchedule"] !== undefined ? _data["startTimeSchedule"] : <any>null;
            this.endTimeSchedule = _data["endTimeSchedule"] !== undefined ? _data["endTimeSchedule"] : <any>null;
        }
    }

    static fromJS(data: any): SlotGenerationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new SlotGenerationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["doctorId"] = this.doctorId !== undefined ? this.doctorId : <any>null;
        if (Array.isArray(this.dayOfWeek)) {
            data["dayOfWeek"] = [];
            for (let item of this.dayOfWeek)
                data["dayOfWeek"].push(item);
        }
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>null;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>null;
        data["startTimeSchedule"] = this.startTimeSchedule !== undefined ? this.startTimeSchedule : <any>null;
        data["endTimeSchedule"] = this.endTimeSchedule !== undefined ? this.endTimeSchedule : <any>null;
        return data;
    }
}

export interface ISlotGenerationRequestDto {
    doctorId?: number;
    dayOfWeek?: number[] | null;
    startDate?: Date;
    endDate?: Date;
    startTimeSchedule?: string;
    endTimeSchedule?: string;
}

export class StaffDto implements IStaffDto {
    staffId?: number;
    userId?: number | null;
    fullName?: string | null;
    phone?: string | null;
    address?: string | null;
    staffRoleId?: number;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.staffRoleId = _data["staffRoleId"] !== undefined ? _data["staffRoleId"] : <any>null;
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["staffRoleId"] = this.staffRoleId !== undefined ? this.staffRoleId : <any>null;
        return data;
    }
}

export interface IStaffDto {
    staffId?: number;
    userId?: number | null;
    fullName?: string | null;
    phone?: string | null;
    address?: string | null;
    staffRoleId?: number;
}

export class StaffDtoApiResponse implements IStaffDtoApiResponse {
    success?: boolean;
    data?: StaffDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IStaffDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? StaffDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): StaffDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IStaffDtoApiResponse {
    success?: boolean;
    data?: StaffDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class StaffDtoIEnumerableApiResponse implements IStaffDtoIEnumerableApiResponse {
    success?: boolean;
    data?: StaffDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IStaffDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(StaffDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): StaffDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IStaffDtoIEnumerableApiResponse {
    success?: boolean;
    data?: StaffDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class StaffRoleDto implements IStaffRoleDto {
    staffRoleId?: number;
    roleName?: string | null;

    constructor(data?: IStaffRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffRoleId = _data["staffRoleId"] !== undefined ? _data["staffRoleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
        }
    }

    static fromJS(data: any): StaffRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffRoleId"] = this.staffRoleId !== undefined ? this.staffRoleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        return data;
    }
}

export interface IStaffRoleDto {
    staffRoleId?: number;
    roleName?: string | null;
}

export class StaffRoleDtoApiResponse implements IStaffRoleDtoApiResponse {
    success?: boolean;
    data?: StaffRoleDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IStaffRoleDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? StaffRoleDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): StaffRoleDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StaffRoleDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IStaffRoleDtoApiResponse {
    success?: boolean;
    data?: StaffRoleDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class StaffRoleDtoIEnumerableApiResponse implements IStaffRoleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: StaffRoleDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IStaffRoleDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(StaffRoleDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): StaffRoleDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StaffRoleDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IStaffRoleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: StaffRoleDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class StaffWithRoleDTO implements IStaffWithRoleDTO {
    staffId?: number;
    fullName?: string | null;
    phone?: string | null;
    address?: string | null;
    staffRoleId?: number;
    roleName?: string | null;

    constructor(data?: IStaffWithRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.staffRoleId = _data["staffRoleId"] !== undefined ? _data["staffRoleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
        }
    }

    static fromJS(data: any): StaffWithRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StaffWithRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["staffRoleId"] = this.staffRoleId !== undefined ? this.staffRoleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        return data;
    }
}

export interface IStaffWithRoleDTO {
    staffId?: number;
    fullName?: string | null;
    phone?: string | null;
    address?: string | null;
    staffRoleId?: number;
    roleName?: string | null;
}

export class UserDto implements IUserDto {
    userId?: number;
    fullName?: string | null;
    username?: string | null;
    email?: string | null;
    password?: string | null;
    role?: string | null;
    createdAt?: Date | null;
    lastLogin?: Date | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>null;
        return data;
    }
}

export interface IUserDto {
    userId?: number;
    fullName?: string | null;
    username?: string | null;
    email?: string | null;
    password?: string | null;
    role?: string | null;
    createdAt?: Date | null;
    lastLogin?: Date | null;
}

export class UserDtoApiResponse implements IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IUserDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): UserDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class UserDtoIEnumerableApiResponse implements IUserDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IUserDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): UserDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IUserDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class VaccinationDto implements IVaccinationDto {
    vaccinationId?: number;
    animalId?: number;
    vaccineTypeId?: number | null;
    vaccinationDate?: Date;
    nextDueDate?: Date;
    staffId?: number;

    constructor(data?: IVaccinationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vaccinationId = _data["vaccinationId"] !== undefined ? _data["vaccinationId"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.vaccineTypeId = _data["vaccineTypeId"] !== undefined ? _data["vaccineTypeId"] : <any>null;
            this.vaccinationDate = _data["vaccinationDate"] ? new Date(_data["vaccinationDate"].toString()) : <any>null;
            this.nextDueDate = _data["nextDueDate"] ? new Date(_data["nextDueDate"].toString()) : <any>null;
            this.staffId = _data["staffId"] !== undefined ? _data["staffId"] : <any>null;
        }
    }

    static fromJS(data: any): VaccinationDto {
        data = typeof data === 'object' ? data : {};
        let result = new VaccinationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vaccinationId"] = this.vaccinationId !== undefined ? this.vaccinationId : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["vaccineTypeId"] = this.vaccineTypeId !== undefined ? this.vaccineTypeId : <any>null;
        data["vaccinationDate"] = this.vaccinationDate ? this.vaccinationDate.toISOString() : <any>null;
        data["nextDueDate"] = this.nextDueDate ? this.nextDueDate.toISOString() : <any>null;
        data["staffId"] = this.staffId !== undefined ? this.staffId : <any>null;
        return data;
    }
}

export interface IVaccinationDto {
    vaccinationId?: number;
    animalId?: number;
    vaccineTypeId?: number | null;
    vaccinationDate?: Date;
    nextDueDate?: Date;
    staffId?: number;
}

export class VaccinationDtoApiResponse implements IVaccinationDtoApiResponse {
    success?: boolean;
    data?: VaccinationDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IVaccinationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? VaccinationDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): VaccinationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VaccinationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IVaccinationDtoApiResponse {
    success?: boolean;
    data?: VaccinationDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class VaccinationDtoIEnumerableApiResponse implements IVaccinationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: VaccinationDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IVaccinationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(VaccinationDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): VaccinationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VaccinationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IVaccinationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: VaccinationDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class VaccinationWithVaccineTypeDto implements IVaccinationWithVaccineTypeDto {
    vaccinationId?: number;
    vaccineName?: string | null;
    vaccinationDate?: Date;
    dose?: string | null;
    nextDueDate?: Date;

    constructor(data?: IVaccinationWithVaccineTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vaccinationId = _data["vaccinationId"] !== undefined ? _data["vaccinationId"] : <any>null;
            this.vaccineName = _data["vaccineName"] !== undefined ? _data["vaccineName"] : <any>null;
            this.vaccinationDate = _data["vaccinationDate"] ? new Date(_data["vaccinationDate"].toString()) : <any>null;
            this.dose = _data["dose"] !== undefined ? _data["dose"] : <any>null;
            this.nextDueDate = _data["nextDueDate"] ? new Date(_data["nextDueDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): VaccinationWithVaccineTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new VaccinationWithVaccineTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vaccinationId"] = this.vaccinationId !== undefined ? this.vaccinationId : <any>null;
        data["vaccineName"] = this.vaccineName !== undefined ? this.vaccineName : <any>null;
        data["vaccinationDate"] = this.vaccinationDate ? this.vaccinationDate.toISOString() : <any>null;
        data["dose"] = this.dose !== undefined ? this.dose : <any>null;
        data["nextDueDate"] = this.nextDueDate ? this.nextDueDate.toISOString() : <any>null;
        return data;
    }
}

export interface IVaccinationWithVaccineTypeDto {
    vaccinationId?: number;
    vaccineName?: string | null;
    vaccinationDate?: Date;
    dose?: string | null;
    nextDueDate?: Date;
}

export class WeeklyRevenueDto implements IWeeklyRevenueDto {
    paymentDate?: Date;
    totalAmount?: number;

    constructor(data?: IWeeklyRevenueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>null;
            this.totalAmount = _data["totalAmount"] !== undefined ? _data["totalAmount"] : <any>null;
        }
    }

    static fromJS(data: any): WeeklyRevenueDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeeklyRevenueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>null;
        data["totalAmount"] = this.totalAmount !== undefined ? this.totalAmount : <any>null;
        return data;
    }
}

export interface IWeeklyRevenueDto {
    paymentDate?: Date;
    totalAmount?: number;
}

export class XrayImageDto implements IXrayImageDto {
    xrayId?: number;
    imageUrl?: string | null;
    animalId?: number;
    createdDate?: Date;

    constructor(data?: IXrayImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.xrayId = _data["xrayId"] !== undefined ? _data["xrayId"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): XrayImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new XrayImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xrayId"] = this.xrayId !== undefined ? this.xrayId : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        return data;
    }
}

export interface IXrayImageDto {
    xrayId?: number;
    imageUrl?: string | null;
    animalId?: number;
    createdDate?: Date;
}

export class XrayImageDtoApiResponse implements IXrayImageDtoApiResponse {
    success?: boolean;
    data?: XrayImageDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IXrayImageDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? XrayImageDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): XrayImageDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new XrayImageDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IXrayImageDtoApiResponse {
    success?: boolean;
    data?: XrayImageDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class XrayImageDtoIEnumerableApiResponse implements IXrayImageDtoIEnumerableApiResponse {
    success?: boolean;
    data?: XrayImageDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IXrayImageDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(XrayImageDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): XrayImageDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new XrayImageDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IXrayImageDtoIEnumerableApiResponse {
    success?: boolean;
    data?: XrayImageDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZLabResultDto implements IZLabResultDto {
    labResultId?: number;
    animalId?: number;
    testName?: string | null;
    testDate?: Date;
    result?: number;
    notes?: string | null;
    isNormal?: string | null;
    testNormalRangeId?: number;

    constructor(data?: IZLabResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.labResultId = _data["labResultId"] !== undefined ? _data["labResultId"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.testName = _data["testName"] !== undefined ? _data["testName"] : <any>null;
            this.testDate = _data["testDate"] ? new Date(_data["testDate"].toString()) : <any>null;
            this.result = _data["result"] !== undefined ? _data["result"] : <any>null;
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
            this.isNormal = _data["isNormal"] !== undefined ? _data["isNormal"] : <any>null;
            this.testNormalRangeId = _data["testNormalRangeId"] !== undefined ? _data["testNormalRangeId"] : <any>null;
        }
    }

    static fromJS(data: any): ZLabResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZLabResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["labResultId"] = this.labResultId !== undefined ? this.labResultId : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["testName"] = this.testName !== undefined ? this.testName : <any>null;
        data["testDate"] = this.testDate ? this.testDate.toISOString() : <any>null;
        data["result"] = this.result !== undefined ? this.result : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["isNormal"] = this.isNormal !== undefined ? this.isNormal : <any>null;
        data["testNormalRangeId"] = this.testNormalRangeId !== undefined ? this.testNormalRangeId : <any>null;
        return data;
    }
}

export interface IZLabResultDto {
    labResultId?: number;
    animalId?: number;
    testName?: string | null;
    testDate?: Date;
    result?: number;
    notes?: string | null;
    isNormal?: string | null;
    testNormalRangeId?: number;
}

export class ZLabResultDtoApiResponse implements IZLabResultDtoApiResponse {
    success?: boolean;
    data?: ZLabResultDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZLabResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? ZLabResultDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZLabResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZLabResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZLabResultDtoApiResponse {
    success?: boolean;
    data?: ZLabResultDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZLabResultDtoIEnumerableApiResponse implements IZLabResultDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZLabResultDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZLabResultDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ZLabResultDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZLabResultDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZLabResultDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZLabResultDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZLabResultDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZLabResultResponseDto implements IZLabResultResponseDto {
    labResultId?: number;
    animalId?: number;
    testName?: string | null;
    testDate?: Date;
    result?: number;
    isNormal?: string | null;
    notes?: string | null;
    testNormalRangeId?: number;
    unitMeasurements?: string | null;

    constructor(data?: IZLabResultResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.labResultId = _data["labResultId"] !== undefined ? _data["labResultId"] : <any>null;
            this.animalId = _data["animalId"] !== undefined ? _data["animalId"] : <any>null;
            this.testName = _data["testName"] !== undefined ? _data["testName"] : <any>null;
            this.testDate = _data["testDate"] ? new Date(_data["testDate"].toString()) : <any>null;
            this.result = _data["result"] !== undefined ? _data["result"] : <any>null;
            this.isNormal = _data["isNormal"] !== undefined ? _data["isNormal"] : <any>null;
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
            this.testNormalRangeId = _data["testNormalRangeId"] !== undefined ? _data["testNormalRangeId"] : <any>null;
            this.unitMeasurements = _data["unitMeasurements"] !== undefined ? _data["unitMeasurements"] : <any>null;
        }
    }

    static fromJS(data: any): ZLabResultResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZLabResultResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["labResultId"] = this.labResultId !== undefined ? this.labResultId : <any>null;
        data["animalId"] = this.animalId !== undefined ? this.animalId : <any>null;
        data["testName"] = this.testName !== undefined ? this.testName : <any>null;
        data["testDate"] = this.testDate ? this.testDate.toISOString() : <any>null;
        data["result"] = this.result !== undefined ? this.result : <any>null;
        data["isNormal"] = this.isNormal !== undefined ? this.isNormal : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["testNormalRangeId"] = this.testNormalRangeId !== undefined ? this.testNormalRangeId : <any>null;
        data["unitMeasurements"] = this.unitMeasurements !== undefined ? this.unitMeasurements : <any>null;
        return data;
    }
}

export interface IZLabResultResponseDto {
    labResultId?: number;
    animalId?: number;
    testName?: string | null;
    testDate?: Date;
    result?: number;
    isNormal?: string | null;
    notes?: string | null;
    testNormalRangeId?: number;
    unitMeasurements?: string | null;
}

export class ZTestNormalRangeDto implements IZTestNormalRangeDto {
    testNormalRangeId?: number;
    testName?: string | null;
    minRange?: number;
    maxRange?: number;
    unitOfMeasurement?: string | null;

    constructor(data?: IZTestNormalRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testNormalRangeId = _data["testNormalRangeId"] !== undefined ? _data["testNormalRangeId"] : <any>null;
            this.testName = _data["testName"] !== undefined ? _data["testName"] : <any>null;
            this.minRange = _data["minRange"] !== undefined ? _data["minRange"] : <any>null;
            this.maxRange = _data["maxRange"] !== undefined ? _data["maxRange"] : <any>null;
            this.unitOfMeasurement = _data["unitOfMeasurement"] !== undefined ? _data["unitOfMeasurement"] : <any>null;
        }
    }

    static fromJS(data: any): ZTestNormalRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZTestNormalRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testNormalRangeId"] = this.testNormalRangeId !== undefined ? this.testNormalRangeId : <any>null;
        data["testName"] = this.testName !== undefined ? this.testName : <any>null;
        data["minRange"] = this.minRange !== undefined ? this.minRange : <any>null;
        data["maxRange"] = this.maxRange !== undefined ? this.maxRange : <any>null;
        data["unitOfMeasurement"] = this.unitOfMeasurement !== undefined ? this.unitOfMeasurement : <any>null;
        return data;
    }
}

export interface IZTestNormalRangeDto {
    testNormalRangeId?: number;
    testName?: string | null;
    minRange?: number;
    maxRange?: number;
    unitOfMeasurement?: string | null;
}

export class ZTestNormalRangeDtoApiResponse implements IZTestNormalRangeDtoApiResponse {
    success?: boolean;
    data?: ZTestNormalRangeDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZTestNormalRangeDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? ZTestNormalRangeDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZTestNormalRangeDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZTestNormalRangeDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZTestNormalRangeDtoApiResponse {
    success?: boolean;
    data?: ZTestNormalRangeDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZTestNormalRangeDtoIEnumerableApiResponse implements IZTestNormalRangeDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZTestNormalRangeDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZTestNormalRangeDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ZTestNormalRangeDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZTestNormalRangeDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZTestNormalRangeDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZTestNormalRangeDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZTestNormalRangeDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZZVaccineTypeDto implements IZZVaccineTypeDto {
    vaccineTypeId?: number;
    vaccineName?: string | null;
    dose?: string | null;

    constructor(data?: IZZVaccineTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vaccineTypeId = _data["vaccineTypeId"] !== undefined ? _data["vaccineTypeId"] : <any>null;
            this.vaccineName = _data["vaccineName"] !== undefined ? _data["vaccineName"] : <any>null;
            this.dose = _data["dose"] !== undefined ? _data["dose"] : <any>null;
        }
    }

    static fromJS(data: any): ZZVaccineTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZZVaccineTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vaccineTypeId"] = this.vaccineTypeId !== undefined ? this.vaccineTypeId : <any>null;
        data["vaccineName"] = this.vaccineName !== undefined ? this.vaccineName : <any>null;
        data["dose"] = this.dose !== undefined ? this.dose : <any>null;
        return data;
    }
}

export interface IZZVaccineTypeDto {
    vaccineTypeId?: number;
    vaccineName?: string | null;
    dose?: string | null;
}

export class ZZVaccineTypeDtoApiResponse implements IZZVaccineTypeDtoApiResponse {
    success?: boolean;
    data?: ZZVaccineTypeDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZZVaccineTypeDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? ZZVaccineTypeDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZZVaccineTypeDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZZVaccineTypeDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZZVaccineTypeDtoApiResponse {
    success?: boolean;
    data?: ZZVaccineTypeDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZZVaccineTypeDtoIEnumerableApiResponse implements IZZVaccineTypeDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZZVaccineTypeDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZZVaccineTypeDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ZZVaccineTypeDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZZVaccineTypeDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZZVaccineTypeDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZZVaccineTypeDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZZVaccineTypeDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZZratingDto implements IZZratingDto {
    ratingId?: number;
    fullName?: string | null;
    userId?: number | null;
    reviewTitle?: string | null;
    ratingValue?: number;
    review?: string | null;
    createdAt?: Date | null;

    constructor(data?: IZZratingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ratingId = _data["ratingId"] !== undefined ? _data["ratingId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.reviewTitle = _data["reviewTitle"] !== undefined ? _data["reviewTitle"] : <any>null;
            this.ratingValue = _data["ratingValue"] !== undefined ? _data["ratingValue"] : <any>null;
            this.review = _data["review"] !== undefined ? _data["review"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ZZratingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZZratingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ratingId"] = this.ratingId !== undefined ? this.ratingId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["reviewTitle"] = this.reviewTitle !== undefined ? this.reviewTitle : <any>null;
        data["ratingValue"] = this.ratingValue !== undefined ? this.ratingValue : <any>null;
        data["review"] = this.review !== undefined ? this.review : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        return data;
    }
}

export interface IZZratingDto {
    ratingId?: number;
    fullName?: string | null;
    userId?: number | null;
    reviewTitle?: string | null;
    ratingValue?: number;
    review?: string | null;
    createdAt?: Date | null;
}

export class ZZratingDtoApiResponse implements IZZratingDtoApiResponse {
    success?: boolean;
    data?: ZZratingDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZZratingDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? ZZratingDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZZratingDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZZratingDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZZratingDtoApiResponse {
    success?: boolean;
    data?: ZZratingDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class ZZratingDtoIEnumerableApiResponse implements IZZratingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZZratingDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IZZratingDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ZZratingDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ZZratingDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZZratingDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IZZratingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ZZratingDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}