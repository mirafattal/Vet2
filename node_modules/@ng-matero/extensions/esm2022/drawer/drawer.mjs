import { coerceCssPixelValue } from '@angular/cdk/coercion';
import { Dialog, DialogConfig } from '@angular/cdk/dialog';
import { Inject, Injectable, InjectionToken, Optional, SkipSelf, } from '@angular/core';
import { defer, Subject } from 'rxjs';
import { startWith } from 'rxjs/operators';
import { MtxDrawerConfig } from './drawer-config';
import { MtxDrawerContainer } from './drawer-container';
import { MtxDrawerRef } from './drawer-ref';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "./drawer-config";
/** Injection token that can be used to access the data that was passed in to a drawer. */
export const MTX_DRAWER_DATA = new InjectionToken('MtxDrawerData');
/** Injection token that can be used to specify default drawer options. */
export const MTX_DRAWER_DEFAULT_OPTIONS = new InjectionToken('mtx-drawer-default-options');
// Counter for unique drawer ids.
let uniqueId = 0;
/**
 * Service to trigger Material Design bottom sheets.
 */
export class MtxDrawer {
    /** Keeps track of the currently-open dialogs. */
    get openDrawers() {
        return this._parentDrawer ? this._parentDrawer.openDrawers : this._openDrawersAtThisLevel;
    }
    /** Stream that emits when a drawer has been opened. */
    get afterOpened() {
        return this._parentDrawer ? this._parentDrawer.afterOpened : this._afterOpenedAtThisLevel;
    }
    _getAfterAllDismissed() {
        const parent = this._parentDrawer;
        return parent ? parent._getAfterAllDismissed() : this._afterAllDismissedAtThisLevel;
    }
    constructor(_overlay, injector, _parentDrawer, _defaultOptions) {
        this._overlay = _overlay;
        this._parentDrawer = _parentDrawer;
        this._defaultOptions = _defaultOptions;
        this._openDrawersAtThisLevel = [];
        this._afterAllDismissedAtThisLevel = new Subject();
        this._afterOpenedAtThisLevel = new Subject();
        /**
         * Stream that emits when all open drawer have finished closing.
         * Will emit on subscribe if there are no open drawers to begin with.
         */
        this.afterAllDismissed = defer(() => this.openDrawers.length
            ? this._getAfterAllDismissed()
            : this._getAfterAllDismissed().pipe(startWith(undefined)));
        this._dialog = injector.get(Dialog);
    }
    open(componentOrTemplateRef, config) {
        let drawerRef;
        const _config = { ...(this._defaultOptions || new MtxDrawerConfig()), ...config };
        _config.id = _config.id || `mtx-drawer-${uniqueId++}`;
        _config.width =
            _config.position === 'left' || _config.position === 'right'
                ? coerceCssPixelValue(_config.width)
                : '100vw';
        _config.height =
            _config.position === 'top' || _config.position === 'bottom'
                ? coerceCssPixelValue(_config.height)
                : '100vh';
        this._dialog.open(componentOrTemplateRef, {
            ..._config,
            // Disable closing since we need to sync it up to the animation ourselves.
            disableClose: true,
            // Disable closing on detachments so that we can sync up the animation.
            closeOnOverlayDetachments: false,
            container: {
                type: MtxDrawerContainer,
                providers: () => [
                    // Provide our config as the CDK config as well since it has the same interface as the
                    // CDK one, but it contains the actual values passed in by the user for things like
                    // `disableClose` which we disable for the CDK dialog since we handle it ourselves.
                    { provide: MtxDrawerConfig, useValue: _config },
                    { provide: DialogConfig, useValue: _config },
                ],
            },
            scrollStrategy: _config.scrollStrategy || this._overlay.scrollStrategies.block(),
            positionStrategy: this._overlay.position().global()[_config.position]('0'),
            templateContext: () => ({ drawerRef }),
            providers: (cdkRef, _cdkConfig, container) => {
                drawerRef = new MtxDrawerRef(cdkRef, _config, container);
                return [
                    { provide: MtxDrawerRef, useValue: drawerRef },
                    { provide: MTX_DRAWER_DATA, useValue: _config.data },
                ];
            },
        });
        this.openDrawers.push(drawerRef);
        this.afterOpened.next(drawerRef);
        drawerRef.afterDismissed().subscribe(() => {
            const index = this.openDrawers.indexOf(drawerRef);
            if (index > -1) {
                this.openDrawers.splice(index, 1);
                if (!this.openDrawers.length) {
                    this._getAfterAllDismissed().next();
                }
            }
        });
        return drawerRef;
    }
    /**
     * Dismisses all of the currently-open drawers.
     */
    dismissAll() {
        this._dismissDrawers(this.openDrawers);
    }
    /**
     * Finds an open drawer by its id.
     * @param id ID to use when looking up the drawer.
     */
    getDrawerById(id) {
        return this.openDrawers.find(drawer => drawer.id === id);
    }
    ngOnDestroy() {
        // Only dismiss the drawers at this level on destroy
        // since the parent service may still be active.
        this._dismissDrawers(this._openDrawersAtThisLevel);
        this._afterAllDismissedAtThisLevel.complete();
        this._afterOpenedAtThisLevel.complete();
    }
    _dismissDrawers(drawers) {
        let i = drawers.length;
        while (i--) {
            drawers[i].dismiss();
        }
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.0", ngImport: i0, type: MtxDrawer, deps: [{ token: i1.Overlay }, { token: i0.Injector }, { token: MtxDrawer, optional: true, skipSelf: true }, { token: MTX_DRAWER_DEFAULT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.0", ngImport: i0, type: MtxDrawer, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.0", ngImport: i0, type: MtxDrawer, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i1.Overlay }, { type: i0.Injector }, { type: MtxDrawer, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i2.MtxDrawerConfig, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MTX_DRAWER_DEFAULT_OPTIONS]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhd2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvZXh0ZW5zaW9ucy9kcmF3ZXIvZHJhd2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVELE9BQU8sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFHM0QsT0FBTyxFQUNMLE1BQU0sRUFDTixVQUFVLEVBQ1YsY0FBYyxFQUdkLFFBQVEsRUFDUixRQUFRLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLEtBQUssRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNsRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7O0FBRTVDLDBGQUEwRjtBQUMxRixNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsSUFBSSxjQUFjLENBQU0sZUFBZSxDQUFDLENBQUM7QUFFeEUsMEVBQTBFO0FBQzFFLE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLElBQUksY0FBYyxDQUMxRCw0QkFBNEIsQ0FDN0IsQ0FBQztBQUVGLGlDQUFpQztBQUNqQyxJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFFakI7O0dBRUc7QUFFSCxNQUFNLE9BQU8sU0FBUztJQU1wQixpREFBaUQ7SUFDakQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDO0lB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LENBQUMsQ0FBQztRQUVILE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNILFVBQVU7UUFDUixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsYUFBYSxDQUFDLEVBQVU7UUFDdEIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVELFdBQVc7UUFDVCxvREFBb0Q7UUFDcEQsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLDZCQUE2QixDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzlDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0lBRU8sZUFBZSxDQUFDLE9BQTRCO1FBQ2xELElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFFdkIsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ1gsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3ZCLENBQUM7SUFDSCxDQUFDO2lJQTlKVSxTQUFTLHVIQW9DViwwQkFBMEI7cUlBcEN6QixTQUFTLGNBREksTUFBTTs7MkZBQ25CLFNBQVM7a0JBRHJCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzswQkFtQzdCLFFBQVE7OzBCQUFJLFFBQVE7OzBCQUNwQixRQUFROzswQkFDUixNQUFNOzJCQUFDLDBCQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvZXJjZUNzc1BpeGVsVmFsdWUgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgRGlhbG9nLCBEaWFsb2dDb25maWcgfSBmcm9tICdAYW5ndWxhci9jZGsvZGlhbG9nJztcbmltcG9ydCB7IE92ZXJsYXkgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQge1xuICBJbmplY3QsXG4gIEluamVjdGFibGUsXG4gIEluamVjdGlvblRva2VuLFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgU2tpcFNlbGYsXG4gIFRlbXBsYXRlUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRlZmVyLCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNdHhEcmF3ZXJDb25maWcgfSBmcm9tICcuL2RyYXdlci1jb25maWcnO1xuaW1wb3J0IHsgTXR4RHJhd2VyQ29udGFpbmVyIH0gZnJvbSAnLi9kcmF3ZXItY29udGFpbmVyJztcbmltcG9ydCB7IE10eERyYXdlclJlZiB9IGZyb20gJy4vZHJhd2VyLXJlZic7XG5cbi8qKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlIGRhdGEgdGhhdCB3YXMgcGFzc2VkIGluIHRvIGEgZHJhd2VyLiAqL1xuZXhwb3J0IGNvbnN0IE1UWF9EUkFXRVJfREFUQSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdNdHhEcmF3ZXJEYXRhJyk7XG5cbi8qKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGRlZmF1bHQgZHJhd2VyIG9wdGlvbnMuICovXG5leHBvcnQgY29uc3QgTVRYX0RSQVdFUl9ERUZBVUxUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TXR4RHJhd2VyQ29uZmlnPihcbiAgJ210eC1kcmF3ZXItZGVmYXVsdC1vcHRpb25zJ1xuKTtcblxuLy8gQ291bnRlciBmb3IgdW5pcXVlIGRyYXdlciBpZHMuXG5sZXQgdW5pcXVlSWQgPSAwO1xuXG4vKipcbiAqIFNlcnZpY2UgdG8gdHJpZ2dlciBNYXRlcmlhbCBEZXNpZ24gYm90dG9tIHNoZWV0cy5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBNdHhEcmF3ZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHJlYWRvbmx5IF9vcGVuRHJhd2Vyc0F0VGhpc0xldmVsOiBNdHhEcmF3ZXJSZWY8YW55PltdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgX2FmdGVyQWxsRGlzbWlzc2VkQXRUaGlzTGV2ZWwgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IF9hZnRlck9wZW5lZEF0VGhpc0xldmVsID0gbmV3IFN1YmplY3Q8TXR4RHJhd2VyUmVmPGFueT4+KCk7XG4gIHByaXZhdGUgX2RpYWxvZzogRGlhbG9nO1xuXG4gIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudGx5LW9wZW4gZGlhbG9ncy4gKi9cbiAgZ2V0IG9wZW5EcmF3ZXJzKCk6IE10eERyYXdlclJlZjxhbnk+W10ge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnREcmF3ZXIgPyB0aGlzLl9wYXJlbnREcmF3ZXIub3BlbkRyYXdlcnMgOiB0aGlzLl9vcGVuRHJhd2Vyc0F0VGhpc0xldmVsO1xuICB9XG5cbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gYSBkcmF3ZXIgaGFzIGJlZW4gb3BlbmVkLiAqL1xuICBnZXQgYWZ0ZXJPcGVuZWQoKTogU3ViamVjdDxNdHhEcmF3ZXJSZWY8YW55Pj4ge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnREcmF3ZXIgPyB0aGlzLl9wYXJlbnREcmF3ZXIuYWZ0ZXJPcGVuZWQgOiB0aGlzLl9hZnRlck9wZW5lZEF0VGhpc0xldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0QWZ0ZXJBbGxEaXNtaXNzZWQoKTogU3ViamVjdDx2b2lkPiB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50RHJhd2VyO1xuICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuX2dldEFmdGVyQWxsRGlzbWlzc2VkKCkgOiB0aGlzLl9hZnRlckFsbERpc21pc3NlZEF0VGhpc0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gYWxsIG9wZW4gZHJhd2VyIGhhdmUgZmluaXNoZWQgY2xvc2luZy5cbiAgICogV2lsbCBlbWl0IG9uIHN1YnNjcmliZSBpZiB0aGVyZSBhcmUgbm8gb3BlbiBkcmF3ZXJzIHRvIGJlZ2luIHdpdGguXG4gICAqL1xuICByZWFkb25seSBhZnRlckFsbERpc21pc3NlZDogT2JzZXJ2YWJsZTx2b2lkPiA9IGRlZmVyKCgpID0+XG4gICAgdGhpcy5vcGVuRHJhd2Vycy5sZW5ndGhcbiAgICAgID8gdGhpcy5fZ2V0QWZ0ZXJBbGxEaXNtaXNzZWQoKVxuICAgICAgOiB0aGlzLl9nZXRBZnRlckFsbERpc21pc3NlZCgpLnBpcGUoc3RhcnRXaXRoKHVuZGVmaW5lZCkpXG4gICkgYXMgT2JzZXJ2YWJsZTxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIHByaXZhdGUgX3BhcmVudERyYXdlcjogTXR4RHJhd2VyLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChNVFhfRFJBV0VSX0RFRkFVTFRfT1BUSU9OUylcbiAgICBwcml2YXRlIF9kZWZhdWx0T3B0aW9ucz86IE10eERyYXdlckNvbmZpZ1xuICApIHtcbiAgICB0aGlzLl9kaWFsb2cgPSBpbmplY3Rvci5nZXQoRGlhbG9nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhIGRyYXdlciBjb250YWluaW5nIHRoZSBnaXZlbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBjb21wb25lbnQgVHlwZSBvZiB0aGUgY29tcG9uZW50IHRvIGxvYWQgaW50byB0aGUgZHJhd2VyLlxuICAgKiBAcGFyYW0gY29uZmlnIEV4dHJhIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHJldHVybnMgUmVmZXJlbmNlIHRvIHRoZSBuZXdseS1vcGVuZWQgZHJhd2VyLlxuICAgKi9cbiAgb3BlbjxULCBEID0gYW55LCBSID0gYW55PihcbiAgICBjb21wb25lbnQ6IENvbXBvbmVudFR5cGU8VD4sXG4gICAgY29uZmlnPzogTXR4RHJhd2VyQ29uZmlnPEQ+XG4gICk6IE10eERyYXdlclJlZjxULCBSPjtcblxuICAvKipcbiAgICogT3BlbnMgYSBkcmF3ZXIgY29udGFpbmluZyB0aGUgZ2l2ZW4gdGVtcGxhdGUuXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZSBUZW1wbGF0ZVJlZiB0byBpbnN0YW50aWF0ZSBhcyB0aGUgZHJhd2VyIGNvbnRlbnQuXG4gICAqIEBwYXJhbSBjb25maWcgRXh0cmEgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBSZWZlcmVuY2UgdG8gdGhlIG5ld2x5LW9wZW5lZCBkcmF3ZXIuXG4gICAqL1xuICBvcGVuPFQsIEQgPSBhbnksIFIgPSBhbnk+KFxuICAgIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxUPixcbiAgICBjb25maWc/OiBNdHhEcmF3ZXJDb25maWc8RD5cbiAgKTogTXR4RHJhd2VyUmVmPFQsIFI+O1xuXG4gIG9wZW48VCwgRCA9IGFueSwgUiA9IGFueT4oXG4gICAgY29tcG9uZW50T3JUZW1wbGF0ZVJlZjogQ29tcG9uZW50VHlwZTxUPiB8IFRlbXBsYXRlUmVmPFQ+LFxuICAgIGNvbmZpZz86IE10eERyYXdlckNvbmZpZzxEPlxuICApOiBNdHhEcmF3ZXJSZWY8VCwgUj4ge1xuICAgIGxldCBkcmF3ZXJSZWYhOiBNdHhEcmF3ZXJSZWY8VCwgUj47XG5cbiAgICBjb25zdCBfY29uZmlnID0geyAuLi4odGhpcy5fZGVmYXVsdE9wdGlvbnMgfHwgbmV3IE10eERyYXdlckNvbmZpZygpKSwgLi4uY29uZmlnIH07XG4gICAgX2NvbmZpZy5pZCA9IF9jb25maWcuaWQgfHwgYG10eC1kcmF3ZXItJHt1bmlxdWVJZCsrfWA7XG5cbiAgICBfY29uZmlnLndpZHRoID1cbiAgICAgIF9jb25maWcucG9zaXRpb24gPT09ICdsZWZ0JyB8fCBfY29uZmlnLnBvc2l0aW9uID09PSAncmlnaHQnXG4gICAgICAgID8gY29lcmNlQ3NzUGl4ZWxWYWx1ZShfY29uZmlnLndpZHRoKVxuICAgICAgICA6ICcxMDB2dyc7XG5cbiAgICBfY29uZmlnLmhlaWdodCA9XG4gICAgICBfY29uZmlnLnBvc2l0aW9uID09PSAndG9wJyB8fCBfY29uZmlnLnBvc2l0aW9uID09PSAnYm90dG9tJ1xuICAgICAgICA/IGNvZXJjZUNzc1BpeGVsVmFsdWUoX2NvbmZpZy5oZWlnaHQpXG4gICAgICAgIDogJzEwMHZoJztcblxuICAgIHRoaXMuX2RpYWxvZy5vcGVuPFIsIEQsIFQ+KGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIHtcbiAgICAgIC4uLl9jb25maWcsXG4gICAgICAvLyBEaXNhYmxlIGNsb3Npbmcgc2luY2Ugd2UgbmVlZCB0byBzeW5jIGl0IHVwIHRvIHRoZSBhbmltYXRpb24gb3Vyc2VsdmVzLlxuICAgICAgZGlzYWJsZUNsb3NlOiB0cnVlLFxuICAgICAgLy8gRGlzYWJsZSBjbG9zaW5nIG9uIGRldGFjaG1lbnRzIHNvIHRoYXQgd2UgY2FuIHN5bmMgdXAgdGhlIGFuaW1hdGlvbi5cbiAgICAgIGNsb3NlT25PdmVybGF5RGV0YWNobWVudHM6IGZhbHNlLFxuICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgIHR5cGU6IE10eERyYXdlckNvbnRhaW5lcixcbiAgICAgICAgcHJvdmlkZXJzOiAoKSA9PiBbXG4gICAgICAgICAgLy8gUHJvdmlkZSBvdXIgY29uZmlnIGFzIHRoZSBDREsgY29uZmlnIGFzIHdlbGwgc2luY2UgaXQgaGFzIHRoZSBzYW1lIGludGVyZmFjZSBhcyB0aGVcbiAgICAgICAgICAvLyBDREsgb25lLCBidXQgaXQgY29udGFpbnMgdGhlIGFjdHVhbCB2YWx1ZXMgcGFzc2VkIGluIGJ5IHRoZSB1c2VyIGZvciB0aGluZ3MgbGlrZVxuICAgICAgICAgIC8vIGBkaXNhYmxlQ2xvc2VgIHdoaWNoIHdlIGRpc2FibGUgZm9yIHRoZSBDREsgZGlhbG9nIHNpbmNlIHdlIGhhbmRsZSBpdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgeyBwcm92aWRlOiBNdHhEcmF3ZXJDb25maWcsIHVzZVZhbHVlOiBfY29uZmlnIH0sXG4gICAgICAgICAgeyBwcm92aWRlOiBEaWFsb2dDb25maWcsIHVzZVZhbHVlOiBfY29uZmlnIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgc2Nyb2xsU3RyYXRlZ3k6IF9jb25maWcuc2Nyb2xsU3RyYXRlZ3kgfHwgdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmJsb2NrKCksXG4gICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuZ2xvYmFsKClbX2NvbmZpZy5wb3NpdGlvbiFdKCcwJyksXG4gICAgICB0ZW1wbGF0ZUNvbnRleHQ6ICgpID0+ICh7IGRyYXdlclJlZiB9KSxcbiAgICAgIHByb3ZpZGVyczogKGNka1JlZiwgX2Nka0NvbmZpZywgY29udGFpbmVyKSA9PiB7XG4gICAgICAgIGRyYXdlclJlZiA9IG5ldyBNdHhEcmF3ZXJSZWYoY2RrUmVmLCBfY29uZmlnLCBjb250YWluZXIgYXMgTXR4RHJhd2VyQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IHByb3ZpZGU6IE10eERyYXdlclJlZiwgdXNlVmFsdWU6IGRyYXdlclJlZiB9LFxuICAgICAgICAgIHsgcHJvdmlkZTogTVRYX0RSQVdFUl9EQVRBLCB1c2VWYWx1ZTogX2NvbmZpZy5kYXRhIH0sXG4gICAgICAgIF07XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5vcGVuRHJhd2Vycy5wdXNoKGRyYXdlclJlZik7XG4gICAgdGhpcy5hZnRlck9wZW5lZC5uZXh0KGRyYXdlclJlZik7XG5cbiAgICBkcmF3ZXJSZWYuYWZ0ZXJEaXNtaXNzZWQoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm9wZW5EcmF3ZXJzLmluZGV4T2YoZHJhd2VyUmVmKTtcblxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5vcGVuRHJhd2Vycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgIGlmICghdGhpcy5vcGVuRHJhd2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9nZXRBZnRlckFsbERpc21pc3NlZCgpLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRyYXdlclJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNtaXNzZXMgYWxsIG9mIHRoZSBjdXJyZW50bHktb3BlbiBkcmF3ZXJzLlxuICAgKi9cbiAgZGlzbWlzc0FsbCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kaXNtaXNzRHJhd2Vycyh0aGlzLm9wZW5EcmF3ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBvcGVuIGRyYXdlciBieSBpdHMgaWQuXG4gICAqIEBwYXJhbSBpZCBJRCB0byB1c2Ugd2hlbiBsb29raW5nIHVwIHRoZSBkcmF3ZXIuXG4gICAqL1xuICBnZXREcmF3ZXJCeUlkKGlkOiBzdHJpbmcpOiBNdHhEcmF3ZXJSZWY8YW55PiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMub3BlbkRyYXdlcnMuZmluZChkcmF3ZXIgPT4gZHJhd2VyLmlkID09PSBpZCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICAvLyBPbmx5IGRpc21pc3MgdGhlIGRyYXdlcnMgYXQgdGhpcyBsZXZlbCBvbiBkZXN0cm95XG4gICAgLy8gc2luY2UgdGhlIHBhcmVudCBzZXJ2aWNlIG1heSBzdGlsbCBiZSBhY3RpdmUuXG4gICAgdGhpcy5fZGlzbWlzc0RyYXdlcnModGhpcy5fb3BlbkRyYXdlcnNBdFRoaXNMZXZlbCk7XG4gICAgdGhpcy5fYWZ0ZXJBbGxEaXNtaXNzZWRBdFRoaXNMZXZlbC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX2FmdGVyT3BlbmVkQXRUaGlzTGV2ZWwuY29tcGxldGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2Rpc21pc3NEcmF3ZXJzKGRyYXdlcnM6IE10eERyYXdlclJlZjxhbnk+W10pIHtcbiAgICBsZXQgaSA9IGRyYXdlcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgZHJhd2Vyc1tpXS5kaXNtaXNzKCk7XG4gICAgfVxuICB9XG59XG4iXX0=