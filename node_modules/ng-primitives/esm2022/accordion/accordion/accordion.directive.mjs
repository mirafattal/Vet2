import { Directive, booleanAttribute, input, model } from '@angular/core';
import { injectAccordionConfig } from '../config/accordion.config';
import { NgpAccordionToken } from './accordion.token';
import * as i0 from "@angular/core";
export class NgpAccordion {
    constructor() {
        /**
         * Access the global accordion configuration.
         */
        this.config = injectAccordionConfig();
        /**
         * The type of the accordion.
         */
        this.type = input(this.config.type, {
            alias: 'ngpAccordionType',
        });
        /**
         * Whether the accordion is collapsible.
         */
        this.collapsible = input(this.config.collapsible, {
            alias: 'ngpAccordionCollapsible',
            transform: booleanAttribute,
        });
        /**
         * The value of the accordion.
         */
        this.value = model(null, {
            alias: 'ngpAccordionValue',
        });
        /**
         * Whether the accordion is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpAccordionDisabled',
            transform: booleanAttribute,
        });
        /**
         * The accordion orientation.
         */
        this.orientation = input(this.config.orientation, {
            alias: 'ngpAccordionOrientation',
        });
    }
    /**
     * @param value The value to check.
     * @returns Whether the value is open.
     * @internal
     */
    isOpen(value) {
        if (this.type() === 'multiple') {
            return this.value()?.includes(value) ?? false;
        }
        return this.value() === value;
    }
    toggle(value) {
        const isOpen = this.isOpen(value);
        // if we are in single mode and the value is already open and the accordion is not collapsible, do nothing
        if (this.type() === 'single' && isOpen && !this.collapsible()) {
            return;
        }
        // if we are in single mode then toggle the value
        if (this.type() === 'single') {
            this.value.set(isOpen ? null : value);
            return;
        }
        // if we are in multiple mode then toggle the value
        const values = this.value() ?? [];
        if (isOpen) {
            this.value.set(values.filter(v => v !== value));
        }
        else {
            this.value.set([...values, value]);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpAccordion, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpAccordion, isStandalone: true, selector: "[ngpAccordion]", inputs: { type: { classPropertyName: "type", publicName: "ngpAccordionType", isSignal: true, isRequired: false, transformFunction: null }, collapsible: { classPropertyName: "collapsible", publicName: "ngpAccordionCollapsible", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpAccordionValue", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpAccordionDisabled", isSignal: true, isRequired: false, transformFunction: null }, orientation: { classPropertyName: "orientation", publicName: "ngpAccordionOrientation", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { value: "ngpAccordionValueChange" }, host: { properties: { "attr.data-orientation": "orientation()", "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [{ provide: NgpAccordionToken, useExisting: NgpAccordion }], exportAs: ["ngpAccordion"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpAccordion, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpAccordion]',
                    exportAs: 'ngpAccordion',
                    providers: [{ provide: NgpAccordionToken, useExisting: NgpAccordion }],
                    host: {
                        '[attr.data-orientation]': 'orientation()',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                    },
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3JkaW9uLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL25nLXByaW1pdGl2ZXMvYWNjb3JkaW9uL3NyYy9hY2NvcmRpb24vYWNjb3JkaW9uLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDbkUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7O0FBWXRELE1BQU0sT0FBTyxZQUFZO0lBVnpCO1FBV0U7O1dBRUc7UUFDYyxXQUFNLEdBQUcscUJBQXFCLEVBQUUsQ0FBQztRQUVsRDs7V0FFRztRQUNNLFNBQUksR0FBRyxLQUFLLENBQW1CLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQ3hELEtBQUssRUFBRSxrQkFBa0I7U0FDMUIsQ0FBQyxDQUFDO1FBRUg7O1dBRUc7UUFDTSxnQkFBVyxHQUFHLEtBQUssQ0FBd0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUU7WUFDM0UsS0FBSyxFQUFFLHlCQUF5QjtZQUNoQyxTQUFTLEVBQUUsZ0JBQWdCO1NBQzVCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sVUFBSyxHQUFHLEtBQUssQ0FBaUIsSUFBSSxFQUFFO1lBQzNDLEtBQUssRUFBRSxtQkFBbUI7U0FDM0IsQ0FBQyxDQUFDO1FBRUg7O1dBRUc7UUFDTSxhQUFRLEdBQUcsS0FBSyxDQUF3QixLQUFLLEVBQUU7WUFDdEQsS0FBSyxFQUFFLHNCQUFzQjtZQUM3QixTQUFTLEVBQUUsZ0JBQWdCO1NBQzVCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sZ0JBQVcsR0FBRyxLQUFLLENBQTRCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFO1lBQy9FLEtBQUssRUFBRSx5QkFBeUI7U0FDakMsQ0FBQyxDQUFDO0tBc0NKO0lBcENDOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsS0FBUTtRQUNiLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLFVBQVUsRUFBRSxDQUFDO1lBQy9CLE9BQVEsSUFBSSxDQUFDLEtBQUssRUFBaUIsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDO1FBQ2hFLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxLQUFLLENBQUM7SUFDaEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFRO1FBQ2IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVsQywwR0FBMEc7UUFDMUcsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssUUFBUSxJQUFJLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO1lBQzlELE9BQU87UUFDVCxDQUFDO1FBRUQsaURBQWlEO1FBQ2pELElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN0QyxPQUFPO1FBQ1QsQ0FBQztRQUVELG1EQUFtRDtRQUNuRCxNQUFNLE1BQU0sR0FBSSxJQUFJLENBQUMsS0FBSyxFQUFVLElBQUksRUFBRSxDQUFDO1FBRTNDLElBQUksTUFBTSxFQUFFLENBQUM7WUFDWCxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEQsQ0FBQzthQUFNLENBQUM7WUFDTixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQztJQUNILENBQUM7K0dBOUVVLFlBQVk7bUdBQVosWUFBWSw0NkJBTlosQ0FBQyxFQUFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLENBQUM7OzRGQU0zRCxZQUFZO2tCQVZ4QixTQUFTO21CQUFDO29CQUNULFVBQVUsRUFBRSxJQUFJO29CQUNoQixRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixRQUFRLEVBQUUsY0FBYztvQkFDeEIsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxjQUFjLEVBQUUsQ0FBQztvQkFDdEUsSUFBSSxFQUFFO3dCQUNKLHlCQUF5QixFQUFFLGVBQWU7d0JBQzFDLHNCQUFzQixFQUFFLHdCQUF3QjtxQkFDakQ7aUJBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCDCqSAyMDI0IEFuZ3VsYXIgUHJpbWl0aXZlcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZy1wcmltaXRpdmVzL25nLXByaW1pdGl2ZXNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCB7IEJvb2xlYW5JbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIGJvb2xlYW5BdHRyaWJ1dGUsIGlucHV0LCBtb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaW5qZWN0QWNjb3JkaW9uQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2FjY29yZGlvbi5jb25maWcnO1xuaW1wb3J0IHsgTmdwQWNjb3JkaW9uVG9rZW4gfSBmcm9tICcuL2FjY29yZGlvbi50b2tlbic7XG5cbkBEaXJlY3RpdmUoe1xuICBzdGFuZGFsb25lOiB0cnVlLFxuICBzZWxlY3RvcjogJ1tuZ3BBY2NvcmRpb25dJyxcbiAgZXhwb3J0QXM6ICduZ3BBY2NvcmRpb24nLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5ncEFjY29yZGlvblRva2VuLCB1c2VFeGlzdGluZzogTmdwQWNjb3JkaW9uIH1dLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLmRhdGEtb3JpZW50YXRpb25dJzogJ29yaWVudGF0aW9uKCknLFxuICAgICdbYXR0ci5kYXRhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCgpID8gXCJcIiA6IG51bGwnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBOZ3BBY2NvcmRpb248VD4ge1xuICAvKipcbiAgICogQWNjZXNzIHRoZSBnbG9iYWwgYWNjb3JkaW9uIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZyA9IGluamVjdEFjY29yZGlvbkNvbmZpZygpO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgYWNjb3JkaW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZSA9IGlucHV0PE5ncEFjY29yZGlvblR5cGU+KHRoaXMuY29uZmlnLnR5cGUsIHtcbiAgICBhbGlhczogJ25ncEFjY29yZGlvblR5cGUnLFxuICB9KTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgYWNjb3JkaW9uIGlzIGNvbGxhcHNpYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgY29sbGFwc2libGUgPSBpbnB1dDxib29sZWFuLCBCb29sZWFuSW5wdXQ+KHRoaXMuY29uZmlnLmNvbGxhcHNpYmxlLCB7XG4gICAgYWxpYXM6ICduZ3BBY2NvcmRpb25Db2xsYXBzaWJsZScsXG4gICAgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlLFxuICB9KTtcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBhY2NvcmRpb24uXG4gICAqL1xuICByZWFkb25seSB2YWx1ZSA9IG1vZGVsPFQgfCBUW10gfCBudWxsPihudWxsLCB7XG4gICAgYWxpYXM6ICduZ3BBY2NvcmRpb25WYWx1ZScsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBhY2NvcmRpb24gaXMgZGlzYWJsZWQuXG4gICAqL1xuICByZWFkb25seSBkaXNhYmxlZCA9IGlucHV0PGJvb2xlYW4sIEJvb2xlYW5JbnB1dD4oZmFsc2UsIHtcbiAgICBhbGlhczogJ25ncEFjY29yZGlvbkRpc2FibGVkJyxcbiAgICB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgYWNjb3JkaW9uIG9yaWVudGF0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgb3JpZW50YXRpb24gPSBpbnB1dDwnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnPih0aGlzLmNvbmZpZy5vcmllbnRhdGlvbiwge1xuICAgIGFsaWFzOiAnbmdwQWNjb3JkaW9uT3JpZW50YXRpb24nLFxuICB9KTtcblxuICAvKipcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgb3Blbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpc09wZW4odmFsdWU6IFQpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50eXBlKCkgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZSgpIGFzIFRbXSB8IG51bGwpPy5pbmNsdWRlcyh2YWx1ZSkgPz8gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudmFsdWUoKSA9PT0gdmFsdWU7XG4gIH1cblxuICB0b2dnbGUodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBpc09wZW4gPSB0aGlzLmlzT3Blbih2YWx1ZSk7XG5cbiAgICAvLyBpZiB3ZSBhcmUgaW4gc2luZ2xlIG1vZGUgYW5kIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IG9wZW4gYW5kIHRoZSBhY2NvcmRpb24gaXMgbm90IGNvbGxhcHNpYmxlLCBkbyBub3RoaW5nXG4gICAgaWYgKHRoaXMudHlwZSgpID09PSAnc2luZ2xlJyAmJiBpc09wZW4gJiYgIXRoaXMuY29sbGFwc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGFyZSBpbiBzaW5nbGUgbW9kZSB0aGVuIHRvZ2dsZSB0aGUgdmFsdWVcbiAgICBpZiAodGhpcy50eXBlKCkgPT09ICdzaW5nbGUnKSB7XG4gICAgICB0aGlzLnZhbHVlLnNldChpc09wZW4gPyBudWxsIDogdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGFyZSBpbiBtdWx0aXBsZSBtb2RlIHRoZW4gdG9nZ2xlIHRoZSB2YWx1ZVxuICAgIGNvbnN0IHZhbHVlcyA9ICh0aGlzLnZhbHVlKCkgYXMgVFtdKSA/PyBbXTtcblxuICAgIGlmIChpc09wZW4pIHtcbiAgICAgIHRoaXMudmFsdWUuc2V0KHZhbHVlcy5maWx0ZXIodiA9PiB2ICE9PSB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlLnNldChbLi4udmFsdWVzLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBOZ3BBY2NvcmRpb25UeXBlID0gJ3NpbmdsZScgfCAnbXVsdGlwbGUnO1xuIl19