import { afterNextRender, booleanAttribute, contentChild, contentChildren, Directive, inject, Injector, input, model, } from '@angular/core';
import { injectDateAdapter } from 'ng-primitives/date-time';
import { NgpDatePickerDateButtonToken } from '../date-picker-date-button/date-picker-date-button.token';
import { NgpDatePickerLabelToken } from '../date-picker-label/date-picker-label.token';
import { NgpDatePickerToken } from './date-picker.token';
import * as i0 from "@angular/core";
export class NgpDatePicker {
    constructor() {
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * The minimum date that can be selected.
         */
        this.min = input(undefined, {
            alias: 'ngpDatePickerMin',
        });
        /**
         * The maximum date that can be selected.
         */
        this.max = input(undefined, {
            alias: 'ngpDatePickerMax',
        });
        /**
         * Determine if the date picker is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpDatePickerDisabled',
            transform: booleanAttribute,
        });
        /**
         * A function that is called to determine if a specific date should be disabled.
         */
        this.dateDisabled = input(() => false, {
            alias: 'ngpDatePickerDateDisabled',
        });
        /**
         * The selected value.
         */
        this.date = model(undefined, {
            alias: 'ngpDatePickerDate',
        });
        /**
         * The focused value.
         */
        this.focusedDate = model(this.dateAdapter.now(), {
            alias: 'ngpDatePickerFocusedDate',
        });
        /**
         * Detect the label element.
         * @internal
         */
        this.label = contentChild(NgpDatePickerLabelToken, { descendants: true });
        /**
         * Access all the date picker buttons
         */
        this.buttons = contentChildren(NgpDatePickerDateButtonToken, { descendants: true });
    }
    /**
     * Set the focused date.
     * @param date The date to focus.
     * @internal
     */
    setFocusedDate(date, origin = 'mouse', direction) {
        if (this.disabled()) {
            return;
        }
        const min = this.min();
        const max = this.max();
        if (min && this.dateAdapter.isBefore(date, min)) {
            date = min;
        }
        if (max && this.dateAdapter.isAfter(date, max)) {
            date = max;
        }
        // if the date is disabled, find the next available date in the specified direction.
        if (this.dateDisabled()(date)) {
            let nextDate = this.dateAdapter.add(date, { days: direction === 'forward' ? 1 : -1 });
            while (this.dateDisabled()(nextDate) ||
                (min && this.dateAdapter.isBefore(nextDate, min)) ||
                (max && this.dateAdapter.isAfter(nextDate, max))) {
                nextDate = this.dateAdapter.add(nextDate, { days: direction === 'forward' ? 1 : -1 });
            }
            date = nextDate;
        }
        this.focusedDate.set(date);
        if (origin === 'keyboard') {
            afterNextRender({
                write: () => {
                    this.buttons().forEach(button => button.focus());
                },
            }, {
                injector: this.injector,
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePicker, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "18.2.13", type: NgpDatePicker, isStandalone: true, selector: "[ngpDatePicker]", inputs: { min: { classPropertyName: "min", publicName: "ngpDatePickerMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpDatePickerMax", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpDatePickerDisabled", isSignal: true, isRequired: false, transformFunction: null }, dateDisabled: { classPropertyName: "dateDisabled", publicName: "ngpDatePickerDateDisabled", isSignal: true, isRequired: false, transformFunction: null }, date: { classPropertyName: "date", publicName: "ngpDatePickerDate", isSignal: true, isRequired: false, transformFunction: null }, focusedDate: { classPropertyName: "focusedDate", publicName: "ngpDatePickerFocusedDate", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { date: "ngpDatePickerDateChange", focusedDate: "ngpDatePickerFocusedDateChange" }, host: { properties: { "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [{ provide: NgpDatePickerToken, useExisting: NgpDatePicker }], queries: [{ propertyName: "label", first: true, predicate: NgpDatePickerLabelToken, descendants: true, isSignal: true }, { propertyName: "buttons", predicate: NgpDatePickerDateButtonToken, descendants: true, isSignal: true }], exportAs: ["ngpDatePicker"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePicker, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePicker]',
                    exportAs: 'ngpDatePicker',
                    providers: [{ provide: NgpDatePickerToken, useExisting: NgpDatePicker }],
                    host: {
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                    },
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvbmctcHJpbWl0aXZlcy9kYXRlLXBpY2tlci9zcmMvZGF0ZS1waWNrZXIvZGF0ZS1waWNrZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNBLE9BQU8sRUFDTCxlQUFlLEVBQ2YsZ0JBQWdCLEVBQ2hCLFlBQVksRUFDWixlQUFlLEVBQ2YsU0FBUyxFQUNULE1BQU0sRUFDTixRQUFRLEVBQ1IsS0FBSyxFQUNMLEtBQUssR0FDTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSwwREFBMEQsQ0FBQztBQUN4RyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4Q0FBOEMsQ0FBQztBQUN2RixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7QUFXekQsTUFBTSxPQUFPLGFBQWE7SUFUMUI7UUFVRTs7V0FFRztRQUNjLGdCQUFXLEdBQUcsaUJBQWlCLEVBQUssQ0FBQztRQUV0RDs7V0FFRztRQUNjLGFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFN0M7O1dBRUc7UUFDTSxRQUFHLEdBQUcsS0FBSyxDQUFnQixTQUFTLEVBQUU7WUFDN0MsS0FBSyxFQUFFLGtCQUFrQjtTQUMxQixDQUFDLENBQUM7UUFFSDs7V0FFRztRQUNNLFFBQUcsR0FBRyxLQUFLLENBQWdCLFNBQVMsRUFBRTtZQUM3QyxLQUFLLEVBQUUsa0JBQWtCO1NBQzFCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBd0IsS0FBSyxFQUFFO1lBQ3RELEtBQUssRUFBRSx1QkFBdUI7WUFDOUIsU0FBUyxFQUFFLGdCQUFnQjtTQUM1QixDQUFDLENB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QUFFLElBQUksQ0FBQyxRQUFRO2FBQ3hCLENBQ0YsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDOytHQW5IVSxhQUFhO21HQUFiLGFBQWEsa2pDQUxiLENBQUMsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRSxDQUFDLDZEQStEMUMsdUJBQXVCLDZFQUtWLDRCQUE0Qjs7NEZBL0Q1RCxhQUFhO2tCQVR6QixTQUFTO21CQUFDO29CQUNULFVBQVUsRUFBRSxJQUFJO29CQUNoQixRQUFRLEVBQUUsaUJBQWlCO29CQUMzQixRQUFRLEVBQUUsZUFBZTtvQkFDekIsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxlQUFlLEVBQUUsQ0FBQztvQkFDeEUsSUFBSSxFQUFFO3dCQUNKLHNCQUFzQixFQUFFLHdCQUF3QjtxQkFDakQ7aUJBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCDCqSAyMDI0IEFuZ3VsYXIgUHJpbWl0aXZlcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZy1wcmltaXRpdmVzL25nLXByaW1pdGl2ZXNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCB7IEZvY3VzT3JpZ2luIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQm9vbGVhbklucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIGFmdGVyTmV4dFJlbmRlcixcbiAgYm9vbGVhbkF0dHJpYnV0ZSxcbiAgY29udGVudENoaWxkLFxuICBjb250ZW50Q2hpbGRyZW4sXG4gIERpcmVjdGl2ZSxcbiAgaW5qZWN0LFxuICBJbmplY3RvcixcbiAgaW5wdXQsXG4gIG1vZGVsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGluamVjdERhdGVBZGFwdGVyIH0gZnJvbSAnbmctcHJpbWl0aXZlcy9kYXRlLXRpbWUnO1xuaW1wb3J0IHsgTmdwRGF0ZVBpY2tlckRhdGVCdXR0b25Ub2tlbiB9IGZyb20gJy4uL2RhdGUtcGlja2VyLWRhdGUtYnV0dG9uL2RhdGUtcGlja2VyLWRhdGUtYnV0dG9uLnRva2VuJztcbmltcG9ydCB7IE5ncERhdGVQaWNrZXJMYWJlbFRva2VuIH0gZnJvbSAnLi4vZGF0ZS1waWNrZXItbGFiZWwvZGF0ZS1waWNrZXItbGFiZWwudG9rZW4nO1xuaW1wb3J0IHsgTmdwRGF0ZVBpY2tlclRva2VuIH0gZnJvbSAnLi9kYXRlLXBpY2tlci50b2tlbic7XG5cbkBEaXJlY3RpdmUoe1xuICBzdGFuZGFsb25lOiB0cnVlLFxuICBzZWxlY3RvcjogJ1tuZ3BEYXRlUGlja2VyXScsXG4gIGV4cG9ydEFzOiAnbmdwRGF0ZVBpY2tlcicsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmdwRGF0ZVBpY2tlclRva2VuLCB1c2VFeGlzdGluZzogTmdwRGF0ZVBpY2tlciB9XSxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5kYXRhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCgpID8gXCJcIiA6IG51bGwnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBOZ3BEYXRlUGlja2VyPFQ+IHtcbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgZGF0ZSBhZGFwdGVyLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkYXRlQWRhcHRlciA9IGluamVjdERhdGVBZGFwdGVyPFQ+KCk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgaW5qZWN0b3IuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGluamVjdG9yID0gaW5qZWN0KEluamVjdG9yKTtcblxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZGF0ZSB0aGF0IGNhbiBiZSBzZWxlY3RlZC5cbiAgICovXG4gIHJlYWRvbmx5IG1pbiA9IGlucHV0PFQgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCwge1xuICAgIGFsaWFzOiAnbmdwRGF0ZVBpY2tlck1pbicsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBkYXRlIHRoYXQgY2FuIGJlIHNlbGVjdGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgbWF4ID0gaW5wdXQ8VCB8IHVuZGVmaW5lZD4odW5kZWZpbmVkLCB7XG4gICAgYWxpYXM6ICduZ3BEYXRlUGlja2VyTWF4JyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgZGF0ZSBwaWNrZXIgaXMgZGlzYWJsZWQuXG4gICAqL1xuICByZWFkb25seSBkaXNhYmxlZCA9IGlucHV0PGJvb2xlYW4sIEJvb2xlYW5JbnB1dD4oZmFsc2UsIHtcbiAgICBhbGlhczogJ25ncERhdGVQaWNrZXJEaXNhYmxlZCcsXG4gICAgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlLFxuICB9KTtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBkYXRlIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGVEaXNhYmxlZCA9IGlucHV0PChkYXRlOiBUKSA9PiBib29sZWFuPigoKSA9PiBmYWxzZSwge1xuICAgIGFsaWFzOiAnbmdwRGF0ZVBpY2tlckRhdGVEaXNhYmxlZCcsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAqL1xuICByZWFkb25seSBkYXRlID0gbW9kZWw8VCB8IHVuZGVmaW5lZD4odW5kZWZpbmVkLCB7XG4gICAgYWxpYXM6ICduZ3BEYXRlUGlja2VyRGF0ZScsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9jdXNlZCB2YWx1ZS5cbiAgICovXG4gIHJlYWRvbmx5IGZvY3VzZWREYXRlID0gbW9kZWw8VD4odGhpcy5kYXRlQWRhcHRlci5ub3coKSwge1xuICAgIGFsaWFzOiAnbmdwRGF0ZVBpY2tlckZvY3VzZWREYXRlJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERldGVjdCB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWFkb25seSBsYWJlbCA9IGNvbnRlbnRDaGlsZChOZ3BEYXRlUGlja2VyTGFiZWxUb2tlbiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KTtcblxuICAvKipcbiAgICogQWNjZXNzIGFsbCB0aGUgZGF0ZSBwaWNrZXIgYnV0dG9uc1xuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBidXR0b25zID0gY29udGVudENoaWxkcmVuKE5ncERhdGVQaWNrZXJEYXRlQnV0dG9uVG9rZW4sIHsgZGVzY2VuZGFudHM6IHRydWUgfSk7XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXNlZCBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBmb2N1cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRGb2N1c2VkRGF0ZShkYXRlOiBULCBvcmlnaW46IEZvY3VzT3JpZ2luID0gJ21vdXNlJywgZGlyZWN0aW9uOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluKCk7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXgoKTtcblxuICAgIGlmIChtaW4gJiYgdGhpcy5kYXRlQWRhcHRlci5pc0JlZm9yZShkYXRlLCBtaW4pKSB7XG4gICAgICBkYXRlID0gbWluO1xuICAgIH1cblxuICAgIGlmIChtYXggJiYgdGhpcy5kYXRlQWRhcHRlci5pc0FmdGVyKGRhdGUsIG1heCkpIHtcbiAgICAgIGRhdGUgPSBtYXg7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGRhdGUgaXMgZGlzYWJsZWQsIGZpbmQgdGhlIG5leHQgYXZhaWxhYmxlIGRhdGUgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uXG4gICAgaWYgKHRoaXMuZGF0ZURpc2FibGVkKCkoZGF0ZSkpIHtcbiAgICAgIGxldCBuZXh0RGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIuYWRkKGRhdGUsIHsgZGF5czogZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyAxIDogLTEgfSk7XG5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgdGhpcy5kYXRlRGlzYWJsZWQoKShuZXh0RGF0ZSkgfHxcbiAgICAgICAgKG1pbiAmJiB0aGlzLmRhdGVBZGFwdGVyLmlzQmVmb3JlKG5leHREYXRlLCBtaW4pKSB8fFxuICAgICAgICAobWF4ICYmIHRoaXMuZGF0ZUFkYXB0ZXIuaXNBZnRlcihuZXh0RGF0ZSwgbWF4KSlcbiAgICAgICkge1xuICAgICAgICBuZXh0RGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIuYWRkKG5leHREYXRlLCB7IGRheXM6IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gMSA6IC0xIH0pO1xuICAgICAgfVxuXG4gICAgICBkYXRlID0gbmV4dERhdGU7XG4gICAgfVxuXG4gICAgdGhpcy5mb2N1c2VkRGF0ZS5zZXQoZGF0ZSk7XG5cbiAgICBpZiAob3JpZ2luID09PSAna2V5Ym9hcmQnKSB7XG4gICAgICBhZnRlck5leHRSZW5kZXIoXG4gICAgICAgIHtcbiAgICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b25zKCkuZm9yRWFjaChidXR0b24gPT4gYnV0dG9uLmZvY3VzKCkpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpbmplY3RvcjogdGhpcy5pbmplY3RvcixcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=