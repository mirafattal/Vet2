/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { computed, Directive, inject, Injector, TemplateRef, ViewContainerRef, } from '@angular/core';
import { injectDateAdapter } from 'ng-primitives/date-time';
import { onChange } from 'ng-primitives/utils';
import { injectDatePicker } from '../date-picker/date-picker.token';
import { NgpDatePickerRowRenderToken, NgpDatePickerWeekToken, } from './date-picker-row-render.token';
import * as i0 from "@angular/core";
export class NgpDatePickerRowRender {
    constructor() {
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Access the template ref for the cell.
         */
        this.templateRef = inject(TemplateRef);
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Get all the days to display, this is the days of the current month
         * and the days of the previous and next month to fill the grid.
         */
        this.days = computed(() => {
            const month = this.datePicker.focusedDate();
            const days = [];
            // Get the first and last day of the month.
            let firstDay = this.dateAdapter.startOfMonth(month);
            let lastDay = this.dateAdapter.endOfMonth(month);
            // find the first and last day of visible in the grid.
            firstDay = this.dateAdapter.subtract(firstDay, {
                days: this.dateAdapter.getDay(firstDay),
            });
            lastDay = this.dateAdapter.add(lastDay, {
                days: 6 - this.dateAdapter.getDay(lastDay),
            });
            // collect all the days to display.
            while (firstDay <= lastDay) {
                days.push(firstDay);
                firstDay = this.dateAdapter.add(firstDay, { days: 1 });
            }
            return days;
        });
        // get the weeks to display.
        this.weeks = computed(() => {
            const days = this.days();
            const weeks = [];
            for (let i = 0; i < days.length; i += 7) {
                weeks.push(days.slice(i, i + 7));
            }
            return weeks;
        });
        /**
         * Store the embedded view refs of each rendered row.
         */
        this.viewRefs = [];
        // re-render the rows when the month changes.
        onChange(this.datePicker.focusedDate, (date, previousDate) => {
            if (!date || !previousDate || !this.dateAdapter.isSameMonth(date, previousDate)) {
                this.renderRows();
            }
        });
    }
    ngOnDestroy() {
        this.destroyRows();
    }
    /**
     * Render the row.
     */
    renderRows() {
        const weeks = this.weeks();
        // clear the view container.
        this.destroyRows();
        // render the weeks.
        for (const week of weeks) {
            const viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, null, {
                injector: Injector.create({
                    parent: this.viewContainerRef.injector,
                    providers: [{ provide: NgpDatePickerWeekToken, useValue: week }],
                }),
            });
            this.viewRefs.push(viewRef);
        }
    }
    /**
     * Destroy the row.
     */
    destroyRows() {
        for (const viewRef of this.viewRefs) {
            viewRef.destroy();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerRowRender, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpDatePickerRowRender, isStandalone: true, selector: "[ngpDatePickerRowRender]", providers: [{ provide: NgpDatePickerRowRenderToken, useExisting: NgpDatePickerRowRender }], exportAs: ["ngpDatePickerRowRender"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerRowRender, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerRowRender]',
                    exportAs: 'ngpDatePickerRowRender',
                    providers: [{ provide: NgpDatePickerRowRenderToken, useExisting: NgpDatePickerRowRender }],
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXItcm93LXJlbmRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9uZy1wcmltaXRpdmVzL2RhdGUtcGlja2VyL3NyYy9kYXRlLXBpY2tlci1yb3ctcmVuZGVyL2RhdGUtcGlja2VyLXJvdy1yZW5kZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUNILE9BQU8sRUFDTCxRQUFRLEVBQ1IsU0FBUyxFQUVULE1BQU0sRUFDTixRQUFRLEVBRVIsV0FBVyxFQUNYLGdCQUFnQixHQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDcEUsT0FBTyxFQUNMLDJCQUEyQixFQUMzQixzQkFBc0IsR0FDdkIsTUFBTSxnQ0FBZ0MsQ0FBQzs7QUFReEMsTUFBTSxPQUFPLHNCQUFzQjtJQW1FakM7UUFsRUE7O1dBRUc7UUFDYyxnQkFBVyxHQUFHLGlCQUFpQixFQUFLLENBQUM7UUFFdEQ7O1dBRUc7UUFDYyxlQUFVLEdBQUcsZ0JBQWdCLEVBQUssQ0FBQztRQUVwRDs7V0FFRztRQUNjLGdCQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRW5EOztXQUVHO1FBQ2MscUJBQWdCLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFN0Q7OztXQUdHO1FBQ2dCLFNBQUksR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQ3RDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDNUMsTUFBTSxJQUFJLEdBQVEsRUFBRSxDQUFDO1lBRXJCLDJD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LENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssV0FBVztRQUNqQixLQUFLLE1BQU0sT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNwQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEIsQ0FBQztJQUNILENBQUM7K0dBNUdVLHNCQUFzQjttR0FBdEIsc0JBQXNCLHVFQUZ0QixDQUFDLEVBQUUsT0FBTyxFQUFFLDJCQUEyQixFQUFFLFdBQVcsRUFBRSxzQkFBc0IsRUFBRSxDQUFDOzs0RkFFL0Usc0JBQXNCO2tCQU5sQyxTQUFTO21CQUFDO29CQUNULFVBQVUsRUFBRSxJQUFJO29CQUNoQixRQUFRLEVBQUUsMEJBQTBCO29CQUNwQyxRQUFRLEVBQUUsd0JBQXdCO29CQUNsQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxXQUFXLHdCQUF3QixFQUFFLENBQUM7aUJBQzNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgwqkgMjAyNCBBbmd1bGFyIFByaW1pdGl2ZXMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmctcHJpbWl0aXZlcy9uZy1wcmltaXRpdmVzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQge1xuICBjb21wdXRlZCxcbiAgRGlyZWN0aXZlLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIGluamVjdCxcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaW5qZWN0RGF0ZUFkYXB0ZXIgfSBmcm9tICduZy1wcmltaXRpdmVzL2RhdGUtdGltZSc7XG5pbXBvcnQgeyBvbkNoYW5nZSB9IGZyb20gJ25nLXByaW1pdGl2ZXMvdXRpbHMnO1xuaW1wb3J0IHsgaW5qZWN0RGF0ZVBpY2tlciB9IGZyb20gJy4uL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLnRva2VuJztcbmltcG9ydCB7XG4gIE5ncERhdGVQaWNrZXJSb3dSZW5kZXJUb2tlbixcbiAgTmdwRGF0ZVBpY2tlcldlZWtUb2tlbixcbn0gZnJvbSAnLi9kYXRlLXBpY2tlci1yb3ctcmVuZGVyLnRva2VuJztcblxuQERpcmVjdGl2ZSh7XG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIHNlbGVjdG9yOiAnW25ncERhdGVQaWNrZXJSb3dSZW5kZXJdJyxcbiAgZXhwb3J0QXM6ICduZ3BEYXRlUGlja2VyUm93UmVuZGVyJyxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOZ3BEYXRlUGlja2VyUm93UmVuZGVyVG9rZW4sIHVzZUV4aXN0aW5nOiBOZ3BEYXRlUGlja2VyUm93UmVuZGVyIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBOZ3BEYXRlUGlja2VyUm93UmVuZGVyPFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgZGF0ZSBhZGFwdGVyLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkYXRlQWRhcHRlciA9IGluamVjdERhdGVBZGFwdGVyPFQ+KCk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgZGF0ZSBwaWNrZXIuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGRhdGVQaWNrZXIgPSBpbmplY3REYXRlUGlja2VyPFQ+KCk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgdGVtcGxhdGUgcmVmIGZvciB0aGUgY2VsbC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVSZWYgPSBpbmplY3QoVGVtcGxhdGVSZWYpO1xuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdGhlIHZpZXcgY29udGFpbmVyIHJlZi5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgdmlld0NvbnRhaW5lclJlZiA9IGluamVjdChWaWV3Q29udGFpbmVyUmVmKTtcblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgZGF5cyB0byBkaXNwbGF5LCB0aGlzIGlzIHRoZSBkYXlzIG9mIHRoZSBjdXJyZW50IG1vbnRoXG4gICAqIGFuZCB0aGUgZGF5cyBvZiB0aGUgcHJldmlvdXMgYW5kIG5leHQgbW9udGggdG8gZmlsbCB0aGUgZ3JpZC5cbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYXlzID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IG1vbnRoID0gdGhpcy5kYXRlUGlja2VyLmZvY3VzZWREYXRlKCk7XG4gICAgY29uc3QgZGF5czogVFtdID0gW107XG5cbiAgICAvLyBHZXQgdGhlIGZpcnN0IGFuZCBsYXN0IGRheSBvZiB0aGUgbW9udGguXG4gICAgbGV0IGZpcnN0RGF5ID0gdGhpcy5kYXRlQWRhcHRlci5zdGFydE9mTW9udGgobW9udGgpO1xuICAgIGxldCBsYXN0RGF5ID0gdGhpcy5kYXRlQWRhcHRlci5lbmRPZk1vbnRoKG1vbnRoKTtcblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGFuZCBsYXN0IGRheSBvZiB2aXNpYmxlIGluIHRoZSBncmlkLlxuICAgIGZpcnN0RGF5ID0gdGhpcy5kYXRlQWRhcHRlci5zdWJ0cmFjdChmaXJzdERheSwge1xuICAgICAgZGF5czogdGhpcy5kYXRlQWRhcHRlci5nZXREYXkoZmlyc3REYXkpLFxuICAgIH0pO1xuICAgIGxhc3REYXkgPSB0aGlzLmRhdGVBZGFwdGVyLmFkZChsYXN0RGF5LCB7XG4gICAgICBkYXlzOiA2IC0gdGhpcy5kYXRlQWRhcHRlci5nZXREYXkobGFzdERheSksXG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IGFsbCB0aGUgZGF5cyB0byBkaXNwbGF5LlxuICAgIHdoaWxlIChmaXJzdERheSA8PSBsYXN0RGF5KSB7XG4gICAgICBkYXlzLnB1c2goZmlyc3REYXkpO1xuICAgICAgZmlyc3REYXkgPSB0aGlzLmRhdGVBZGFwdGVyLmFkZChmaXJzdERheSwgeyBkYXlzOiAxIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkYXlzO1xuICB9KTtcblxuICAvLyBnZXQgdGhlIHdlZWtzIHRvIGRpc3BsYXkuXG4gIHByb3RlY3RlZCByZWFkb25seSB3ZWVrcyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCBkYXlzID0gdGhpcy5kYXlzKCk7XG4gICAgY29uc3Qgd2Vla3MgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF5cy5sZW5ndGg7IGkgKz0gNykge1xuICAgICAgd2Vla3MucHVzaChkYXlzLnNsaWNlKGksIGkgKyA3KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdlZWtzO1xuICB9KTtcblxuICAvKipcbiAgICogU3RvcmUgdGhlIGVtYmVkZGVkIHZpZXcgcmVmcyBvZiBlYWNoIHJlbmRlcmVkIHJvdy5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgdmlld1JlZnM6IEVtYmVkZGVkVmlld1JlZjx2b2lkPltdID0gW107XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gcmUtcmVuZGVyIHRoZSByb3dzIHdoZW4gdGhlIG1vbnRoIGNoYW5nZXMuXG4gICAgb25DaGFuZ2UodGhpcy5kYXRlUGlja2VyLmZvY3VzZWREYXRlLCAoZGF0ZSwgcHJldmlvdXNEYXRlKSA9PiB7XG4gICAgICBpZiAoIWRhdGUgfHwgIXByZXZpb3VzRGF0ZSB8fCAhdGhpcy5kYXRlQWRhcHRlci5pc1NhbWVNb250aChkYXRlLCBwcmV2aW91c0RhdGUpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUm93cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95Um93cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgcm93LlxuICAgKi9cbiAgcHJpdmF0ZSByZW5kZXJSb3dzKCk6IHZvaWQge1xuICAgIGNvbnN0IHdlZWtzID0gdGhpcy53ZWVrcygpO1xuXG4gICAgLy8gY2xlYXIgdGhlIHZpZXcgY29udGFpbmVyLlxuICAgIHRoaXMuZGVzdHJveVJvd3MoKTtcblxuICAgIC8vIHJlbmRlciB0aGUgd2Vla3MuXG4gICAgZm9yIChjb25zdCB3ZWVrIG9mIHdlZWtzKSB7XG4gICAgICBjb25zdCB2aWV3UmVmID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlUmVmLCBudWxsLCB7XG4gICAgICAgIGluamVjdG9yOiBJbmplY3Rvci5jcmVhdGUoe1xuICAgICAgICAgIHBhcmVudDogdGhpcy52aWV3Q29udGFpbmVyUmVmLmluamVjdG9yLFxuICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmdwRGF0ZVBpY2tlcldlZWtUb2tlbiwgdXNlVmFsdWU6IHdlZWsgfV0sXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG4gICAgICB0aGlzLnZpZXdSZWZzLnB1c2godmlld1JlZik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHJvdy5cbiAgICovXG4gIHByaXZhdGUgZGVzdHJveVJvd3MoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCB2aWV3UmVmIG9mIHRoaXMudmlld1JlZnMpIHtcbiAgICAgIHZpZXdSZWYuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuIl19