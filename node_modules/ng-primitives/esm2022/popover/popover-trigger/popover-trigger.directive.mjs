import { DomPortalOutlet, TemplatePortal } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { Directive, ElementRef, Injector, ViewContainerRef, booleanAttribute, computed, inject, input, model, numberAttribute, signal, } from '@angular/core';
import { autoUpdate, computePosition, flip, offset, shift, } from '@floating-ui/dom';
import { injectDisposables, onBooleanChange } from 'ng-primitives/utils';
import { injectPopoverConfig } from '../config/popover.config';
import { NgpPopoverTriggerToken, providePopoverTrigger } from './popover-trigger.token';
import * as i0 from "@angular/core";
export class NgpPopoverTrigger {
    constructor() {
        /**
         * Access the trigger element
         */
        this.trigger = inject((ElementRef));
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the document.
         */
        this.document = inject(DOCUMENT);
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the global popover configuration.
         */
        this.config = injectPopoverConfig();
        /**
         * Access the disposable utilities
         */
        this.disposables = injectDisposables();
        /**
         * Access the popover template ref.
         */
        this.popover = input.required({
            alias: 'ngpPopoverTrigger',
        });
        /**
         * The open state of the popover.
         * @default false
         */
        this.open = model(false, {
            alias: 'ngpPopoverTriggerOpen',
        });
        /**
         * Define if the trigger should be disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpPopoverTriggerDisabled',
            transform: booleanAttribute,
        });
        /**
         * Define the placement of the popover relative to the trigger.
         * @default 'top'
         */
        this.placement = input(this.config.placement, {
            alias: 'ngpPopoverTriggerPlacement',
        });
        /**
         * Define the offset of the popover relative to the trigger.
         * @default 0
         */
        this.offset = input(this.config.offset, {
            alias: 'ngpPopoverTriggerOffset',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the popover is displayed.
         * @default 0
         */
        this.showDelay = input(this.config.showDelay, {
            alias: 'ngpPopoverTriggerShowDelay',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the popover is hidden.
         * @default 0
         */
        this.hideDelay = input(this.config.hideDelay, {
            alias: 'ngpPopoverTriggerHideDelay',
            transform: numberAttribute,
        });
        /**
         * Define whether the popover should flip when there is not enough space for the popover.
         * @default true
         */
        this.flip = input(this.config.flip, {
            alias: 'ngpPopoverTriggerFlip',
            transform: booleanAttribute,
        });
        /**
         * Define the container in which the popover should be attached.
         * @default document.body
         */
        this.container = input(this.config.container, {
            alias: 'ngpPopoverTriggerContainer',
        });
        /**
         * Define whether the popover should close when clicking outside of it.
         * @default true
         */
        this.closeOnOutsideClick = input(this.config.closeOnOutsideClick, {
            alias: 'ngpPopoverTriggerCloseOnOutsideClick',
            transform: booleanAttribute,
        });
        /**
         * Store the popover view ref.
         */
        this.viewRef = null;
        /**
         * Derive the popover middleware from the provided configuration.
         */
        this.middleware = computed(() => {
            const middleware = [offset(this.offset()), shift()];
            if (this.flip()) {
                middleware.push(flip());
            }
            return middleware;
        });
        /**
         * Store the computed position of the popover.
         * @internal
         */
        this.position = signal({
            x: 0,
            y: 0,
        });
        /**
         * Store the state of the popover.
         * @internal
         */
        this.state = signal('closed');
        // any time the open state changes then show or hide the popover
        onBooleanChange(this.open, this.show.bind(this), this.hide.bind(this));
    }
    ngOnDestroy() {
        this.destroyPopover();
    }
    toggleOpenState() {
        this.open.update(open => !open);
    }
    show() {
        // if the trigger is disabled or the popover is already open then do not show the popover
        if (this.disabled() || this.state() === 'open' || this.state() === 'opening') {
            return;
        }
        this.state.set('opening');
        this.disposables.setTimeout(() => this.createPopover(), this.showDelay());
        // Add document click listener to detect outside clicks
        if (this.closeOnOutsideClick()) {
            this.documentClickListener = this.onDocumentClick.bind(this);
            this.document.addEventListener('click', this.documentClickListener, true);
        }
    }
    hide() {
        // if the trigger is disabled or the popover is already closed then do not hide the popover
        if (this.disabled() || this.state() === 'closed' || this.state() === 'closing') {
            return;
        }
        this.state.set('closing');
        this.disposables.setTimeout(() => this.destroyPopover(), this.hideDelay());
        // Remove the document click listener when the popover is hidden
        if (this.documentClickListener) {
            this.document.removeEventListener('click', this.documentClickListener, true);
        }
    }
    onDocumentClick(event) {
        const target = event.target;
        // Check if the click is outside the trigger or the popover
        const isOutside = !this.trigger.nativeElement.contains(target) &&
            !(this.viewRef?.rootNodes[0]).contains(target);
        if (isOutside) {
            // Close the popover
            this.open.set(false);
        }
    }
    createPopover() {
        const portal = new TemplatePortal(this.popover(), this.viewContainerRef, undefined, this.injector);
        const domOutlet = new DomPortalOutlet(this.container() ?? this.document.body, undefined, undefined, Injector.create({
            parent: this.injector,
            providers: [providePopoverTrigger(this)],
        }));
        this.viewRef = domOutlet.attach(portal);
        this.viewRef.detectChanges();
        const outletElement = this.viewRef.rootNodes[0];
        this.dispose = autoUpdate(this.trigger.nativeElement, outletElement, async () => {
            const position = await computePosition(this.trigger.nativeElement, outletElement, {
                placement: this.placement(),
                middleware: this.middleware(),
            });
            this.position.set({ x: position.x, y: position.y });
        });
        this.state.set('open');
    }
    destroyPopover() {
        this.viewRef?.destroy();
        this.viewRef = null;
        this.dispose?.();
        this.state.set('closed');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPopoverTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpPopoverTrigger, isStandalone: true, selector: "[ngpPopoverTrigger]", inputs: { popover: { classPropertyName: "popover", publicName: "ngpPopoverTrigger", isSignal: true, isRequired: true, transformFunction: null }, open: { classPropertyName: "open", publicName: "ngpPopoverTriggerOpen", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpPopoverTriggerDisabled", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpPopoverTriggerPlacement", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "ngpPopoverTriggerOffset", isSignal: true, isRequired: false, transformFunction: null }, showDelay: { classPropertyName: "showDelay", publicName: "ngpPopoverTriggerShowDelay", isSignal: true, isRequired: false, transformFunction: null }, hideDelay: { classPropertyName: "hideDelay", publicName: "ngpPopoverTriggerHideDelay", isSignal: true, isRequired: false, transformFunction: null }, flip: { classPropertyName: "flip", publicName: "ngpPopoverTriggerFlip", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "ngpPopoverTriggerContainer", isSignal: true, isRequired: false, transformFunction: null }, closeOnOutsideClick: { classPropertyName: "closeOnOutsideClick", publicName: "ngpPopoverTriggerCloseOnOutsideClick", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { open: "ngpPopoverTriggerOpenChange" }, host: { listeners: { "click": "toggleOpenState()" }, properties: { "attr.data-state": "state()", "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [{ provide: NgpPopoverTriggerToken, useExisting: NgpPopoverTrigger }], exportAs: ["ngpPopoverTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPopoverTrigger, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpPopoverTrigger]',
                    exportAs: 'ngpPopoverTrigger',
                    providers: [{ provide: NgpPopoverTriggerToken, useExisting: NgpPopoverTrigger }],
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                        '(click)': 'toggleOpenState()',
                    },
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL25nLXByaW1pdGl2ZXMvcG9wb3Zlci9zcmMvcG9wb3Zlci10cmlnZ2VyL3BvcG92ZXItdHJpZ2dlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBRVYsUUFBUSxFQUdSLGdCQUFnQixFQUNoQixnQkFBZ0IsRUFDaEIsUUFBUSxFQUNSLE1BQU0sRUFDTixLQUFLLEVBQ0wsS0FBSyxFQUNMLGVBQWUsRUFDZixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUdMLFVBQVUsRUFDVixlQUFlLEVBQ2YsSUFBSSxFQUNKLE1BQU0sRUFDTixLQUFLLEdBQ04sTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDL0QsT0FBTyxFQUFFLHNCQUFzQixFQUFFLHFCQUFxQixFQUFFLE1BQU0seUJBQXlCLENBQUM7O0FBYXhGLE1BQU0sT0FBTyxpQkFBaUI7SUFnSzVCO1FBL0pBOztXQUVHO1FBQ2MsWUFBTyxHQUFHLE1BQU0sQ0FBQyxDQUFBLFVBQXVCLENBQUEsQ0FBQyxDQUFDO1FBRTNEOztXQUVHO1FBQ2MscUJBQWdCLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFN0Q7O1dBRUc7UUFDYyxhQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTdDOztXQUVHO1FB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QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMzQixDQUFDOytHQWxRVSxpQkFBaUI7bUdBQWpCLGlCQUFpQiwrc0RBUGpCLENBQUMsRUFBRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixFQUFFLENBQUM7OzRGQU9yRSxpQkFBaUI7a0JBWDdCLFNBQVM7bUJBQUM7b0JBQ1QsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSxxQkFBcUI7b0JBQy9CLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFNBQVMsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLFdBQVcsbUJBQW1CLEVBQUUsQ0FBQztvQkFDaEYsSUFBSSxFQUFFO3dCQUNKLG1CQUFtQixFQUFFLFNBQVM7d0JBQzlCLHNCQUFzQixFQUFFLHdCQUF3Qjt3QkFDaEQsU0FBUyxFQUFFLG1CQUFtQjtxQkFDL0I7aUJBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCDCqSAyMDI0IEFuZ3VsYXIgUHJpbWl0aXZlcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZy1wcmltaXRpdmVzL25nLXByaW1pdGl2ZXNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCB7IEJvb2xlYW5JbnB1dCwgTnVtYmVySW5wdXQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgRG9tUG9ydGFsT3V0bGV0LCBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIEluamVjdG9yLFxuICBPbkRlc3Ryb3ksXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBib29sZWFuQXR0cmlidXRlLFxuICBjb21wdXRlZCxcbiAgaW5qZWN0LFxuICBpbnB1dCxcbiAgbW9kZWwsXG4gIG51bWJlckF0dHJpYnV0ZSxcbiAgc2lnbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIE1pZGRsZXdhcmUsXG4gIFBsYWNlbWVudCxcbiAgYXV0b1VwZGF0ZSxcbiAgY29tcHV0ZVBvc2l0aW9uLFxuICBmbGlwLFxuICBvZmZzZXQsXG4gIHNoaWZ0LFxufSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmltcG9ydCB7IGluamVjdERpc3Bvc2FibGVzLCBvbkJvb2xlYW5DaGFuZ2UgfSBmcm9tICduZy1wcmltaXRpdmVzL3V0aWxzJztcbmltcG9ydCB7IGluamVjdFBvcG92ZXJDb25maWcgfSBmcm9tICcuLi9jb25maWcvcG9wb3Zlci5jb25maWcnO1xuaW1wb3J0IHsgTmdwUG9wb3ZlclRyaWdnZXJUb2tlbiwgcHJvdmlkZVBvcG92ZXJUcmlnZ2VyIH0gZnJvbSAnLi9wb3BvdmVyLXRyaWdnZXIudG9rZW4nO1xuXG5ARGlyZWN0aXZlKHtcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgc2VsZWN0b3I6ICdbbmdwUG9wb3ZlclRyaWdnZXJdJyxcbiAgZXhwb3J0QXM6ICduZ3BQb3BvdmVyVHJpZ2dlcicsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmdwUG9wb3ZlclRyaWdnZXJUb2tlbiwgdXNlRXhpc3Rpbmc6IE5ncFBvcG92ZXJUcmlnZ2VyIH1dLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLmRhdGEtc3RhdGVdJzogJ3N0YXRlKCknLFxuICAgICdbYXR0ci5kYXRhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCgpID8gXCJcIiA6IG51bGwnLFxuICAgICcoY2xpY2spJzogJ3RvZ2dsZU9wZW5TdGF0ZSgpJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTmdwUG9wb3ZlclRyaWdnZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAvKipcbiAgICogQWNjZXNzIHRoZSB0cmlnZ2VyIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgdHJpZ2dlciA9IGluamVjdChFbGVtZW50UmVmPEhUTUxFbGVtZW50Pik7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgdmlldyBjb250YWluZXIgcmVmLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSB2aWV3Q29udGFpbmVyUmVmID0gaW5qZWN0KFZpZXdDb250YWluZXJSZWYpO1xuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkb2N1bWVudCA9IGluamVjdChET0NVTUVOVCk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgaW5qZWN0b3IuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGluamVjdG9yID0gaW5qZWN0KEluamVjdG9yKTtcblxuICAvKipcbiAgICogQWNjZXNzIHRoZSBnbG9iYWwgcG9wb3ZlciBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWcgPSBpbmplY3RQb3BvdmVyQ29uZmlnKCk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgZGlzcG9zYWJsZSB1dGlsaXRpZXNcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZGlzcG9zYWJsZXMgPSBpbmplY3REaXNwb3NhYmxlcygpO1xuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdGhlIHBvcG92ZXIgdGVtcGxhdGUgcmVmLlxuICAgKi9cbiAgcmVhZG9ubHkgcG9wb3ZlciA9IGlucHV0LnJlcXVpcmVkPFRlbXBsYXRlUmVmPHZvaWQ+Pih7XG4gICAgYWxpYXM6ICduZ3BQb3BvdmVyVHJpZ2dlcicsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgb3BlbiBzdGF0ZSBvZiB0aGUgcG9wb3Zlci5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IG9wZW4gPSBtb2RlbDxib29sZWFuPihmYWxzZSwge1xuICAgIGFsaWFzOiAnbmdwUG9wb3ZlclRyaWdnZXJPcGVuJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlZmluZSBpZiB0aGUgdHJpZ2dlciBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBkaXNhYmxlZCA9IGlucHV0PGJvb2xlYW4sIEJvb2xlYW5JbnB1dD4oZmFsc2UsIHtcbiAgICBhbGlhczogJ25ncFBvcG92ZXJUcmlnZ2VyRGlzYWJsZWQnLFxuICAgIHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlZmluZSB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BvdmVyIHJlbGF0aXZlIHRvIHRoZSB0cmlnZ2VyLlxuICAgKiBAZGVmYXVsdCAndG9wJ1xuICAgKi9cbiAgcmVhZG9ubHkgcGxhY2VtZW50ID0gaW5wdXQ8UGxhY2VtZW50Pih0aGlzLmNvbmZpZy5wbGFjZW1lbnQsIHtcbiAgICBhbGlhczogJ25ncFBvcG92ZXJUcmlnZ2VyUGxhY2VtZW50JyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlZmluZSB0aGUgb2Zmc2V0IG9mIHRoZSBwb3BvdmVyIHJlbGF0aXZlIHRvIHRoZSB0cmlnZ2VyLlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICByZWFkb25seSBvZmZzZXQgPSBpbnB1dDxudW1iZXIsIE51bWJlcklucHV0Pih0aGlzLmNvbmZpZy5vZmZzZXQsIHtcbiAgICBhbGlhczogJ25ncFBvcG92ZXJUcmlnZ2VyT2Zmc2V0JyxcbiAgICB0cmFuc2Zvcm06IG51bWJlckF0dHJpYnV0ZSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlZmluZSB0aGUgZGVsYXkgYmVmb3JlIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgcmVhZG9ubHkgc2hvd0RlbGF5ID0gaW5wdXQ8bnVtYmVyLCBOdW1iZXJJbnB1dD4odGhpcy5jb25maWcuc2hvd0RlbGF5LCB7XG4gICAgYWxpYXM6ICduZ3BQb3BvdmVyVHJpZ2dlclNob3dEZWxheScsXG4gICAgdHJhbnNmb3JtOiBudW1iZXJBdHRyaWJ1dGUsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIGRlbGF5IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHJlYWRvbmx5IGhpZGVEZWxheSA9IGlucHV0PG51bWJlciwgTnVtYmVySW5wdXQ+KHRoaXMuY29uZmlnLmhpZGVEZWxheSwge1xuICAgIGFsaWFzOiAnbmdwUG9wb3ZlclRyaWdnZXJIaWRlRGVsYXknLFxuICAgIHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlLFxuICB9KTtcblxuICAvKipcbiAgICogRGVmaW5lIHdoZXRoZXIgdGhlIHBvcG92ZXIgc2hvdWxkIGZsaXAgd2hlbiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGZvciB0aGUgcG9wb3Zlci5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgZmxpcCA9IGlucHV0PGJvb2xlYW4sIEJvb2xlYW5JbnB1dD4odGhpcy5jb25maWcuZmxpcCwge1xuICAgIGFsaWFzOiAnbmdwUG9wb3ZlclRyaWdnZXJGbGlwJyxcbiAgICB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIGNvbnRhaW5lciBpbiB3aGljaCB0aGUgcG9wb3ZlciBzaG91bGQgYmUgYXR0YWNoZWQuXG4gICAqIEBkZWZhdWx0IGRvY3VtZW50LmJvZHlcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lciA9IGlucHV0PEhUTUxFbGVtZW50IHwgbnVsbD4odGhpcy5jb25maWcuY29udGFpbmVyLCB7XG4gICAgYWxpYXM6ICduZ3BQb3BvdmVyVHJpZ2dlckNvbnRhaW5lcicsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgd2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgY2xvc2Ugd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIGl0LlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBjbG9zZU9uT3V0c2lkZUNsaWNrID0gaW5wdXQ8Ym9vbGVhbiwgQm9vbGVhbklucHV0Pih0aGlzLmNvbmZpZy5jbG9zZU9uT3V0c2lkZUNsaWNrLCB7XG4gICAgYWxpYXM6ICduZ3BQb3BvdmVyVHJpZ2dlckNsb3NlT25PdXRzaWRlQ2xpY2snLFxuICAgIHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSBwb3BvdmVyIHZpZXcgcmVmLlxuICAgKi9cbiAgcHJpdmF0ZSB2aWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8dm9pZD4gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogRGVyaXZlIHRoZSBwb3BvdmVyIG1pZGRsZXdhcmUgZnJvbSB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgbWlkZGxld2FyZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCBtaWRkbGV3YXJlOiBNaWRkbGV3YXJlW10gPSBbb2Zmc2V0KHRoaXMub2Zmc2V0KCkpLCBzaGlmdCgpXTtcblxuICAgIGlmICh0aGlzLmZsaXAoKSkge1xuICAgICAgbWlkZGxld2FyZS5wdXNoKGZsaXAoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pZGRsZXdhcmU7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgY29tcHV0ZWQgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVhZG9ubHkgcG9zaXRpb24gPSBzaWduYWw8eyB4OiBudW1iZXI7IHk6IG51bWJlciB9Pih7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICB9KTtcblxuICAvKipcbiAgICogU3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBwb3BvdmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlYWRvbmx5IHN0YXRlID0gc2lnbmFsPFBvcG92ZXJTdGF0ZT4oJ2Nsb3NlZCcpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGlzcG9zZSBmdW5jdGlvbiB0byBzdG9wIGNvbXB1dGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqL1xuICBwcml2YXRlIGRpc3Bvc2U/OiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBIGRvY3VtZW50LXdpZGUgY2xpY2sgbGlzdGVuZXIgdGhhdCBjaGVja3MgaWYgdGhlIGNsaWNrXG4gICAqIG9jY3VycmVkIG91dHNpZGUgb2YgdGhlIHBvcG92ZXIgYW5kIHRyaWdnZXIgZWxlbWVudHMuXG4gICAqL1xuICBwcml2YXRlIGRvY3VtZW50Q2xpY2tMaXN0ZW5lcj86IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBhbnkgdGltZSB0aGUgb3BlbiBzdGF0ZSBjaGFuZ2VzIHRoZW4gc2hvdyBvciBoaWRlIHRoZSBwb3BvdmVyXG4gICAgb25Cb29sZWFuQ2hhbmdlKHRoaXMub3BlbiwgdGhpcy5zaG93LmJpbmQodGhpcyksIHRoaXMuaGlkZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZGVzdHJveVBvcG92ZXIoKTtcbiAgfVxuXG4gIHRvZ2dsZU9wZW5TdGF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLm9wZW4udXBkYXRlKG9wZW4gPT4gIW9wZW4pO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG93KCk6IHZvaWQge1xuICAgIC8vIGlmIHRoZSB0cmlnZ2VyIGlzIGRpc2FibGVkIG9yIHRoZSBwb3BvdmVyIGlzIGFscmVhZHkgb3BlbiB0aGVuIGRvIG5vdCBzaG93IHRoZSBwb3BvdmVyXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQoKSB8fCB0aGlzLnN0YXRlKCkgPT09ICdvcGVuJyB8fCB0aGlzLnN0YXRlKCkgPT09ICdvcGVuaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuc2V0KCdvcGVuaW5nJyk7XG4gICAgdGhpcy5kaXNwb3NhYmxlcy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuY3JlYXRlUG9wb3ZlcigpLCB0aGlzLnNob3dEZWxheSgpKTtcblxuICAgIC8vIEFkZCBkb2N1bWVudCBjbGljayBsaXN0ZW5lciB0byBkZXRlY3Qgb3V0c2lkZSBjbGlja3NcbiAgICBpZiAodGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrKCkpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gdGhpcy5vbkRvY3VtZW50Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoaWRlKCk6IHZvaWQge1xuICAgIC8vIGlmIHRoZSB0cmlnZ2VyIGlzIGRpc2FibGVkIG9yIHRoZSBwb3BvdmVyIGlzIGFscmVhZHkgY2xvc2VkIHRoZW4gZG8gbm90IGhpZGUgdGhlIHBvcG92ZXJcbiAgICBpZiAodGhpcy5kaXNhYmxlZCgpIHx8IHRoaXMuc3RhdGUoKSA9PT0gJ2Nsb3NlZCcgfHwgdGhpcy5zdGF0ZSgpID09PSAnY2xvc2luZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLnNldCgnY2xvc2luZycpO1xuICAgIHRoaXMuZGlzcG9zYWJsZXMuc2V0VGltZW91dCgoKSA9PiB0aGlzLmRlc3Ryb3lQb3BvdmVyKCksIHRoaXMuaGlkZURlbGF5KCkpO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBkb2N1bWVudCBjbGljayBsaXN0ZW5lciB3aGVuIHRoZSBwb3BvdmVyIGlzIGhpZGRlblxuICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uRG9jdW1lbnRDbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBpcyBvdXRzaWRlIHRoZSB0cmlnZ2VyIG9yIHRoZSBwb3BvdmVyXG4gICAgY29uc3QgaXNPdXRzaWRlID1cbiAgICAgICF0aGlzLnRyaWdnZXIubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpICYmXG4gICAgICAhKHRoaXMudmlld1JlZj8ucm9vdE5vZGVzWzBdIGFzIEhUTUxFbGVtZW50KS5jb250YWlucyh0YXJnZXQpO1xuXG4gICAgaWYgKGlzT3V0c2lkZSkge1xuICAgICAgLy8gQ2xvc2UgdGhlIHBvcG92ZXJcbiAgICAgIHRoaXMub3Blbi5zZXQoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICBjb25zdCBwb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwoXG4gICAgICB0aGlzLnBvcG92ZXIoKSxcbiAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZixcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMuaW5qZWN0b3IsXG4gICAgKTtcblxuICAgIGNvbnN0IGRvbU91dGxldCA9IG5ldyBEb21Qb3J0YWxPdXRsZXQoXG4gICAgICB0aGlzLmNvbnRhaW5lcigpID8/IHRoaXMuZG9jdW1lbnQuYm9keSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIEluamVjdG9yLmNyZWF0ZSh7XG4gICAgICAgIHBhcmVudDogdGhpcy5pbmplY3RvcixcbiAgICAgICAgcHJvdmlkZXJzOiBbcHJvdmlkZVBvcG92ZXJUcmlnZ2VyKHRoaXMpXSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICB0aGlzLnZpZXdSZWYgPSBkb21PdXRsZXQuYXR0YWNoKHBvcnRhbCk7XG4gICAgdGhpcy52aWV3UmVmLmRldGVjdENoYW5nZXMoKTtcblxuICAgIGNvbnN0IG91dGxldEVsZW1lbnQgPSB0aGlzLnZpZXdSZWYucm9vdE5vZGVzWzBdO1xuXG4gICAgdGhpcy5kaXNwb3NlID0gYXV0b1VwZGF0ZSh0aGlzLnRyaWdnZXIubmF0aXZlRWxlbWVudCwgb3V0bGV0RWxlbWVudCwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBhd2FpdCBjb21wdXRlUG9zaXRpb24odGhpcy50cmlnZ2VyLm5hdGl2ZUVsZW1lbnQsIG91dGxldEVsZW1lbnQsIHtcbiAgICAgICAgcGxhY2VtZW50OiB0aGlzLnBsYWNlbWVudCgpLFxuICAgICAgICBtaWRkbGV3YXJlOiB0aGlzLm1pZGRsZXdhcmUoKSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnBvc2l0aW9uLnNldCh7IHg6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnkgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0YXRlLnNldCgnb3BlbicpO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXN0cm95UG9wb3ZlcigpOiB2b2lkIHtcbiAgICB0aGlzLnZpZXdSZWY/LmRlc3Ryb3koKTtcbiAgICB0aGlzLnZpZXdSZWYgPSBudWxsO1xuICAgIHRoaXMuZGlzcG9zZT8uKCk7XG4gICAgdGhpcy5zdGF0ZS5zZXQoJ2Nsb3NlZCcpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBvcG92ZXJTdGF0ZSA9ICdjbG9zZWQnIHwgJ29wZW5pbmcnIHwgJ29wZW4nIHwgJ2Nsb3NpbmcnO1xuIl19