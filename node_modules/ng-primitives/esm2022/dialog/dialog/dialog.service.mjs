/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Overlay, OverlayConfig, OverlayContainer } from '@angular/cdk/overlay';
import { ComponentPortal, TemplatePortal } from '@angular/cdk/portal';
import { Injectable, Injector, TemplateRef, inject, isDevMode, } from '@angular/core';
import { uniqueId } from 'ng-primitives/utils';
import { Subject, defer } from 'rxjs';
import { startWith } from 'rxjs/operators';
import { injectDialogConfig } from '../config/dialog.config';
import { NgpDialogRef } from './dialog-ref';
import * as i0 from "@angular/core";
/**
 * This is based on the Angular CDK Dialog service.
 * https://github.com/angular/components/blob/main/src/cdk/dialog/dialog.ts
 */
export class NgpDialogManager {
    constructor() {
        this.overlay = inject(Overlay);
        this.defaultOptions = injectDialogConfig();
        this.parentDialogManager = inject(NgpDialogManager, {
            optional: true,
            skipSelf: true,
        });
        this.overlayContainer = inject(OverlayContainer);
        this.scrollStrategy = this.defaultOptions.scrollStrategy ?? this.overlay.scrollStrategies.block();
        this.openDialogsAtThisLevel = [];
        this.afterAllClosedAtThisLevel = new Subject();
        this.afterOpenedAtThisLevel = new Subject();
        this.ariaHiddenElements = new Map();
        /**
         * Stream that emits when all open dialog have finished closing.
         * Will emit on subscribe if there are no open dialogs to begin with.
         */
        this.afterAllClosed = defer(() => this.openDialogs.length
            ? this.getAfterAllClosed()
            : this.getAfterAllClosed().pipe(startWith(undefined)));
    }
    /** Keeps track of the currently-open dialogs. */
    get openDialogs() {
        return this.parentDialogManager
            ? this.parentDialogManager.openDialogs
            : this.openDialogsAtThisLevel;
    }
    /** Stream that emits when a dialog has been opened. */
    get afterOpened() {
        return this.parentDialogManager
            ? this.parentDialogManager.afterOpened
            : this.afterOpenedAtThisLevel;
    }
    /**
     * Opens a modal dialog containing the given template.
     */
    open(templateRefOrComponentType, config) {
        const defaults = this.defaultOptions;
        config = { ...defaults, ...config };
        config.id = config.id ?? uniqueId('ngp-dialog');
        if (config.id && this.getDialogById(config.id) && isDevMode()) {
            throw Error(`Dialog with id "${config.id}" exists already. The dialog id must be unique.`);
        }
        const overlayConfig = this.getOverlayConfig(config);
        const overlayRef = this.overlay.create(overlayConfig);
        const dialogRef = new NgpDialogRef(overlayRef, config);
        const injector = this.createInjector(config, dialogRef, undefined);
        const context = {
            $implicit: dialogRef,
            close: dialogRef.close.bind(dialogRef),
        };
        if (templateRefOrComponentType instanceof TemplateRef) {
            overlayRef.attach(new TemplatePortal(templateRefOrComponentType, config.viewContainerRef, context, injector));
        }
        else {
            overlayRef.attach(new ComponentPortal(templateRefOrComponentType, config.viewContainerRef, injector));
        }
        // If this is the first dialog that we're opening, hide all the non-overlay content.
        if (!this.openDialogs.length) {
            this.hideNonDialogContentFromAssistiveTechnology();
        }
        this.openDialogs.push(dialogRef);
        dialogRef.closed.subscribe(() => this.removeOpenDialog(dialogRef, true));
        this.afterOpened.next(dialogRef);
        return dialogRef;
    }
    /**
     * Closes all of the currently-open dialogs.
     */
    closeAll() {
        reverseForEach(this.openDialogs, dialog => dialog.close());
    }
    /**
     * Finds an open dialog by its id.
     * @param id ID to use when looking up the dialog.
     */
    getDialogById(id) {
        return this.openDialogs.find(dialog => dialog.id === id);
    }
    ngOnDestroy() {
        // Make one pass over all the dialogs that need to be untracked, but should not be closed. We
        // want to stop tracking the open dialog even if it hasn't been closed, because the tracking
        // determines when `aria-hidden` is removed from elements outside the dialog.
        reverseForEach(this.openDialogsAtThisLevel, dialog => {
            // Check for `false` specifically since we want `undefined` to be interpreted as `true`.
            this.removeOpenDialog(dialog, false);
        });
        // Make a second pass and close the remaining dialogs. We do this second pass in order to
        // correctly dispatch the `afterAllClosed` event in case we have a mixed array of dialogs
        // that should be closed and dialogs that should not.
        reverseForEach(this.openDialogsAtThisLevel, dialog => dialog.close());
        this.afterAllClosedAtThisLevel.complete();
        this.afterOpenedAtThisLevel.complete();
        this.openDialogsAtThisLevel = [];
    }
    /**
     * Creates an overlay config from a dialog config.
     */
    getOverlayConfig(config) {
        const state = new OverlayConfig({
            positionStrategy: this.overlay.position().global().centerHorizontally().centerVertically(),
            scrollStrategy: config.scrollStrategy || this.scrollStrategy,
            hasBackdrop: false,
            disposeOnNavigation: config.closeOnNavigation,
        });
        return state;
    }
    /**
     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
     * of a dialog to close itself and, optionally, to return a value.
     */
    createInjector(config, dialogRef, fallbackInjector) {
        const userInjector = config.injector || config.viewContainerRef?.injector;
        const providers = [{ provide: NgpDialogRef, useValue: dialogRef }];
        return Injector.create({ parent: userInjector || fallbackInjector, providers });
    }
    /**
     * Removes a dialog from the array of open dialogs.
     */
    removeOpenDialog(dialogRef, emitEvent) {
        const index = this.openDialogs.indexOf(dialogRef);
        if (index > -1) {
            this.openDialogs.splice(index, 1);
            // If all the dialogs were closed, remove/restore the `aria-hidden`
            // to a the siblings and emit to the `afterAllClosed` stream.
            if (!this.openDialogs.length) {
                this.ariaHiddenElements.forEach((previousValue, element) => {
                    if (previousValue) {
                        element.setAttribute('aria-hidden', previousValue);
                    }
                    else {
                        element.removeAttribute('aria-hidden');
                    }
                });
                this.ariaHiddenElements.clear();
                if (emitEvent) {
                    this.getAfterAllClosed().next();
                }
            }
        }
    }
    /** Hides all of the content that isn't an overlay from assistive technology. */
    hideNonDialogContentFromAssistiveTechnology() {
        const overlayContainer = this.overlayContainer.getContainerElement();
        // Ensure that the overlay container is attached to the DOM.
        if (overlayContainer.parentElement) {
            const siblings = overlayContainer.parentElement.children;
            for (let i = siblings.length - 1; i > -1; i--) {
                const sibling = siblings[i];
                if (sibling !== overlayContainer &&
                    sibling.nodeName !== 'SCRIPT' &&
                    sibling.nodeName !== 'STYLE' &&
                    !sibling.hasAttribute('aria-live')) {
                    this.ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                    sibling.setAttribute('aria-hidden', 'true');
                }
            }
        }
    }
    getAfterAllClosed() {
        const parent = this.parentDialogManager;
        return parent ? parent.getAfterAllClosed() : this.afterAllClosedAtThisLevel;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDialogManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDialogManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDialogManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
/**
 * Executes a callback against all elements in an array while iterating in reverse.
 * Useful if the array is being modified as it is being iterated.
 */
function reverseForEach(items, callback) {
    let i = items.length;
    while (i--) {
        callback(items[i]);
    }
}
export function injectDialogManager() {
    return inject(NgpDialogManager);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9nLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9uZy1wcmltaXRpdmVzL2RpYWxvZy9zcmMvZGlhbG9nL2RpYWxvZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUNILE9BQU8sRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFrQixNQUFNLHNCQUFzQixDQUFDO0FBQ2hHLE9BQU8sRUFBRSxlQUFlLEVBQWlCLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JGLE9BQU8sRUFDTCxVQUFVLEVBQ1YsUUFBUSxFQUdSLFdBQVcsRUFDWCxNQUFNLEVBQ04sU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvQyxPQUFPLEVBQWMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFtQixrQkFBa0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzlFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxjQUFjLENBQUM7O0FBRTVDOzs7R0FHRztBQUtILE1BQU0sT0FBTyxnQkFBZ0I7SUFIN0I7UUFJbUIsWUFBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMxQixtQkFBYyxHQUFHLGtCQUFrQixFQUFFLENBQUM7UUFDdEMsd0JBQW1CLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixFQUFFO1lBQzlELFFBQVEsRUFBRSxJQUFJO1lBQ2QsUUFBUSxFQUFFLElBQUk7U0FDZixDQUFDLENBQUM7UUFDYyxxQkFBZ0IsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUM1QyxtQkFBYyxHQUM3QixJQUFJLENBQUMsY0FBYyxD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LEtBQUssUUFBUTtvQkFDN0IsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPO29CQUM1QixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEVBQ2xDLENBQUM7b0JBQ0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO29CQUMxRSxPQUFPLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDOUMsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVPLGlCQUFpQjtRQUN2QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7UUFDeEMsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUM7SUFDOUUsQ0FBQzsrR0E3TVUsZ0JBQWdCO21IQUFoQixnQkFBZ0IsY0FGZixNQUFNOzs0RkFFUCxnQkFBZ0I7a0JBSDVCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COztBQWlORDs7O0dBR0c7QUFDSCxTQUFTLGNBQWMsQ0FBSSxLQUF5QixFQUFFLFFBQThCO0lBQ2xGLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFFckIsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ1gsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7QUFDSCxDQUFDO0FBT0QsTUFBTSxVQUFVLG1CQUFtQjtJQUNqQyxPQUFPLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQ2xDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCDCqSAyMDI0IEFuZ3VsYXIgUHJpbWl0aXZlcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZy1wcmltaXRpdmVzL25nLXByaW1pdGl2ZXNcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCB7IE92ZXJsYXksIE92ZXJsYXlDb25maWcsIE92ZXJsYXlDb250YWluZXIsIFNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tcG9uZW50UG9ydGFsLCBDb21wb25lbnRUeXBlLCBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHtcbiAgSW5qZWN0YWJsZSxcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgU3RhdGljUHJvdmlkZXIsXG4gIFRlbXBsYXRlUmVmLFxuICBpbmplY3QsXG4gIGlzRGV2TW9kZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJ25nLXByaW1pdGl2ZXMvdXRpbHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgZGVmZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE5ncERpYWxvZ0NvbmZpZywgaW5qZWN0RGlhbG9nQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2RpYWxvZy5jb25maWcnO1xuaW1wb3J0IHsgTmdwRGlhbG9nUmVmIH0gZnJvbSAnLi9kaWFsb2ctcmVmJztcblxuLyoqXG4gKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBBbmd1bGFyIENESyBEaWFsb2cgc2VydmljZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NvbXBvbmVudHMvYmxvYi9tYWluL3NyYy9jZGsvZGlhbG9nL2RpYWxvZy50c1xuICovXG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBOZ3BEaWFsb2dNYW5hZ2VyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSByZWFkb25seSBvdmVybGF5ID0gaW5qZWN0KE92ZXJsYXkpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRPcHRpb25zID0gaW5qZWN0RGlhbG9nQ29uZmlnKCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgcGFyZW50RGlhbG9nTWFuYWdlciA9IGluamVjdChOZ3BEaWFsb2dNYW5hZ2VyLCB7XG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgc2tpcFNlbGY6IHRydWUsXG4gIH0pO1xuICBwcml2YXRlIHJlYWRvbmx5IG92ZXJsYXlDb250YWluZXIgPSBpbmplY3QoT3ZlcmxheUNvbnRhaW5lcik7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2Nyb2xsU3RyYXRlZ3k6IFNjcm9sbFN0cmF0ZWd5ID1cbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zLnNjcm9sbFN0cmF0ZWd5ID8/IHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmJsb2NrKCk7XG5cbiAgcHJpdmF0ZSBvcGVuRGlhbG9nc0F0VGhpc0xldmVsOiBOZ3BEaWFsb2dSZWZbXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGFmdGVyQWxsQ2xvc2VkQXRUaGlzTGV2ZWwgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IGFmdGVyT3BlbmVkQXRUaGlzTGV2ZWwgPSBuZXcgU3ViamVjdDxOZ3BEaWFsb2dSZWY+KCk7XG4gIHByaXZhdGUgYXJpYUhpZGRlbkVsZW1lbnRzID0gbmV3IE1hcDxFbGVtZW50LCBzdHJpbmcgfCBudWxsPigpO1xuXG4gIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudGx5LW9wZW4gZGlhbG9ncy4gKi9cbiAgZ2V0IG9wZW5EaWFsb2dzKCk6IHJlYWRvbmx5IE5ncERpYWxvZ1JlZltdIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnREaWFsb2dNYW5hZ2VyXG4gICAgICA/IHRoaXMucGFyZW50RGlhbG9nTWFuYWdlci5vcGVuRGlhbG9nc1xuICAgICAgOiB0aGlzLm9wZW5EaWFsb2dzQXRUaGlzTGV2ZWw7XG4gIH1cblxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBhIGRpYWxvZyBoYXMgYmVlbiBvcGVuZWQuICovXG4gIGdldCBhZnRlck9wZW5lZCgpOiBTdWJqZWN0PE5ncERpYWxvZ1JlZj4ge1xuICAgIHJldHVybiB0aGlzLnBhcmVudERpYWxvZ01hbmFnZXJcbiAgICAgID8gdGhpcy5wYXJlbnREaWFsb2dNYW5hZ2VyLmFmdGVyT3BlbmVkXG4gICAgICA6IHRoaXMuYWZ0ZXJPcGVuZWRBdFRoaXNMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIGFsbCBvcGVuIGRpYWxvZyBoYXZlIGZpbmlzaGVkIGNsb3NpbmcuXG4gICAqIFdpbGwgZW1pdCBvbiBzdWJzY3JpYmUgaWYgdGhlcmUgYXJlIG5vIG9wZW4gZGlhbG9ncyB0byBiZWdpbiB3aXRoLlxuICAgKi9cbiAgcmVhZG9ubHkgYWZ0ZXJBbGxDbG9zZWQ6IE9ic2VydmFibGU8dm9pZD4gPSBkZWZlcigoKSA9PlxuICAgIHRoaXMub3BlbkRpYWxvZ3MubGVuZ3RoXG4gICAgICA/IHRoaXMuZ2V0QWZ0ZXJBbGxDbG9zZWQoKVxuICAgICAgOiB0aGlzLmdldEFmdGVyQWxsQ2xvc2VkKCkucGlwZShzdGFydFdpdGgodW5kZWZpbmVkKSksXG4gICk7XG5cbiAgLyoqXG4gICAqIE9wZW5zIGEgbW9kYWwgZGlhbG9nIGNvbnRhaW5pbmcgdGhlIGdpdmVuIHRlbXBsYXRlLlxuICAgKi9cbiAgb3BlbihcbiAgICB0ZW1wbGF0ZVJlZk9yQ29tcG9uZW50VHlwZTogVGVtcGxhdGVSZWY8TmdwRGlhbG9nQ29udGV4dD4gfCBDb21wb25lbnRUeXBlPGFueT4sXG4gICAgY29uZmlnPzogTmdwRGlhbG9nQ29uZmlnLFxuICApOiBOZ3BEaWFsb2dSZWYge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0T3B0aW9ucztcbiAgICBjb25maWcgPSB7IC4uLmRlZmF1bHRzLCAuLi5jb25maWcgfTtcbiAgICBjb25maWcuaWQgPSBjb25maWcuaWQgPz8gdW5pcXVlSWQoJ25ncC1kaWFsb2cnKTtcblxuICAgIGlmIChjb25maWcuaWQgJiYgdGhpcy5nZXREaWFsb2dCeUlkKGNvbmZpZy5pZCkgJiYgaXNEZXZNb2RlKCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBEaWFsb2cgd2l0aCBpZCBcIiR7Y29uZmlnLmlkfVwiIGV4aXN0cyBhbHJlYWR5LiBUaGUgZGlhbG9nIGlkIG11c3QgYmUgdW5pcXVlLmApO1xuICAgIH1cblxuICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLmdldE92ZXJsYXlDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5vdmVybGF5LmNyZWF0ZShvdmVybGF5Q29uZmlnKTtcbiAgICBjb25zdCBkaWFsb2dSZWYgPSBuZXcgTmdwRGlhbG9nUmVmKG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgY29uc3QgaW5qZWN0b3IgPSB0aGlzLmNyZWF0ZUluamVjdG9yKGNvbmZpZywgZGlhbG9nUmVmLCB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGNvbnRleHQ6IE5ncERpYWxvZ0NvbnRleHQgPSB7XG4gICAgICAkaW1wbGljaXQ6IGRpYWxvZ1JlZixcbiAgICAgIGNsb3NlOiBkaWFsb2dSZWYuY2xvc2UuYmluZChkaWFsb2dSZWYpLFxuICAgIH07XG5cbiAgICBpZiAodGVtcGxhdGVSZWZPckNvbXBvbmVudFR5cGUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZikge1xuICAgICAgb3ZlcmxheVJlZi5hdHRhY2goXG4gICAgICAgIG5ldyBUZW1wbGF0ZVBvcnRhbCh0ZW1wbGF0ZVJlZk9yQ29tcG9uZW50VHlwZSwgY29uZmlnLnZpZXdDb250YWluZXJSZWYhLCBjb250ZXh0LCBpbmplY3RvciksXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdmVybGF5UmVmLmF0dGFjaChcbiAgICAgICAgbmV3IENvbXBvbmVudFBvcnRhbCh0ZW1wbGF0ZVJlZk9yQ29tcG9uZW50VHlwZSwgY29uZmlnLnZpZXdDb250YWluZXJSZWYhLCBpbmplY3RvciksXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IGRpYWxvZyB0aGF0IHdlJ3JlIG9wZW5pbmcsIGhpZGUgYWxsIHRoZSBub24tb3ZlcmxheSBjb250ZW50LlxuICAgIGlmICghdGhpcy5vcGVuRGlhbG9ncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaGlkZU5vbkRpYWxvZ0NvbnRlbnRGcm9tQXNzaXN0aXZlVGVjaG5vbG9neSgpO1xuICAgIH1cblxuICAgICh0aGlzLm9wZW5EaWFsb2dzIGFzIE5ncERpYWxvZ1JlZltdKS5wdXNoKGRpYWxvZ1JlZik7XG4gICAgZGlhbG9nUmVmLmNsb3NlZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZW1vdmVPcGVuRGlhbG9nKGRpYWxvZ1JlZiwgdHJ1ZSkpO1xuICAgIHRoaXMuYWZ0ZXJPcGVuZWQubmV4dChkaWFsb2dSZWYpO1xuXG4gICAgcmV0dXJuIGRpYWxvZ1JlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgYWxsIG9mIHRoZSBjdXJyZW50bHktb3BlbiBkaWFsb2dzLlxuICAgKi9cbiAgY2xvc2VBbGwoKTogdm9pZCB7XG4gICAgcmV2ZXJzZUZvckVhY2godGhpcy5vcGVuRGlhbG9ncywgZGlhbG9nID0+IGRpYWxvZy5jbG9zZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBvcGVuIGRpYWxvZyBieSBpdHMgaWQuXG4gICAqIEBwYXJhbSBpZCBJRCB0byB1c2Ugd2hlbiBsb29raW5nIHVwIHRoZSBkaWFsb2cuXG4gICAqL1xuICBnZXREaWFsb2dCeUlkKGlkOiBzdHJpbmcpOiBOZ3BEaWFsb2dSZWYgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm9wZW5EaWFsb2dzLmZpbmQoZGlhbG9nID0+IGRpYWxvZy5pZCA9PT0gaWQpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gTWFrZSBvbmUgcGFzcyBvdmVyIGFsbCB0aGUgZGlhbG9ncyB0aGF0IG5lZWQgdG8gYmUgdW50cmFja2VkLCBidXQgc2hvdWxkIG5vdCBiZSBjbG9zZWQuIFdlXG4gICAgLy8gd2FudCB0byBzdG9wIHRyYWNraW5nIHRoZSBvcGVuIGRpYWxvZyBldmVuIGlmIGl0IGhhc24ndCBiZWVuIGNsb3NlZCwgYmVjYXVzZSB0aGUgdHJhY2tpbmdcbiAgICAvLyBkZXRlcm1pbmVzIHdoZW4gYGFyaWEtaGlkZGVuYCBpcyByZW1vdmVkIGZyb20gZWxlbWVudHMgb3V0c2lkZSB0aGUgZGlhbG9nLlxuICAgIHJldmVyc2VGb3JFYWNoKHRoaXMub3BlbkRpYWxvZ3NBdFRoaXNMZXZlbCwgZGlhbG9nID0+IHtcbiAgICAgIC8vIENoZWNrIGZvciBgZmFsc2VgIHNwZWNpZmljYWxseSBzaW5jZSB3ZSB3YW50IGB1bmRlZmluZWRgIHRvIGJlIGludGVycHJldGVkIGFzIGB0cnVlYC5cbiAgICAgIHRoaXMucmVtb3ZlT3BlbkRpYWxvZyhkaWFsb2csIGZhbHNlKTtcbiAgICB9KTtcblxuICAgIC8vIE1ha2UgYSBzZWNvbmQgcGFzcyBhbmQgY2xvc2UgdGhlIHJlbWFpbmluZyBkaWFsb2dzLiBXZSBkbyB0aGlzIHNlY29uZCBwYXNzIGluIG9yZGVyIHRvXG4gICAgLy8gY29ycmVjdGx5IGRpc3BhdGNoIHRoZSBgYWZ0ZXJBbGxDbG9zZWRgIGV2ZW50IGluIGNhc2Ugd2UgaGF2ZSBhIG1peGVkIGFycmF5IG9mIGRpYWxvZ3NcbiAgICAvLyB0aGF0IHNob3VsZCBiZSBjbG9zZWQgYW5kIGRpYWxvZ3MgdGhhdCBzaG91bGQgbm90LlxuICAgIHJldmVyc2VGb3JFYWNoKHRoaXMub3BlbkRpYWxvZ3NBdFRoaXNMZXZlbCwgZGlhbG9nID0+IGRpYWxvZy5jbG9zZSgpKTtcblxuICAgIHRoaXMuYWZ0ZXJBbGxDbG9zZWRBdFRoaXNMZXZlbC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuYWZ0ZXJPcGVuZWRBdFRoaXNMZXZlbC5jb21wbGV0ZSgpO1xuICAgIHRoaXMub3BlbkRpYWxvZ3NBdFRoaXNMZXZlbCA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb3ZlcmxheSBjb25maWcgZnJvbSBhIGRpYWxvZyBjb25maWcuXG4gICAqL1xuICBwcml2YXRlIGdldE92ZXJsYXlDb25maWcoY29uZmlnOiBOZ3BEaWFsb2dDb25maWcpOiBPdmVybGF5Q29uZmlnIHtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMub3ZlcmxheS5wb3NpdGlvbigpLmdsb2JhbCgpLmNlbnRlckhvcml6b250YWxseSgpLmNlbnRlclZlcnRpY2FsbHkoKSxcbiAgICAgIHNjcm9sbFN0cmF0ZWd5OiBjb25maWcuc2Nyb2xsU3RyYXRlZ3kgfHwgdGhpcy5zY3JvbGxTdHJhdGVneSxcbiAgICAgIGhhc0JhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGRpc3Bvc2VPbk5hdmlnYXRpb246IGNvbmZpZy5jbG9zZU9uTmF2aWdhdGlvbixcbiAgICB9KTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY3VzdG9tIGluamVjdG9yIHRvIGJlIHVzZWQgaW5zaWRlIHRoZSBkaWFsb2cuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IGxvYWRlZCBpbnNpZGVcbiAgICogb2YgYSBkaWFsb2cgdG8gY2xvc2UgaXRzZWxmIGFuZCwgb3B0aW9uYWxseSwgdG8gcmV0dXJuIGEgdmFsdWUuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUluamVjdG9yKFxuICAgIGNvbmZpZzogTmdwRGlhbG9nQ29uZmlnLFxuICAgIGRpYWxvZ1JlZjogTmdwRGlhbG9nUmVmLFxuICAgIGZhbGxiYWNrSW5qZWN0b3I6IEluamVjdG9yIHwgdW5kZWZpbmVkLFxuICApOiBJbmplY3RvciB7XG4gICAgY29uc3QgdXNlckluamVjdG9yID0gY29uZmlnLmluamVjdG9yIHx8IGNvbmZpZy52aWV3Q29udGFpbmVyUmVmPy5pbmplY3RvcjtcbiAgICBjb25zdCBwcm92aWRlcnM6IFN0YXRpY1Byb3ZpZGVyW10gPSBbeyBwcm92aWRlOiBOZ3BEaWFsb2dSZWYsIHVzZVZhbHVlOiBkaWFsb2dSZWYgfV07XG5cbiAgICByZXR1cm4gSW5qZWN0b3IuY3JlYXRlKHsgcGFyZW50OiB1c2VySW5qZWN0b3IgfHwgZmFsbGJhY2tJbmplY3RvciwgcHJvdmlkZXJzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBkaWFsb2cgZnJvbSB0aGUgYXJyYXkgb2Ygb3BlbiBkaWFsb2dzLlxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVPcGVuRGlhbG9nKGRpYWxvZ1JlZjogTmdwRGlhbG9nUmVmLCBlbWl0RXZlbnQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3BlbkRpYWxvZ3MuaW5kZXhPZihkaWFsb2dSZWYpO1xuXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICh0aGlzLm9wZW5EaWFsb2dzIGFzIE5ncERpYWxvZ1JlZltdKS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAvLyBJZiBhbGwgdGhlIGRpYWxvZ3Mgd2VyZSBjbG9zZWQsIHJlbW92ZS9yZXN0b3JlIHRoZSBgYXJpYS1oaWRkZW5gXG4gICAgICAvLyB0byBhIHRoZSBzaWJsaW5ncyBhbmQgZW1pdCB0byB0aGUgYGFmdGVyQWxsQ2xvc2VkYCBzdHJlYW0uXG4gICAgICBpZiAoIXRoaXMub3BlbkRpYWxvZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYXJpYUhpZGRlbkVsZW1lbnRzLmZvckVhY2goKHByZXZpb3VzVmFsdWUsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hcmlhSGlkZGVuRWxlbWVudHMuY2xlYXIoKTtcblxuICAgICAgICBpZiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5nZXRBZnRlckFsbENsb3NlZCgpLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBIaWRlcyBhbGwgb2YgdGhlIGNvbnRlbnQgdGhhdCBpc24ndCBhbiBvdmVybGF5IGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3kuICovXG4gIHByaXZhdGUgaGlkZU5vbkRpYWxvZ0NvbnRlbnRGcm9tQXNzaXN0aXZlVGVjaG5vbG9neSgpIHtcbiAgICBjb25zdCBvdmVybGF5Q29udGFpbmVyID0gdGhpcy5vdmVybGF5Q29udGFpbmVyLmdldENvbnRhaW5lckVsZW1lbnQoKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdmVybGF5IGNvbnRhaW5lciBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICAgIGlmIChvdmVybGF5Q29udGFpbmVyLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gb3ZlcmxheUNvbnRhaW5lci5wYXJlbnRFbGVtZW50LmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKGxldCBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaWJsaW5nICE9PSBvdmVybGF5Q29udGFpbmVyICYmXG4gICAgICAgICAgc2libGluZy5ub2RlTmFtZSAhPT0gJ1NDUklQVCcgJiZcbiAgICAgICAgICBzaWJsaW5nLm5vZGVOYW1lICE9PSAnU1RZTEUnICYmXG4gICAgICAgICAgIXNpYmxpbmcuaGFzQXR0cmlidXRlKCdhcmlhLWxpdmUnKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmFyaWFIaWRkZW5FbGVtZW50cy5zZXQoc2libGluZywgc2libGluZy5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpO1xuICAgICAgICAgIHNpYmxpbmcuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEFmdGVyQWxsQ2xvc2VkKCk6IFN1YmplY3Q8dm9pZD4ge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50RGlhbG9nTWFuYWdlcjtcbiAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50LmdldEFmdGVyQWxsQ2xvc2VkKCkgOiB0aGlzLmFmdGVyQWxsQ2xvc2VkQXRUaGlzTGV2ZWw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGFnYWluc3QgYWxsIGVsZW1lbnRzIGluIGFuIGFycmF5IHdoaWxlIGl0ZXJhdGluZyBpbiByZXZlcnNlLlxuICogVXNlZnVsIGlmIHRoZSBhcnJheSBpcyBiZWluZyBtb2RpZmllZCBhcyBpdCBpcyBiZWluZyBpdGVyYXRlZC5cbiAqL1xuZnVuY3Rpb24gcmV2ZXJzZUZvckVhY2g8VD4oaXRlbXM6IFRbXSB8IHJlYWRvbmx5IFRbXSwgY2FsbGJhY2s6IChjdXJyZW50OiBUKSA9PiB2b2lkKSB7XG4gIGxldCBpID0gaXRlbXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjYWxsYmFjayhpdGVtc1tpXSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBOZ3BEaWFsb2dDb250ZXh0IHtcbiAgJGltcGxpY2l0OiBOZ3BEaWFsb2dSZWY7XG4gIGNsb3NlOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0RGlhbG9nTWFuYWdlcigpOiBOZ3BEaWFsb2dNYW5hZ2VyIHtcbiAgcmV0dXJuIGluamVjdChOZ3BEaWFsb2dNYW5hZ2VyKTtcbn1cbiJdfQ==