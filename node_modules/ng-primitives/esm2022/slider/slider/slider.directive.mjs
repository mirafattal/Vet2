import { Directive, booleanAttribute, computed, contentChild, input, model, numberAttribute, } from '@angular/core';
import { NgpFormControl } from 'ng-primitives/form-field';
import { NgpDisabledToken } from 'ng-primitives/internal';
import { NgpSliderTrackToken } from '../slider-track/slider-track.token';
import { NgpSliderToken } from './slider.token';
import * as i0 from "@angular/core";
import * as i1 from "ng-primitives/form-field";
export class NgpSlider {
    constructor() {
        /**
         * The value of the slider.
         */
        this.value = model(0, {
            alias: 'ngpSliderValue',
        });
        /**
         * The minimum value of the slider.
         */
        this.min = input(0, {
            alias: 'ngpSliderMin',
            transform: numberAttribute,
        });
        /**
         * The maximum value of the slider.
         */
        this.max = input(100, {
            alias: 'ngpSliderMax',
            transform: numberAttribute,
        });
        /**
         * The step value of the slider.
         */
        this.step = input(1, {
            alias: 'ngpSliderStep',
            transform: numberAttribute,
        });
        /**
         * The orientation of the slider.
         */
        this.orientation = input('horizontal', {
            alias: 'ngpSliderOrientation',
        });
        /**
         * The disabled state of the slider.
         */
        this.disabled = input(false, {
            alias: 'ngpSliderDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the slider track.
         */
        this.track = contentChild(NgpSliderTrackToken);
        /**
         * The value as a percentage based on the min and max values.
         */
        this.percentage = computed(() => ((this.value() - this.min()) / (this.max() - this.min())) * 100);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpSlider, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "18.2.13", type: NgpSlider, isStandalone: true, selector: "[ngpSlider]", inputs: { value: { classPropertyName: "value", publicName: "ngpSliderValue", isSignal: true, isRequired: false, transformFunction: null }, min: { classPropertyName: "min", publicName: "ngpSliderMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpSliderMax", isSignal: true, isRequired: false, transformFunction: null }, step: { classPropertyName: "step", publicName: "ngpSliderStep", isSignal: true, isRequired: false, transformFunction: null }, orientation: { classPropertyName: "orientation", publicName: "ngpSliderOrientation", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpSliderDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { value: "ngpSliderValueChange" }, host: { properties: { "attr.data-orientation": "orientation()" } }, providers: [
            { provide: NgpSliderToken, useExisting: NgpSlider },
            { provide: NgpDisabledToken, useExisting: NgpSlider },
        ], queries: [{ propertyName: "track", first: true, predicate: NgpSliderTrackToken, descendants: true, isSignal: true }], exportAs: ["ngpSlider"], hostDirectives: [{ directive: i1.NgpFormControl }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpSlider, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpSlider]',
                    exportAs: 'ngpSlider',
                    providers: [
                        { provide: NgpSliderToken, useExisting: NgpSlider },
                        { provide: NgpDisabledToken, useExisting: NgpSlider },
                    ],
                    hostDirectives: [NgpFormControl],
                    host: {
                        '[attr.data-orientation]': 'orientation()',
                    },
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL25nLXByaW1pdGl2ZXMvc2xpZGVyL3NyYy9zbGlkZXIvc2xpZGVyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxPQUFPLEVBQ0wsU0FBUyxFQUNULGdCQUFnQixFQUNoQixRQUFRLEVBQ1IsWUFBWSxFQUNaLEtBQUssRUFDTCxLQUFLLEVBQ0wsZUFBZSxHQUNoQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFpQixnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBZWhELE1BQU0sT0FBTyxTQUFTO0lBYnRCO1FBY0U7O1dBRUc7UUFDTSxVQUFLLEdBQUcsS0FBSyxDQUFTLENBQUMsRUFBRTtZQUNoQyxLQUFLLEVBQUUsZ0JBQWdCO1NBQ3hCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sUUFBRyxHQUFHLEtBQUssQ0FBc0IsQ0FBQyxFQUFFO1lBQzNDLEtBQUssRUFBRSxjQUFjO1lBQ3JCLFNBQVMsRUFBRSxlQUFlO1NBQzNCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sUUFBRyxHQUFHLEtBQUssQ0FBc0IsR0FBRyxFQUFFO1lBQzdDLEtBQUssRUFBRSxjQUFjO1lBQ3JCLFNBQVMsRUFBRSxlQUFlO1NBQzNCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sU0FBSSxHQUFHLEtBQUssQ0FBc0IsQ0FBQyxFQUFFO1lBQzVDLEtBQUssRUFBRSxlQUFlO1lBQ3RCLFNBQVMsRUFBRSxlQUFlO1NBQzNCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sZ0JBQVcsR0FBRyxLQUFLLENBQTRCLFlBQVksRUFBRTtZQUNwRSxLQUFLLEVBQUUsc0JBQXNCO1NBQzlCLENBQUMsQ0FBQztRQUVIOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBd0IsS0FBSyxFQUFFO1lBQ3RELEtBQUssRUFBRSxtQkFBbUI7WUFDMUIsU0FBUyxFQUFFLGdCQUFnQjtTQUM1QixDQUFDLENBQUM7UUFFSDs7V0FFRztRQUNNLFVBQUssR0FBRyxZQUFZLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUVuRDs7V0FFRztRQUNnQixlQUFVLEdBQUcsUUFBUSxDQUN0QyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUN0RSxDQUFDO0tBQ0g7K0dBMURZLFNBQVM7bUdBQVQsU0FBUyx3OEJBVFQ7WUFDVCxFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRTtZQUNuRCxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFO1NBQ3RELDZEQXdENkIsbUJBQW1COzs0RkFsRHRDLFNBQVM7a0JBYnJCLFNBQVM7bUJBQUM7b0JBQ1QsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSxhQUFhO29CQUN2QixRQUFRLEVBQUUsV0FBVztvQkFDckIsU0FBUyxFQUFFO3dCQUNULEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxXQUFXLFdBQVcsRUFBRTt3QkFDbkQsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxXQUFXLEVBQUU7cUJBQ3REO29CQUNELGNBQWMsRUFBRSxDQUFDLGNBQWMsQ0FBQztvQkFDaEMsSUFBSSxFQUFFO3dCQUNKLHlCQUF5QixFQUFFLGVBQWU7cUJBQzNDO2lCQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgwqkgMjAyNCBBbmd1bGFyIFByaW1pdGl2ZXMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmctcHJpbWl0aXZlcy9uZy1wcmltaXRpdmVzXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgeyBCb29sZWFuSW5wdXQsIE51bWJlcklucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgYm9vbGVhbkF0dHJpYnV0ZSxcbiAgY29tcHV0ZWQsXG4gIGNvbnRlbnRDaGlsZCxcbiAgaW5wdXQsXG4gIG1vZGVsLFxuICBudW1iZXJBdHRyaWJ1dGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdwRm9ybUNvbnRyb2wgfSBmcm9tICduZy1wcmltaXRpdmVzL2Zvcm0tZmllbGQnO1xuaW1wb3J0IHsgTmdwQ2FuRGlzYWJsZSwgTmdwRGlzYWJsZWRUb2tlbiB9IGZyb20gJ25nLXByaW1pdGl2ZXMvaW50ZXJuYWwnO1xuaW1wb3J0IHsgTmdwU2xpZGVyVHJhY2tUb2tlbiB9IGZyb20gJy4uL3NsaWRlci10cmFjay9zbGlkZXItdHJhY2sudG9rZW4nO1xuaW1wb3J0IHsgTmdwU2xpZGVyVG9rZW4gfSBmcm9tICcuL3NsaWRlci50b2tlbic7XG5cbkBEaXJlY3RpdmUoe1xuICBzdGFuZGFsb25lOiB0cnVlLFxuICBzZWxlY3RvcjogJ1tuZ3BTbGlkZXJdJyxcbiAgZXhwb3J0QXM6ICduZ3BTbGlkZXInLFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IE5ncFNsaWRlclRva2VuLCB1c2VFeGlzdGluZzogTmdwU2xpZGVyIH0sXG4gICAgeyBwcm92aWRlOiBOZ3BEaXNhYmxlZFRva2VuLCB1c2VFeGlzdGluZzogTmdwU2xpZGVyIH0sXG4gIF0sXG4gIGhvc3REaXJlY3RpdmVzOiBbTmdwRm9ybUNvbnRyb2xdLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLmRhdGEtb3JpZW50YXRpb25dJzogJ29yaWVudGF0aW9uKCknLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBOZ3BTbGlkZXIgaW1wbGVtZW50cyBOZ3BDYW5EaXNhYmxlIHtcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWUgPSBtb2RlbDxudW1iZXI+KDAsIHtcbiAgICBhbGlhczogJ25ncFNsaWRlclZhbHVlJyxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICByZWFkb25seSBtaW4gPSBpbnB1dDxudW1iZXIsIE51bWJlcklucHV0PigwLCB7XG4gICAgYWxpYXM6ICduZ3BTbGlkZXJNaW4nLFxuICAgIHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlLFxuICB9KTtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIHJlYWRvbmx5IG1heCA9IGlucHV0PG51bWJlciwgTnVtYmVySW5wdXQ+KDEwMCwge1xuICAgIGFsaWFzOiAnbmdwU2xpZGVyTWF4JyxcbiAgICB0cmFuc2Zvcm06IG51bWJlckF0dHJpYnV0ZSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGVwIHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICByZWFkb25seSBzdGVwID0gaW5wdXQ8bnVtYmVyLCBOdW1iZXJJbnB1dD4oMSwge1xuICAgIGFsaWFzOiAnbmdwU2xpZGVyU3RlcCcsXG4gICAgdHJhbnNmb3JtOiBudW1iZXJBdHRyaWJ1dGUsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JpZW50YXRpb24gb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIHJlYWRvbmx5IG9yaWVudGF0aW9uID0gaW5wdXQ8J2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJz4oJ2hvcml6b250YWwnLCB7XG4gICAgYWxpYXM6ICduZ3BTbGlkZXJPcmllbnRhdGlvbicsXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIHJlYWRvbmx5IGRpc2FibGVkID0gaW5wdXQ8Ym9vbGVhbiwgQm9vbGVhbklucHV0PihmYWxzZSwge1xuICAgIGFsaWFzOiAnbmdwU2xpZGVyRGlzYWJsZWQnLFxuICAgIHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgc2xpZGVyIHRyYWNrLlxuICAgKi9cbiAgcmVhZG9ubHkgdHJhY2sgPSBjb250ZW50Q2hpbGQoTmdwU2xpZGVyVHJhY2tUb2tlbik7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBhcyBhIHBlcmNlbnRhZ2UgYmFzZWQgb24gdGhlIG1pbiBhbmQgbWF4IHZhbHVlcy5cbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBwZXJjZW50YWdlID0gY29tcHV0ZWQoXG4gICAgKCkgPT4gKCh0aGlzLnZhbHVlKCkgLSB0aGlzLm1pbigpKSAvICh0aGlzLm1heCgpIC0gdGhpcy5taW4oKSkpICogMTAwLFxuICApO1xufVxuIl19