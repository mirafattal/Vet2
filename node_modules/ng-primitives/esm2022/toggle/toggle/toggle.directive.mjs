import { Directive, ElementRef, HostListener, booleanAttribute, inject, input, model, } from '@angular/core';
import * as i0 from "@angular/core";
export class NgpToggle {
    constructor() {
        /**
         * Access the element.
         */
        this.element = inject(ElementRef);
        /**
         * Whether the toggle is selected.
         * @default false
         */
        this.selected = model(false, { alias: 'ngpToggleSelected' });
        /**
         * Whether the toggle is disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpToggleDisabled',
            transform: booleanAttribute,
        });
        /**
         * Determine if the element is a button.
         */
        this.isButton = this.element.nativeElement.tagName === 'BUTTON';
    }
    /**
     * Toggle the selected state.
     */
    toggle() {
        if (this.disabled()) {
            return;
        }
        this.selected.update(selected => !selected);
    }
    /**
     * If the element is not a button or a link the space key should toggle the selected state.
     */
    onKeyDown(event) {
        if (!this.isButton && this.element.nativeElement.tagName !== 'A') {
            event.preventDefault();
            this.toggle();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpToggle, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpToggle, isStandalone: true, selector: "[ngpToggle]", inputs: { selected: { classPropertyName: "selected", publicName: "ngpToggleSelected", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpToggleDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { selected: "ngpToggleSelectedChange" }, host: { listeners: { "click": "toggle()", "keydown.space": "onKeyDown($event)" }, properties: { "attr.type": "isButton ? \"button\" : null", "attr.aria-pressed": "selected()", "attr.data-selected": "selected() ? \"\" : null", "attr.data-disabled": "disabled() ? \"\" : null" } }, exportAs: ["ngpToggle"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpToggle, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpToggle]',
                    exportAs: 'ngpToggle',
                    standalone: true,
                    host: {
                        '[attr.type]': 'isButton ? "button" : null',
                        '[attr.aria-pressed]': 'selected()',
                        '[attr.data-selected]': 'selected() ? "" : null',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                    },
                }]
        }], propDecorators: { toggle: [{
                type: HostListener,
                args: ['click']
            }], onKeyDown: [{
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL25nLXByaW1pdGl2ZXMvdG9nZ2xlL3NyYy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osZ0JBQWdCLEVBQ2hCLE1BQU0sRUFDTixLQUFLLEVBQ0wsS0FBSyxHQUNOLE1BQU0sZUFBZSxDQUFDOztBQWF2QixNQUFNLE9BQU8sU0FBUztJQVh0QjtRQVlFOztXQUVHO1FBQ2MsWUFBTyxHQUFHLE1BQU0sQ0FBMEIsVUFBVSxDQUFDLENBQUM7UUFFdkU7OztXQUdHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBVSxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO1FBRTFFOzs7V0FHRztRQUNNLGFBQVEsR0FBRyxLQUFLLENBQXdCLEtBQUssRUFBRTtZQUN0RCxLQUFLLEVBQUUsbUJBQW1CO1lBQzFCLFNBQVMsRUFBRSxnQkFBZ0I7U0FDNUIsQ0FBQyxDQUFDO1FBRUg7O1dBRUc7UUFDTyxhQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsT0FBTyxLQUFLLFFBQVEsQ0FBQztLQXdCdEU7SUF0QkM7O09BRUc7SUFFSCxNQUFNO1FBQ0osSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQztZQUNwQixPQUFPO1FBQ1QsQ0FBQztRQUVELElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7O09BRUc7SUFFTyxTQUFTLENBQUMsS0FBb0I7UUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsT0FBTyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQ2pFLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDaEIsQ0FBQztJQUNILENBQUM7K0dBL0NVLFNBQVM7bUdBQVQsU0FBUzs7NEZBQVQsU0FBUztrQkFYckIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsYUFBYTtvQkFDdkIsUUFBUSxFQUFFLFdBQVc7b0JBQ3JCLFVBQVUsRUFBRSxJQUFJO29CQUNoQixJQUFJLEVBQUU7d0JBQ0osYUFBYSxFQUFFLDRCQUE0Qjt3QkFDM0MscUJBQXFCLEVBQUUsWUFBWTt3QkFDbkMsc0JBQXNCLEVBQUUsd0JBQXdCO3dCQUNoRCxzQkFBc0IsRUFBRSx3QkFBd0I7cUJBQ2pEO2lCQUNGOzhCQStCQyxNQUFNO3NCQURMLFlBQVk7dUJBQUMsT0FBTztnQkFhWCxTQUFTO3NCQURsQixZQUFZO3VCQUFDLGVBQWUsRUFBRSxDQUFDLFFBQVEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IMKpIDIwMjQgQW5ndWxhciBQcmltaXRpdmVzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL25nLXByaW1pdGl2ZXMvbmctcHJpbWl0aXZlc1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSAyLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IHsgQm9vbGVhbklucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBib29sZWFuQXR0cmlidXRlLFxuICBpbmplY3QsXG4gIGlucHV0LFxuICBtb2RlbCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuZ3BUb2dnbGVdJyxcbiAgZXhwb3J0QXM6ICduZ3BUb2dnbGUnLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBob3N0OiB7XG4gICAgJ1thdHRyLnR5cGVdJzogJ2lzQnV0dG9uID8gXCJidXR0b25cIiA6IG51bGwnLFxuICAgICdbYXR0ci5hcmlhLXByZXNzZWRdJzogJ3NlbGVjdGVkKCknLFxuICAgICdbYXR0ci5kYXRhLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCgpID8gXCJcIiA6IG51bGwnLFxuICAgICdbYXR0ci5kYXRhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCgpID8gXCJcIiA6IG51bGwnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBOZ3BUb2dnbGUge1xuICAvKipcbiAgICogQWNjZXNzIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBlbGVtZW50ID0gaW5qZWN0PEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+PihFbGVtZW50UmVmKTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgdG9nZ2xlIGlzIHNlbGVjdGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VsZWN0ZWQgPSBtb2RlbDxib29sZWFuPihmYWxzZSwgeyBhbGlhczogJ25ncFRvZ2dsZVNlbGVjdGVkJyB9KTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgdG9nZ2xlIGlzIGRpc2FibGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZGlzYWJsZWQgPSBpbnB1dDxib29sZWFuLCBCb29sZWFuSW5wdXQ+KGZhbHNlLCB7XG4gICAgYWxpYXM6ICduZ3BUb2dnbGVEaXNhYmxlZCcsXG4gICAgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlLFxuICB9KTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIGEgYnV0dG9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGlzQnV0dG9uID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0JVVFRPTic7XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgc2VsZWN0ZWQgc3RhdGUuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZC51cGRhdGUoc2VsZWN0ZWQgPT4gIXNlbGVjdGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgZWxlbWVudCBpcyBub3QgYSBidXR0b24gb3IgYSBsaW5rIHRoZSBzcGFjZSBrZXkgc2hvdWxkIHRvZ2dsZSB0aGUgc2VsZWN0ZWQgc3RhdGUuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdrZXlkb3duLnNwYWNlJywgWyckZXZlbnQnXSlcbiAgcHJvdGVjdGVkIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc0J1dHRvbiAmJiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC50YWdOYW1lICE9PSAnQScpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgIH1cbiAgfVxufVxuIl19