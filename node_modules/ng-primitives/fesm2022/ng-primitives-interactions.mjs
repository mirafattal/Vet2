import * as i0 from '@angular/core';
import { InjectionToken, inject, input, booleanAttribute, output, Directive, signal, HostListener } from '@angular/core';
import { injectDisabled, setupHover, setupFocus, setupFocusVisible, setupPress } from 'ng-primitives/internal';
import { injectDisposables } from 'ng-primitives/utils';

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpHoverToken = new InjectionToken('NgpHoverToken');
/**
 * Inject the Hover directive instance
 * @returns Hover directive instance
 */
function injectHover() {
    return inject(NgpHoverToken);
}

/**
 * A directive for normalizing hover events across the different browsers and devices.
 *
 * This is an Angular port of the useHover hook from
 * react-aria: https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useHover.ts
 */
class NgpHover {
    /**
     * Setup the hover state.
     */
    constructor() {
        /**
         * Whether hoving should be disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpHoverDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the disabled state from any parent.
         */
        this.isDisabled = injectDisabled(this.disabled);
        /**
         * Emit an event when hovering starts.
         */
        this.hoverStart = output({ alias: 'ngpHoverStart' });
        /**
         * Emit an event when hovering ends.
         */
        this.hoverEnd = output({ alias: 'ngpHoverEnd' });
        /**
         * Emit an event when the hover state changes.
         */
        this.hoverChange = output({ alias: 'ngpHover' });
        // setup the hover listener
        setupHover({
            hoverStart: () => {
                this.hoverStart.emit();
                this.hoverChange.emit(true);
            },
            hoverEnd: () => {
                this.hoverEnd.emit();
                this.hoverChange.emit(false);
            },
            disabled: this.isDisabled,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpHover, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpHover, isStandalone: true, selector: "[ngpHover]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpHoverDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { hoverStart: "ngpHoverStart", hoverEnd: "ngpHoverEnd", hoverChange: "ngpHover" }, providers: [{ provide: NgpHoverToken, useExisting: NgpHover }], exportAs: ["ngpHover"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpHover, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpHover]',
                    exportAs: 'ngpHover',
                    providers: [{ provide: NgpHoverToken, useExisting: NgpHover }],
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpFocusToken = new InjectionToken('NgpFocusToken');
/**
 * Inject the Focus directive instance
 */
function injectFocus() {
    return inject(NgpFocusToken);
}

/**
 * This was inspired by the React Aria useFocus hook.
 * https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useFocus.ts#L20
 */
class NgpFocus {
    constructor() {
        /**
         * Whether listening for focus events is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpFocusDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the disabled state from any parent.
         */
        this.isDisabled = injectDisabled(this.disabled);
        /**
         * Emit when the focus state changes.
         */
        this.focus = output({ alias: 'ngpFocus' });
        // setup the focus listener
        setupFocus({
            disabled: this.isDisabled,
            focus: () => this.focus.emit(true),
            blur: () => this.focus.emit(false),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFocus, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpFocus, isStandalone: true, selector: "[ngpFocus]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpFocusDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { focus: "ngpFocus" }, providers: [{ provide: NgpFocusToken, useExisting: NgpFocus }], exportAs: ["ngpFocus"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFocus, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpFocus]',
                    exportAs: 'ngpFocus',
                    providers: [{ provide: NgpFocusToken, useExisting: NgpFocus }],
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpFocusVisibleToken = new InjectionToken('NgpFocusVisibleToken');
/**
 * Inject the FocusVisible directive instance
 */
function injectFocusVisible() {
    return inject(NgpFocusVisibleToken);
}

class NgpFocusVisible {
    constructor() {
        /**
         * Whether focus events are listened to.
         */
        this.disabled = input(false, {
            alias: 'ngpFocusVisibleDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the disabled state from any parent.
         */
        this.isDisabled = injectDisabled(this.disabled);
        /**
         * Emit when the element is visually focused.
         */
        this.focusChange = output({
            alias: 'ngpFocusVisible',
        });
        // setup the focus visible listener
        setupFocusVisible({
            disabled: this.isDisabled,
            focusChange: value => this.focusChange.emit(value),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFocusVisible, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpFocusVisible, isStandalone: true, selector: "[ngpFocusVisible]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpFocusVisibleDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { focusChange: "ngpFocusVisible" }, providers: [{ provide: NgpFocusVisibleToken, useExisting: NgpFocusVisible }], exportAs: ["ngpFocusVisible"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFocusVisible, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpFocusVisible]',
                    exportAs: 'ngpFocusVisible',
                    providers: [{ provide: NgpFocusVisibleToken, useExisting: NgpFocusVisible }],
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpPressToken = new InjectionToken('NgpPressToken');
/**
 * Inject the Press directive instance
 */
function injectPress() {
    return inject(NgpPressToken);
}

/**
 * This was inpsired by Headless UI's active-press hook:
 * https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-react/src/hooks/use-active-press.tsx
 */
class NgpPress {
    constructor() {
        /**
         * Whether listening for press events is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpPressDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the disabled state from any parent.
         */
        this.isDisabled = injectDisabled(this.disabled);
        /**
         * Emit when the press begins.
         */
        this.pressStart = output({
            alias: 'ngpPressStart',
        });
        /**
         * Emit when the press ends.
         */
        this.pressEnd = output({
            alias: 'ngpPressEnd',
        });
        /**
         * Emit when the press changes.
         */
        this.pressChange = output({
            alias: 'ngpPress',
        });
        // setup the press listener
        setupPress({
            pressStart: () => {
                this.pressStart.emit();
                this.pressChange.emit(true);
            },
            pressEnd: () => {
                this.pressEnd.emit();
                this.pressChange.emit(false);
            },
            disabled: this.isDisabled,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPress, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpPress, isStandalone: true, selector: "[ngpPress]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpPressDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { pressStart: "ngpPressStart", pressEnd: "ngpPressEnd", pressChange: "ngpPress" }, providers: [{ provide: NgpPressToken, useExisting: NgpPress }], exportAs: ["ngpPress"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPress, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpPress]',
                    exportAs: 'ngpPress',
                    providers: [{ provide: NgpPressToken, useExisting: NgpPress }],
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpMoveToken = new InjectionToken('NgpMoveToken');
/**
 * Inject the Move directive instance
 */
function injectMove() {
    return inject(NgpMoveToken);
}

/**
 * Inspired by react-aria useMove hook:
 * https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useMove.ts
 */
class NgpMove {
    constructor() {
        /**
         * Access the disposable helper.
         */
        this.disposables = injectDisposables();
        /**
         * Whether movement is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpMoveDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the disabled state from any parent.
         */
        this.isDisabled = injectDisabled(this.disabled);
        /**
         * Emit when the move event begins.
         */
        this.start = output({
            alias: 'ngpMoveStart',
        });
        /**
         * Emit when the element is moved.
         */
        this.move = output({
            alias: 'ngpMove',
        });
        /**
         * Emit when the move event ends.
         */
        this.end = output({
            alias: 'ngpMoveEnd',
        });
        /**
         * Whether the element is currently being moved.
         */
        this.isMoving = signal(false);
        /**
         * Store the last x position of the element.
         */
        this.x = null;
        /**
         * Store the last y position of the element.
         */
        this.y = null;
        /**
         * Store the id of the last pointer.
         */
        this.pointerId = null;
        /**
         * Store the disposable event listeners.
         */
        this.disposableListeners = [];
    }
    /**
     * Handle a move start.
     */
    onMoveStart(event, pointerType) {
        this.start.emit({
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
        this.isMoving.set(true);
    }
    /**
     * Handle a move event.
     */
    onMove(event, pointerType, deltaX, deltaY) {
        if (deltaX === 0 && deltaY === 0) {
            return;
        }
        this.move.emit({
            deltaX,
            deltaY,
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
    }
    /**
     * Handle a move end.
     */
    onMoveEnd(event, pointerType) {
        this.end.emit({
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
        this.isMoving.set(false);
    }
    /**
     * Handle the pointer down event.
     */
    onPointerDown(event) {
        // ignore right-click or additional pointers
        if (event.button !== 0 || this.pointerId !== null || this.isDisabled()) {
            return;
        }
        // prevent the default behavior
        event.preventDefault();
        event.stopPropagation();
        this.onMoveStart(event, event.pointerType);
        // store the pointer id and initial position
        this.pointerId = event.pointerId;
        this.x = event.pageX;
        this.y = event.pageY;
        // add global event listeners
        const pointerMove = this.disposables.addEventListener(window, 'pointermove', this.onPointerMove.bind(this), false);
        const pointerUp = this.disposables.addEventListener(window, 'pointerup', this.onPointerUp.bind(this), false);
        const pointerCancel = this.disposables.addEventListener(window, 'pointercancel', this.onPointerUp.bind(this), false);
        // store the disposable event listeners
        this.disposableListeners = [pointerMove, pointerUp, pointerCancel];
    }
    /**
     * Handle the pointer up event.
     */
    onPointerUp(event) {
        if (this.pointerId !== event.pointerId) {
            return;
        }
        const pointerType = (event.pointerType ?? 'mouse');
        this.onMoveEnd(event, pointerType);
        this.pointerId = null;
        this.disposableListeners.forEach(dispose => dispose());
    }
    /**
     * Handle the pointer move event.
     */
    onPointerMove(event) {
        if (this.pointerId !== event.pointerId) {
            return;
        }
        // Problems with PointerEvent#movementX/movementY:
        // 1. it is always 0 on macOS Safari.
        // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
        this.onMove(event, event.pointerType, event.pageX - (this.x ?? 0), event.pageY - (this.y ?? 0));
        this.x = event.pageX;
        this.y = event.pageY;
    }
    triggerKeyboardMove(event, deltaX, deltaY) {
        if (this.isDisabled()) {
            return;
        }
        this.onMoveStart(event, 'keyboard');
        this.onMove(event, 'keyboard', deltaX, deltaY);
        this.onMoveEnd(event, 'keyboard');
    }
    onArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 0, -1);
    }
    onArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 0, 1);
    }
    onArrowLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, -1, 0);
    }
    onArrowRight(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 1, 0);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpMove, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpMove, isStandalone: true, selector: "[ngpMove]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpMoveDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { start: "ngpMoveStart", move: "ngpMove", end: "ngpMoveEnd" }, host: { listeners: { "pointerdown": "onPointerDown($event)", "keydown.ArrowUp": "onArrowUp($event)", "keydown.ArrowDown": "onArrowDown($event)", "keydown.ArrowLeft": "onArrowLeft($event)", "keydown.ArrowRight": "onArrowRight($event)" }, properties: { "attr.data-move": "isMoving() ? \"\" : null" } }, providers: [{ provide: NgpMoveToken, useExisting: NgpMove }], exportAs: ["ngpMove"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpMove, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpMove]',
                    exportAs: 'ngpMove',
                    providers: [{ provide: NgpMoveToken, useExisting: NgpMove }],
                    host: {
                        '[attr.data-move]': 'isMoving() ? "" : null',
                    },
                }]
        }], propDecorators: { onPointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }], onArrowUp: [{
                type: HostListener,
                args: ['keydown.ArrowUp', ['$event']]
            }], onArrowDown: [{
                type: HostListener,
                args: ['keydown.ArrowDown', ['$event']]
            }], onArrowLeft: [{
                type: HostListener,
                args: ['keydown.ArrowLeft', ['$event']]
            }], onArrowRight: [{
                type: HostListener,
                args: ['keydown.ArrowRight', ['$event']]
            }] } });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpFocus, NgpFocusToken, NgpFocusVisible, NgpFocusVisibleToken, NgpHover, NgpHoverToken, NgpMove, NgpMoveToken, NgpPress, NgpPressToken, injectHover };
//# sourceMappingURL=ng-primitives-interactions.mjs.map
