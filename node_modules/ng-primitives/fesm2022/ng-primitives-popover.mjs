import * as i0 from '@angular/core';
import { InjectionToken, inject, ElementRef, ViewContainerRef, Injector, input, model, booleanAttribute, numberAttribute, computed, signal, Directive, isDevMode } from '@angular/core';
import { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { offset, shift, flip, autoUpdate, computePosition } from '@floating-ui/dom';
import { injectDisposables, onBooleanChange } from 'ng-primitives/utils';
import * as i1 from 'ng-primitives/focus-trap';
import { NgpFocusTrap } from 'ng-primitives/focus-trap';

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const defaultPopoverConfig = {
    offset: 4,
    placement: 'bottom',
    showDelay: 0,
    hideDelay: 0,
    flip: true,
    container: null,
    closeOnOutsideClick: true,
};
const NgpPopoverConfigToken = new InjectionToken('NgpPopoverConfigToken');
/**
 * Provide the default Popover configuration
 * @param config The Popover configuration
 * @returns The provider
 */
function providePopoverConfig(config) {
    return [
        {
            provide: NgpPopoverConfigToken,
            useValue: { ...defaultPopoverConfig, ...config },
        },
    ];
}
/**
 * Inject the Popover configuration
 * @returns The global Popover configuration
 */
function injectPopoverConfig() {
    return inject(NgpPopoverConfigToken, { optional: true }) ?? defaultPopoverConfig;
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpPopoverTriggerToken = new InjectionToken('NgpPopoverTriggerToken');
/**
 * Inject the PopoverTrigger directive instance
 */
function injectPopoverTrigger() {
    return inject(NgpPopoverTriggerToken);
}
/**
 * Provides the PopoverTrigger directive instance
 * @param trigger
 */
function providePopoverTrigger(trigger) {
    return { provide: NgpPopoverTriggerToken, useValue: trigger };
}

class NgpPopoverTrigger {
    constructor() {
        /**
         * Access the trigger element
         */
        this.trigger = inject((ElementRef));
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the document.
         */
        this.document = inject(DOCUMENT);
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the global popover configuration.
         */
        this.config = injectPopoverConfig();
        /**
         * Access the disposable utilities
         */
        this.disposables = injectDisposables();
        /**
         * Access the popover template ref.
         */
        this.popover = input.required({
            alias: 'ngpPopoverTrigger',
        });
        /**
         * The open state of the popover.
         * @default false
         */
        this.open = model(false, {
            alias: 'ngpPopoverTriggerOpen',
        });
        /**
         * Define if the trigger should be disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpPopoverTriggerDisabled',
            transform: booleanAttribute,
        });
        /**
         * Define the placement of the popover relative to the trigger.
         * @default 'top'
         */
        this.placement = input(this.config.placement, {
            alias: 'ngpPopoverTriggerPlacement',
        });
        /**
         * Define the offset of the popover relative to the trigger.
         * @default 0
         */
        this.offset = input(this.config.offset, {
            alias: 'ngpPopoverTriggerOffset',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the popover is displayed.
         * @default 0
         */
        this.showDelay = input(this.config.showDelay, {
            alias: 'ngpPopoverTriggerShowDelay',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the popover is hidden.
         * @default 0
         */
        this.hideDelay = input(this.config.hideDelay, {
            alias: 'ngpPopoverTriggerHideDelay',
            transform: numberAttribute,
        });
        /**
         * Define whether the popover should flip when there is not enough space for the popover.
         * @default true
         */
        this.flip = input(this.config.flip, {
            alias: 'ngpPopoverTriggerFlip',
            transform: booleanAttribute,
        });
        /**
         * Define the container in which the popover should be attached.
         * @default document.body
         */
        this.container = input(this.config.container, {
            alias: 'ngpPopoverTriggerContainer',
        });
        /**
         * Define whether the popover should close when clicking outside of it.
         * @default true
         */
        this.closeOnOutsideClick = input(this.config.closeOnOutsideClick, {
            alias: 'ngpPopoverTriggerCloseOnOutsideClick',
            transform: booleanAttribute,
        });
        /**
         * Store the popover view ref.
         */
        this.viewRef = null;
        /**
         * Derive the popover middleware from the provided configuration.
         */
        this.middleware = computed(() => {
            const middleware = [offset(this.offset()), shift()];
            if (this.flip()) {
                middleware.push(flip());
            }
            return middleware;
        });
        /**
         * Store the computed position of the popover.
         * @internal
         */
        this.position = signal({
            x: 0,
            y: 0,
        });
        /**
         * Store the state of the popover.
         * @internal
         */
        this.state = signal('closed');
        // any time the open state changes then show or hide the popover
        onBooleanChange(this.open, this.show.bind(this), this.hide.bind(this));
    }
    ngOnDestroy() {
        this.destroyPopover();
    }
    toggleOpenState() {
        this.open.update(open => !open);
    }
    show() {
        // if the trigger is disabled or the popover is already open then do not show the popover
        if (this.disabled() || this.state() === 'open' || this.state() === 'opening') {
            return;
        }
        this.state.set('opening');
        this.disposables.setTimeout(() => this.createPopover(), this.showDelay());
        // Add document click listener to detect outside clicks
        if (this.closeOnOutsideClick()) {
            this.documentClickListener = this.onDocumentClick.bind(this);
            this.document.addEventListener('click', this.documentClickListener, true);
        }
    }
    hide() {
        // if the trigger is disabled or the popover is already closed then do not hide the popover
        if (this.disabled() || this.state() === 'closed' || this.state() === 'closing') {
            return;
        }
        this.state.set('closing');
        this.disposables.setTimeout(() => this.destroyPopover(), this.hideDelay());
        // Remove the document click listener when the popover is hidden
        if (this.documentClickListener) {
            this.document.removeEventListener('click', this.documentClickListener, true);
        }
    }
    onDocumentClick(event) {
        const target = event.target;
        // Check if the click is outside the trigger or the popover
        const isOutside = !this.trigger.nativeElement.contains(target) &&
            !(this.viewRef?.rootNodes[0]).contains(target);
        if (isOutside) {
            // Close the popover
            this.open.set(false);
        }
    }
    createPopover() {
        const portal = new TemplatePortal(this.popover(), this.viewContainerRef, undefined, this.injector);
        const domOutlet = new DomPortalOutlet(this.container() ?? this.document.body, undefined, undefined, Injector.create({
            parent: this.injector,
            providers: [providePopoverTrigger(this)],
        }));
        this.viewRef = domOutlet.attach(portal);
        this.viewRef.detectChanges();
        const outletElement = this.viewRef.rootNodes[0];
        this.dispose = autoUpdate(this.trigger.nativeElement, outletElement, async () => {
            const position = await computePosition(this.trigger.nativeElement, outletElement, {
                placement: this.placement(),
                middleware: this.middleware(),
            });
            this.position.set({ x: position.x, y: position.y });
        });
        this.state.set('open');
    }
    destroyPopover() {
        this.viewRef?.destroy();
        this.viewRef = null;
        this.dispose?.();
        this.state.set('closed');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPopoverTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpPopoverTrigger, isStandalone: true, selector: "[ngpPopoverTrigger]", inputs: { popover: { classPropertyName: "popover", publicName: "ngpPopoverTrigger", isSignal: true, isRequired: true, transformFunction: null }, open: { classPropertyName: "open", publicName: "ngpPopoverTriggerOpen", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpPopoverTriggerDisabled", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpPopoverTriggerPlacement", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "ngpPopoverTriggerOffset", isSignal: true, isRequired: false, transformFunction: null }, showDelay: { classPropertyName: "showDelay", publicName: "ngpPopoverTriggerShowDelay", isSignal: true, isRequired: false, transformFunction: null }, hideDelay: { classPropertyName: "hideDelay", publicName: "ngpPopoverTriggerHideDelay", isSignal: true, isRequired: false, transformFunction: null }, flip: { classPropertyName: "flip", publicName: "ngpPopoverTriggerFlip", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "ngpPopoverTriggerContainer", isSignal: true, isRequired: false, transformFunction: null }, closeOnOutsideClick: { classPropertyName: "closeOnOutsideClick", publicName: "ngpPopoverTriggerCloseOnOutsideClick", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { open: "ngpPopoverTriggerOpenChange" }, host: { listeners: { "click": "toggleOpenState()" }, properties: { "attr.data-state": "state()", "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [{ provide: NgpPopoverTriggerToken, useExisting: NgpPopoverTrigger }], exportAs: ["ngpPopoverTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPopoverTrigger, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpPopoverTrigger]',
                    exportAs: 'ngpPopoverTrigger',
                    providers: [{ provide: NgpPopoverTriggerToken, useExisting: NgpPopoverTrigger }],
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                        '(click)': 'toggleOpenState()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpPopoverToken = new InjectionToken('NgpPopoverToken');
/**
 * Inject the Popover directive instance
 */
function injectPopover() {
    return inject(NgpPopoverToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpPopover {
    constructor() {
        /**
         * Access the popover element.
         */
        this.popover = inject((ElementRef));
        /**
         * Access the trigger instance.
         */
        this.trigger = injectPopoverTrigger();
        /**
         * Compute the x position of the popover.
         */
        this.x = computed(() => this.trigger.position().x);
        /**
         * Compute the y position of the popover.
         */
        this.y = computed(() => this.trigger.position().y);
    }
    ngOnInit() {
        // if the element does not have a fixed position then throw a warning in dev mode
        if (isDevMode()) {
            const { position } = getComputedStyle(this.popover.nativeElement);
            if (position !== 'absolute') {
                console.warn(`The popover element must have an absolute position. The current position is ${position}.`);
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPopover, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpPopover, isStandalone: true, selector: "[ngpPopover]", host: { attributes: { "role": "menu" }, properties: { "style.left.px": "x()", "style.top.px": "y()" } }, providers: [{ provide: NgpPopoverToken, useExisting: NgpPopover }], exportAs: ["ngpPopover"], hostDirectives: [{ directive: i1.NgpFocusTrap }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpPopover, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpPopover]',
                    exportAs: 'ngpPopover',
                    hostDirectives: [NgpFocusTrap],
                    providers: [{ provide: NgpPopoverToken, useExisting: NgpPopover }],
                    host: {
                        role: 'menu',
                        '[style.left.px]': 'x()',
                        '[style.top.px]': 'y()',
                    },
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpPopover, NgpPopoverToken, NgpPopoverTrigger, NgpPopoverTriggerToken, providePopoverConfig };
//# sourceMappingURL=ng-primitives-popover.mjs.map
