import * as i0 from '@angular/core';
import { inject, DestroyRef, Injectable, signal, effect, Renderer2, ElementRef, afterNextRender, AfterRenderPhase } from '@angular/core';
import { coerceElement } from '@angular/cdk/coercion';

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Disposable functions are a way to manage timers, intervals, and event listeners
 * that should be cleared when a component is destroyed.
 *
 * This is heavily inspired by Headless UI disposables:
 * https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-react/src/utils/disposables.ts
 */
function injectDisposables() {
    const destroyRef = inject(DestroyRef);
    return {
        /**
         * Set a timeout that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @param delay The delay before the callback is executed
         * @returns A function to clear the timeout
         */
        setTimeout: (callback, delay) => {
            const id = setTimeout(callback, delay);
            const cleanup = () => clearTimeout(id);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
        /**
         * Set an interval that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @param delay The delay before the callback is executed
         * @param target
         * @param type
         * @param listener
         * @param options
         * @returns A function to clear the interval
         */
        addEventListener: (target, type, listener, options) => {
            target.addEventListener(type, listener, options);
            const cleanup = () => target.removeEventListener(type, listener, options);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
        /**
         * Set an interval that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @param delay The delay before the callback is executed
         * @returns A function to clear the interval
         */
        setInterval: (callback, delay) => {
            const id = setInterval(callback, delay);
            const cleanup = () => clearInterval(id);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
        /**
         * Set a requestAnimationFrame that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @returns A function to clear the requestAnimationFrame
         */
        requestAnimationFrame: (callback) => {
            const id = requestAnimationFrame(callback);
            const cleanup = () => cancelAnimationFrame(id);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
    };
}

class FocusManager {
    focus(element, origin = 'program') {
        element = coerceElement(element);
        switch (origin) {
            case 'keyboard':
                // trigger the focus-visible state for keyboard users
                element.contentEditable = 'true';
                element.focus({ preventScroll: true });
                element.contentEditable = 'false';
                break;
            default:
                element.focus();
                break;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FocusManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FocusManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FocusManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Store a map of unique ids for elements so that there are no collisions.
 */
const uniqueIdMap = new Map();
/**
 * Generate a unique id for an element
 * @param prefix - The prefix to use for the id
 * @returns The generated id
 */
function uniqueId(prefix) {
    const id = uniqueIdMap.get(prefix) ?? 0;
    uniqueIdMap.set(prefix, id + 1);
    return `${prefix}-${id}`;
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Listen for changes to a signal and call a function when the signal changes.
 * @param source
 * @param fn
 * @param options
 * @param options.injector
 * @internal
 */
function onChange(source, fn, options) {
    const previousValue = signal(source());
    effect(() => {
        const value = source();
        if (value !== previousValue()) {
            fn(value, previousValue());
            previousValue.set(value);
        }
    }, { allowSignalWrites: true, injector: options?.injector });
    // call the fn with the initial value
    fn(source(), null);
}
/**
 * Listen for changes to a boolean signal and call one of two functions when the signal changes.
 * @param source
 * @param onTrue
 * @param onFalse
 * @param options
 */
function onBooleanChange(source, onTrue, onFalse, options) {
    onChange(source, value => (value ? onTrue?.() : onFalse?.()), options);
}
/**
 * A utility to sync the value of a signal with the Angular Forms onChange callback.
 * @param source The signal to sync with the onChange callback.
 * @param fn The onChange callback.
 * @param options The options for the effect.
 */
function onFormControlChange(source, fn, options) {
    const previousValue = signal(source());
    effect(() => {
        const value = source();
        if (value !== previousValue() && value !== undefined && value !== null) {
            fn?.(value);
            previousValue.set(value);
        }
    }, { allowSignalWrites: true, injector: options?.injector });
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Injects the dimensions of the element
 * @returns The dimensions of the element
 */
function injectDimensions() {
    const renderer = inject(Renderer2);
    const element = inject(ElementRef);
    const size = signal({
        width: 0,
        height: 0,
        mounted: false,
    });
    let transitionDuration, animationName;
    afterNextRender(() => {
        transitionDuration = element.nativeElement.style.transitionDuration;
        animationName = element.nativeElement.style.animationName;
    }, { phase: AfterRenderPhase.EarlyRead });
    afterNextRender(() => {
        // block any animations/transitions so the element renders at its full dimensions
        renderer.setStyle(element.nativeElement, 'transitionDuration', '0s');
        renderer.setStyle(element.nativeElement, 'animationName', 'none');
    }, { phase: AfterRenderPhase.Write });
    afterNextRender(() => {
        const { width, height } = element.nativeElement.getBoundingClientRect();
        size.set({ width, height, mounted: true });
        // restore the original transition duration and animation name
        renderer.setStyle(element.nativeElement, 'transitionDuration', transitionDuration);
        renderer.setStyle(element.nativeElement, 'animationName', animationName);
    }, { phase: AfterRenderPhase.Read });
    return size;
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FocusManager, injectDimensions, injectDisposables, onBooleanChange, onChange, onFormControlChange, uniqueId };
//# sourceMappingURL=ng-primitives-utils.mjs.map
