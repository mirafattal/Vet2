import * as i0 from '@angular/core';
import { InjectionToken, inject, TemplateRef, ViewContainerRef, Injector, Directive, ElementRef, computed, HostListener, input, booleanAttribute, model, contentChild, contentChildren, afterNextRender } from '@angular/core';
import { FocusMonitor } from '@angular/cdk/a11y';
import * as i1 from 'ng-primitives/button';
import { NgpButton } from 'ng-primitives/button';
import { injectDateAdapter } from 'ng-primitives/date-time';
import { NgpDisabledToken } from 'ng-primitives/internal';
import { uniqueId, onChange } from 'ng-primitives/utils';

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerRowRenderToken = new InjectionToken('NgpDatePickerRowRenderToken');
/**
 * Inject the DatePickerRowRender directive instance
 */
function injectDatePickerRowRender() {
    return inject(NgpDatePickerRowRenderToken);
}
const NgpDatePickerWeekToken = new InjectionToken('NgpDatePickerWeekToken');
/**
 * Inject current week days
 */
function injectDatePickerWeek() {
    return inject(NgpDatePickerWeekToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerCellRenderToken = new InjectionToken('NgpDatePickerCellRenderToken');
/**
 * Inject the DatePickerCell directive instance
 */
function injectDatePickerCellRender() {
    return inject(NgpDatePickerCellRenderToken);
}
const NgpDatePickerCellDateToken = new InjectionToken('NgpDatePickerCellDateToken');
/**
 * Inject current cell date
 */
function injectDatePickerCellDate() {
    return inject(NgpDatePickerCellDateToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerCellRender {
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(_, context) {
        return true;
    }
    constructor() {
        /**
         * Access the template ref for the cell.
         */
        this.templateRef = inject(TemplateRef);
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the dates in the week.
         */
        this.dates = injectDatePickerWeek();
        /**
         * Store the view refs for the dates.
         */
        this.viewRefs = [];
        this.renderDates();
    }
    /**
     * Render the dates in the week.
     */
    renderDates() {
        this.viewRefs.forEach(viewRef => viewRef.destroy());
        for (const date of this.dates) {
            const viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, {
                $implicit: date,
            }, {
                injector: Injector.create({
                    parent: this.viewContainerRef.injector,
                    providers: [{ provide: NgpDatePickerCellDateToken, useValue: date }],
                }),
            });
            this.viewRefs.push(viewRef);
        }
    }
    /**
     * Destroy the view refs.
     */
    ngOnDestroy() {
        this.viewRefs.forEach(viewRef => viewRef.destroy());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerCellRender, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpDatePickerCellRender, isStandalone: true, selector: "[ngpDatePickerCellRender]", providers: [{ provide: NgpDatePickerCellRenderToken, useExisting: NgpDatePickerCellRender }], exportAs: ["ngpDatePickerCellRender"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerCellRender, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerCellRender]',
                    exportAs: 'ngpDatePickerCellRender',
                    providers: [{ provide: NgpDatePickerCellRenderToken, useExisting: NgpDatePickerCellRender }],
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerToken = new InjectionToken('NgpDatePickerToken');
/**
 * Inject the DatePicker directive instance
 */
function injectDatePicker() {
    return inject(NgpDatePickerToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerDateButtonToken = new InjectionToken('NgpDatePickerDateButtonToken');
/**
 * Inject the DatePickerDateButton directive instance
 */
function injectDatePickerDateButton() {
    return inject(NgpDatePickerDateButtonToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerDateButton {
    constructor() {
        /**
         * Access the element ref.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access the focus monitor.
         */
        this.focusMonitor = inject(FocusMonitor);
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * The date this cell represents.
         */
        this.date = injectDatePickerCellDate();
        /**
         * Determine if this is the focused date.
         */
        this.focused = computed(() => this.dateAdapter.isSameDay(this.date, this.datePicker.focusedDate()));
        /**
         * Determine if this is the selected date.
         * @internal
         */
        this.selected = computed(() => {
            const selected = this.datePicker.date();
            return selected && this.dateAdapter.isSameDay(this.date, selected);
        });
        /**
         * Determine if this date is outside the current month.
         */
        this.outside = computed(() => !this.dateAdapter.isSameMonth(this.date, this.datePicker.focusedDate()));
        /**
         * Determine if this date is today.
         */
        this.today = computed(() => this.dateAdapter.isSameDay(this.date, this.dateAdapter.now()));
        /**
         * Determine if this date is disabled.
         * @internal
         */
        this.disabled = computed(() => {
            const min = this.datePicker.min();
            const max = this.datePicker.max();
            if (this.datePicker.disabled() || this.datePicker.dateDisabled()(this.date)) {
                return true;
            }
            if (min && this.dateAdapter.compare(this.dateAdapter.startOfDay(this.date), min) < 0) {
                return true;
            }
            if (max && this.dateAdapter.compare(this.dateAdapter.startOfDay(this.date), max) > 0) {
                return true;
            }
            return false;
        });
        /**
         * Determine if the element is a button.
         */
        this.isButton = this.elementRef.nativeElement.tagName === 'BUTTON';
    }
    /**
     * When the button is clicked, select the date.
     */
    select(event) {
        // if the button is disabled, or is already selected, do nothing.
        if (this.disabled() || this.selected()) {
            return;
        }
        // because this may not be a button, we should stop the event from firing twice due to
        // us listening to both the click and the keydown.enter event.
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.datePicker.date.set(this.date);
        this.datePicker.setFocusedDate(this.date, 'mouse', 'forward');
    }
    /**
     * Focus if this is the current focused date.
     * @internal
     */
    focus() {
        if (this.dateAdapter.isSameDay(this.date, this.datePicker.focusedDate())) {
            this.focusMonitor.focusVia(this.elementRef, 'keyboard');
        }
    }
    /**
     * Focus the previous cell.
     */
    focusPrevious(event) {
        event.preventDefault();
        event.stopPropagation();
        // in rtl, the arrow keys are reversed.
        if (this.getDirection() === 'rtl') {
            this.focusDate(this.dateAdapter.add(this.datePicker.focusedDate(), { days: 1 }), 'forward');
        }
        else {
            this.focusDate(this.dateAdapter.subtract(this.datePicker.focusedDate(), { days: 1 }), 'backward');
        }
    }
    /**
     * Focus the next cell.
     */
    focusNext(event) {
        event.preventDefault();
        event.stopPropagation();
        // in rtl, the arrow keys are reversed.
        if (this.getDirection() === 'rtl') {
            this.focusDate(this.dateAdapter.subtract(this.datePicker.focusedDate(), { days: 1 }), 'backward');
        }
        else {
            this.focusDate(this.dateAdapter.add(this.datePicker.focusedDate(), { days: 1 }), 'forward');
        }
    }
    /**
     * Focus the above cell.
     */
    focusAbove(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.subtract(this.datePicker.focusedDate(), { days: 7 }), 'backward');
    }
    /**
     * Focus the below cell.
     */
    focusBelow(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.add(this.datePicker.focusedDate(), { days: 7 }), 'forward');
    }
    /**
     * Focus the first date of the month.
     */
    focusFirst(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.startOfMonth(this.datePicker.focusedDate()), 'forward');
    }
    /**
     * Focus the last date of the month.
     */
    focusLast(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.endOfMonth(this.datePicker.focusedDate()), 'backward');
    }
    /**
     * Focus the same date in the previous month.
     */
    focusPreviousMonth(event) {
        event.preventDefault();
        event.stopPropagation();
        const date = this.dateAdapter.getDate(this.datePicker.focusedDate());
        let previousMonthTarget = this.dateAdapter.startOfMonth(this.datePicker.focusedDate());
        previousMonthTarget = this.dateAdapter.subtract(previousMonthTarget, { months: 1 });
        const lastDay = this.dateAdapter.endOfMonth(previousMonthTarget);
        // if we are on a date that does not exist in the previous month, we should focus the last day of the month.
        if (date > this.dateAdapter.getDate(lastDay)) {
            this.focusDate(lastDay, 'forward');
            return;
        }
        else {
            this.focusDate(this.dateAdapter.set(previousMonthTarget, { day: date }), 'forward');
        }
    }
    /**
     * Focus the same date in the next month.
     */
    focusNextMonth(event) {
        event.preventDefault();
        event.stopPropagation();
        const date = this.dateAdapter.getDate(this.datePicker.focusedDate());
        let nextMonthTarget = this.dateAdapter.startOfMonth(this.datePicker.focusedDate());
        nextMonthTarget = this.dateAdapter.add(nextMonthTarget, { months: 1 });
        const lastDay = this.dateAdapter.endOfMonth(nextMonthTarget);
        // if we are on a date that does not exist in the next month, we should focus the last day of the month.
        if (date > this.dateAdapter.getDate(lastDay)) {
            this.focusDate(lastDay, 'backward');
            return;
        }
        else {
            this.focusDate(this.dateAdapter.set(nextMonthTarget, { day: date }), 'backward');
        }
    }
    focusDate(date, direction) {
        this.datePicker.setFocusedDate(date, 'keyboard', direction);
    }
    /**
     * Get the direction of the element.
     */
    getDirection() {
        return getComputedStyle(this.elementRef.nativeElement).direction === 'rtl' ? 'rtl' : 'ltr';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerDateButton, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpDatePickerDateButton, isStandalone: true, selector: "[ngpDatePickerDateButton]", host: { listeners: { "click": "select()", "keydown.enter": "select($event)", "keydown.space": "select($event)", "keydown.arrowLeft": "focusPrevious($event)", "keydown.arrowRight": "focusNext($event)", "keydown.arrowUp": "focusAbove($event)", "keydown.arrowDown": "focusBelow($event)", "keydown.home": "focusFirst($event)", "keydown.end": "focusLast($event)", "keydown.pageUp": "focusPreviousMonth($event)", "keydown.pageDown": "focusNextMonth($event)" }, properties: { "attr.role": "!isButton ? \"button\" : null", "attr.tabindex": "focused() ? 0 : -1", "attr.data-selected": "selected() ? \"\" : null", "attr.data-disabled": "disabled() ? \"\" : null", "attr.aria-disabled": "disabled()", "attr.data-outside-month": "outside() ? \"\" : null", "attr.data-today": "today() ? \"\" : null" } }, providers: [
            { provide: NgpDatePickerDateButtonToken, useExisting: NgpDatePickerDateButton },
            { provide: NgpDisabledToken, useExisting: NgpDatePickerDateButton },
        ], exportAs: ["ngpDatePickerDateButton"], hostDirectives: [{ directive: i1.NgpButton }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerDateButton, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerDateButton]',
                    exportAs: 'ngpDatePickerDateButton',
                    providers: [
                        { provide: NgpDatePickerDateButtonToken, useExisting: NgpDatePickerDateButton },
                        { provide: NgpDisabledToken, useExisting: NgpDatePickerDateButton },
                    ],
                    host: {
                        '[attr.role]': '!isButton ? "button" : null',
                        '[attr.tabindex]': 'focused() ? 0 : -1',
                        '[attr.data-selected]': 'selected() ? "" : null',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                        '[attr.aria-disabled]': 'disabled()',
                        '[attr.data-outside-month]': 'outside() ? "" : null',
                        '[attr.data-today]': 'today() ? "" : null',
                    },
                    hostDirectives: [NgpButton],
                }]
        }], propDecorators: { select: [{
                type: HostListener,
                args: ['click']
            }, {
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }], focusPrevious: [{
                type: HostListener,
                args: ['keydown.arrowLeft', ['$event']]
            }], focusNext: [{
                type: HostListener,
                args: ['keydown.arrowRight', ['$event']]
            }], focusAbove: [{
                type: HostListener,
                args: ['keydown.arrowUp', ['$event']]
            }], focusBelow: [{
                type: HostListener,
                args: ['keydown.arrowDown', ['$event']]
            }], focusFirst: [{
                type: HostListener,
                args: ['keydown.home', ['$event']]
            }], focusLast: [{
                type: HostListener,
                args: ['keydown.end', ['$event']]
            }], focusPreviousMonth: [{
                type: HostListener,
                args: ['keydown.pageUp', ['$event']]
            }], focusNextMonth: [{
                type: HostListener,
                args: ['keydown.pageDown', ['$event']]
            }] } });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerGridToken = new InjectionToken('NgpDatePickerGridToken');
/**
 * Inject the DatePickerGrid directive instance
 */
function injectDatePickerGrid() {
    return inject(NgpDatePickerGridToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerGrid {
    constructor() {
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Determine the id for the label.
         */
        this.labelId = computed(() => this.datePicker.label()?.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerGrid, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpDatePickerGrid, isStandalone: true, selector: "[ngpDatePickerGrid]", host: { attributes: { "role": "grid" }, properties: { "attr.aria-labelledby": "labelId()", "attr.data-disabled": "datePicker.disabled() ? \"\" : null" } }, providers: [{ provide: NgpDatePickerGridToken, useExisting: NgpDatePickerGrid }], exportAs: ["ngpDatePickerGrid"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerGrid, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerGrid]',
                    exportAs: 'ngpDatePickerGrid',
                    providers: [{ provide: NgpDatePickerGridToken, useExisting: NgpDatePickerGrid }],
                    host: {
                        role: 'grid',
                        '[attr.aria-labelledby]': 'labelId()',
                        '[attr.data-disabled]': 'datePicker.disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerLabelToken = new InjectionToken('NgpDatePickerLabelToken');
/**
 * Inject the DatePickerLabel directive instance
 */
function injectDatePickerLabel() {
    return inject(NgpDatePickerLabelToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerLabel {
    constructor() {
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Define a unique id for the label.
         */
        this.id = input(uniqueId('ngp-date-picker-label'));
        /**
         * Define the aria live attribute.
         */
        this.ariaLive = input('polite', {
            alias: 'aria-live',
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerLabel, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpDatePickerLabel, isStandalone: true, selector: "[ngpDatePickerLabel]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, ariaLive: { classPropertyName: "ariaLive", publicName: "aria-live", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "id": "id()", "attr.aria-live": "ariaLive()", "attr.data-disabled": "datePicker.disabled() ? \"\" : null" } }, providers: [{ provide: NgpDatePickerLabelToken, useExisting: NgpDatePickerLabel }], exportAs: ["ngpDatePickerLabel"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerLabel, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerLabel]',
                    exportAs: 'ngpDatePickerLabel',
                    providers: [{ provide: NgpDatePickerLabelToken, useExisting: NgpDatePickerLabel }],
                    host: {
                        '[id]': 'id()',
                        '[attr.aria-live]': 'ariaLive()',
                        '[attr.data-disabled]': 'datePicker.disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerNextMonthToken = new InjectionToken('NgpDatePickerNextMonthToken');
/**
 * Inject the DatePickerNextMonth directive instance
 */
function injectDatePickerNextMonth() {
    return inject(NgpDatePickerNextMonthToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerNextMonth {
    constructor() {
        /**
         * Access the element ref.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Determine if this is a button element
         */
        this.isButton = this.elementRef.nativeElement.tagName.toLowerCase() === 'button';
        /**
         * Determine if the next month is disabled.
         * @internal
         */
        this.disabled = computed(() => {
            if (this.datePicker.disabled()) {
                return true;
            }
            const maxDate = this.datePicker.max();
            const lastDay = this.dateAdapter.set(this.dateAdapter.endOfMonth(this.datePicker.focusedDate()), {
                hour: 23,
                minute: 59,
                second: 59,
                millisecond: 999,
            });
            // if there is a max date and it is equal to or before the last day of the month, disable it.
            if (maxDate && this.dateAdapter.compare(maxDate, lastDay) <= 0) {
                return true;
            }
            return false;
        });
    }
    /**
     * Navigate to the next month.
     */
    navigateToNextMonth() {
        if (this.disabled()) {
            return;
        }
        // move focus to the first day of the next month.
        let date = this.datePicker.focusedDate();
        date = this.dateAdapter.add(date, { months: 1 });
        date = this.dateAdapter.set(date, {
            day: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0,
        });
        this.datePicker.setFocusedDate(date, 'mouse', 'forward');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerNextMonth, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpDatePickerNextMonth, isStandalone: true, selector: "[ngpDatePickerNextMonth]", host: { listeners: { "click": "navigateToNextMonth()" }, properties: { "attr.data-disabled": "disabled() ? \"\" : null", "attr.aria-disabled": "disabled()", "attr.disabled": "isButton && disabled() ? true : null", "attr.type": "isButton ? \"button\" : null" } }, providers: [
            { provide: NgpDatePickerNextMonthToken, useExisting: NgpDatePickerNextMonth },
            { provide: NgpDisabledToken, useExisting: NgpDatePickerNextMonth },
        ], exportAs: ["ngpDatePickerNextMonth"], hostDirectives: [{ directive: i1.NgpButton }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerNextMonth, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerNextMonth]',
                    exportAs: 'ngpDatePickerNextMonth',
                    providers: [
                        { provide: NgpDatePickerNextMonthToken, useExisting: NgpDatePickerNextMonth },
                        { provide: NgpDisabledToken, useExisting: NgpDatePickerNextMonth },
                    ],
                    hostDirectives: [NgpButton],
                    host: {
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                        '[attr.aria-disabled]': 'disabled()',
                        '[attr.disabled]': 'isButton && disabled() ? true : null',
                        '[attr.type]': 'isButton ? "button" : null',
                    },
                }]
        }], propDecorators: { navigateToNextMonth: [{
                type: HostListener,
                args: ['click']
            }] } });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerPreviousMonthToken = new InjectionToken('NgpDatePickerPreviousMonthToken');
/**
 * Inject the DatePickerPreviousMonth directive instance
 */
function injectDatePickerPreviousMonth() {
    return inject(NgpDatePickerPreviousMonthToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerPreviousMonth {
    constructor() {
        /**
         * Access the element ref.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Determine if this is a button element
         */
        this.isButton = this.elementRef.nativeElement.tagName.toLowerCase() === 'button';
        /**
         * Determine if the next month is disabled.
         * @internal
         */
        this.disabled = computed(() => {
            if (this.datePicker.disabled()) {
                return true;
            }
            const minDate = this.datePicker.min();
            // if the next month is out of bounds, disable it.
            const firstDay = this.dateAdapter.set(this.dateAdapter.startOfMonth(this.datePicker.focusedDate()), {
                hour: 0,
                minute: 0,
                second: 0,
                millisecond: 0,
            });
            // if there is a min date and it is equal to or after the first day of the month, disable it.
            if (minDate && this.dateAdapter.compare(minDate, firstDay) >= 0) {
                return true;
            }
            return false;
        });
    }
    /**
     * Navigate to the previous month.
     */
    navigateToPreviouMonth() {
        if (this.disabled()) {
            return;
        }
        // move focus to the first day of the previous month.
        let date = this.datePicker.focusedDate();
        date = this.dateAdapter.subtract(date, { months: 1 });
        date = this.dateAdapter.set(date, {
            day: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0,
        });
        this.datePicker.setFocusedDate(date, 'mouse', 'backward');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerPreviousMonth, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpDatePickerPreviousMonth, isStandalone: true, selector: "[ngpDatePickerPreviousMonth]", host: { listeners: { "click": "navigateToPreviouMonth()" }, properties: { "attr.data-disabled": "disabled() ? \"\" : null", "attr.aria-disabled": "disabled()", "attr.disabled": "isButton && disabled() ? true : null", "attr.type": "isButton ? \"button\" : null" } }, providers: [
            { provide: NgpDatePickerPreviousMonthToken, useExisting: NgpDatePickerPreviousMonth },
            { provide: NgpDisabledToken, useExisting: NgpDatePickerPreviousMonth },
        ], exportAs: ["ngpDatePickerPreviousMonth"], hostDirectives: [{ directive: i1.NgpButton }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerPreviousMonth, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerPreviousMonth]',
                    exportAs: 'ngpDatePickerPreviousMonth',
                    providers: [
                        { provide: NgpDatePickerPreviousMonthToken, useExisting: NgpDatePickerPreviousMonth },
                        { provide: NgpDisabledToken, useExisting: NgpDatePickerPreviousMonth },
                    ],
                    hostDirectives: [NgpButton],
                    host: {
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                        '[attr.aria-disabled]': 'disabled()',
                        '[attr.disabled]': 'isButton && disabled() ? true : null',
                        '[attr.type]': 'isButton ? "button" : null',
                    },
                }]
        }], propDecorators: { navigateToPreviouMonth: [{
                type: HostListener,
                args: ['click']
            }] } });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerRowRender {
    constructor() {
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Access the template ref for the cell.
         */
        this.templateRef = inject(TemplateRef);
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Get all the days to display, this is the days of the current month
         * and the days of the previous and next month to fill the grid.
         */
        this.days = computed(() => {
            const month = this.datePicker.focusedDate();
            const days = [];
            // Get the first and last day of the month.
            let firstDay = this.dateAdapter.startOfMonth(month);
            let lastDay = this.dateAdapter.endOfMonth(month);
            // find the first and last day of visible in the grid.
            firstDay = this.dateAdapter.subtract(firstDay, {
                days: this.dateAdapter.getDay(firstDay),
            });
            lastDay = this.dateAdapter.add(lastDay, {
                days: 6 - this.dateAdapter.getDay(lastDay),
            });
            // collect all the days to display.
            while (firstDay <= lastDay) {
                days.push(firstDay);
                firstDay = this.dateAdapter.add(firstDay, { days: 1 });
            }
            return days;
        });
        // get the weeks to display.
        this.weeks = computed(() => {
            const days = this.days();
            const weeks = [];
            for (let i = 0; i < days.length; i += 7) {
                weeks.push(days.slice(i, i + 7));
            }
            return weeks;
        });
        /**
         * Store the embedded view refs of each rendered row.
         */
        this.viewRefs = [];
        // re-render the rows when the month changes.
        onChange(this.datePicker.focusedDate, (date, previousDate) => {
            if (!date || !previousDate || !this.dateAdapter.isSameMonth(date, previousDate)) {
                this.renderRows();
            }
        });
    }
    ngOnDestroy() {
        this.destroyRows();
    }
    /**
     * Render the row.
     */
    renderRows() {
        const weeks = this.weeks();
        // clear the view container.
        this.destroyRows();
        // render the weeks.
        for (const week of weeks) {
            const viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, null, {
                injector: Injector.create({
                    parent: this.viewContainerRef.injector,
                    providers: [{ provide: NgpDatePickerWeekToken, useValue: week }],
                }),
            });
            this.viewRefs.push(viewRef);
        }
    }
    /**
     * Destroy the row.
     */
    destroyRows() {
        for (const viewRef of this.viewRefs) {
            viewRef.destroy();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerRowRender, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpDatePickerRowRender, isStandalone: true, selector: "[ngpDatePickerRowRender]", providers: [{ provide: NgpDatePickerRowRenderToken, useExisting: NgpDatePickerRowRender }], exportAs: ["ngpDatePickerRowRender"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerRowRender, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerRowRender]',
                    exportAs: 'ngpDatePickerRowRender',
                    providers: [{ provide: NgpDatePickerRowRenderToken, useExisting: NgpDatePickerRowRender }],
                }]
        }], ctorParameters: () => [] });

class NgpDatePicker {
    constructor() {
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * The minimum date that can be selected.
         */
        this.min = input(undefined, {
            alias: 'ngpDatePickerMin',
        });
        /**
         * The maximum date that can be selected.
         */
        this.max = input(undefined, {
            alias: 'ngpDatePickerMax',
        });
        /**
         * Determine if the date picker is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpDatePickerDisabled',
            transform: booleanAttribute,
        });
        /**
         * A function that is called to determine if a specific date should be disabled.
         */
        this.dateDisabled = input(() => false, {
            alias: 'ngpDatePickerDateDisabled',
        });
        /**
         * The selected value.
         */
        this.date = model(undefined, {
            alias: 'ngpDatePickerDate',
        });
        /**
         * The focused value.
         */
        this.focusedDate = model(this.dateAdapter.now(), {
            alias: 'ngpDatePickerFocusedDate',
        });
        /**
         * Detect the label element.
         * @internal
         */
        this.label = contentChild(NgpDatePickerLabelToken, { descendants: true });
        /**
         * Access all the date picker buttons
         */
        this.buttons = contentChildren(NgpDatePickerDateButtonToken, { descendants: true });
    }
    /**
     * Set the focused date.
     * @param date The date to focus.
     * @internal
     */
    setFocusedDate(date, origin = 'mouse', direction) {
        if (this.disabled()) {
            return;
        }
        const min = this.min();
        const max = this.max();
        if (min && this.dateAdapter.isBefore(date, min)) {
            date = min;
        }
        if (max && this.dateAdapter.isAfter(date, max)) {
            date = max;
        }
        // if the date is disabled, find the next available date in the specified direction.
        if (this.dateDisabled()(date)) {
            let nextDate = this.dateAdapter.add(date, { days: direction === 'forward' ? 1 : -1 });
            while (this.dateDisabled()(nextDate) ||
                (min && this.dateAdapter.isBefore(nextDate, min)) ||
                (max && this.dateAdapter.isAfter(nextDate, max))) {
                nextDate = this.dateAdapter.add(nextDate, { days: direction === 'forward' ? 1 : -1 });
            }
            date = nextDate;
        }
        this.focusedDate.set(date);
        if (origin === 'keyboard') {
            afterNextRender({
                write: () => {
                    this.buttons().forEach(button => button.focus());
                },
            }, {
                injector: this.injector,
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePicker, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "18.2.13", type: NgpDatePicker, isStandalone: true, selector: "[ngpDatePicker]", inputs: { min: { classPropertyName: "min", publicName: "ngpDatePickerMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpDatePickerMax", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpDatePickerDisabled", isSignal: true, isRequired: false, transformFunction: null }, dateDisabled: { classPropertyName: "dateDisabled", publicName: "ngpDatePickerDateDisabled", isSignal: true, isRequired: false, transformFunction: null }, date: { classPropertyName: "date", publicName: "ngpDatePickerDate", isSignal: true, isRequired: false, transformFunction: null }, focusedDate: { classPropertyName: "focusedDate", publicName: "ngpDatePickerFocusedDate", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { date: "ngpDatePickerDateChange", focusedDate: "ngpDatePickerFocusedDateChange" }, host: { properties: { "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [{ provide: NgpDatePickerToken, useExisting: NgpDatePicker }], queries: [{ propertyName: "label", first: true, predicate: NgpDatePickerLabelToken, descendants: true, isSignal: true }, { propertyName: "buttons", predicate: NgpDatePickerDateButtonToken, descendants: true, isSignal: true }], exportAs: ["ngpDatePicker"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePicker, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePicker]',
                    exportAs: 'ngpDatePicker',
                    providers: [{ provide: NgpDatePickerToken, useExisting: NgpDatePicker }],
                    host: {
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDatePickerCellToken = new InjectionToken('NgpDatePickerCellToken');
/**
 * Inject the DatePickerCell directive instance
 */
function injectDatePickerCell() {
    return inject(NgpDatePickerCellToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDatePickerCell {
    constructor() {
        /**
         * Access the date picker.
         */
        this.datePicker = injectDatePicker();
        /**
         * Access the child date picker date button.
         */
        this.datePickerButton = contentChild(NgpDatePickerDateButtonToken, {
            descendants: true,
        });
        /**
         * Access the label id.
         */
        this.labelId = computed(() => this.datePicker.label()?.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerCell, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "18.2.13", type: NgpDatePickerCell, isStandalone: true, selector: "[ngpDatePickerCell]", host: { attributes: { "role": "gridcell" }, properties: { "attr.data-selected": "datePickerButton()?.selected() ? \"\" : null", "attr.aria-selected": "datePickerButton()?.selected()", "attr.aria-disabled": "datePickerButton()?.disabled()", "attr.data-disabled": "datePickerButton()?.disabled() ? \"\" : null", "attr.aria-labelledby": "labelId()" } }, providers: [{ provide: NgpDatePickerCellToken, useExisting: NgpDatePickerCell }], queries: [{ propertyName: "datePickerButton", first: true, predicate: NgpDatePickerDateButtonToken, descendants: true, isSignal: true }], exportAs: ["ngpDatePickerCell"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDatePickerCell, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDatePickerCell]',
                    exportAs: 'ngpDatePickerCell',
                    providers: [{ provide: NgpDatePickerCellToken, useExisting: NgpDatePickerCell }],
                    host: {
                        role: 'gridcell',
                        '[attr.data-selected]': 'datePickerButton()?.selected() ? "" : null',
                        '[attr.aria-selected]': 'datePickerButton()?.selected()',
                        '[attr.aria-disabled]': 'datePickerButton()?.disabled()',
                        '[attr.data-disabled]': 'datePickerButton()?.disabled() ? "" : null',
                        '[attr.aria-labelledby]': 'labelId()',
                    },
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpDatePicker, NgpDatePickerCell, NgpDatePickerCellRender, NgpDatePickerCellRenderToken, NgpDatePickerCellToken, NgpDatePickerDateButton, NgpDatePickerDateButtonToken, NgpDatePickerGrid, NgpDatePickerGridToken, NgpDatePickerLabel, NgpDatePickerLabelToken, NgpDatePickerNextMonth, NgpDatePickerNextMonthToken, NgpDatePickerPreviousMonth, NgpDatePickerPreviousMonthToken, NgpDatePickerRowRender, NgpDatePickerRowRenderToken, NgpDatePickerToken };
//# sourceMappingURL=ng-primitives-date-picker.mjs.map
