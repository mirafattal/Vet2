import * as i0 from '@angular/core';
import { InjectionToken, inject, TemplateRef, ViewContainerRef, Injector, input, numberAttribute, booleanAttribute, Directive } from '@angular/core';
import { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const defaultToastConfig = {
    gap: 16,
    duration: 3000,
    gravity: 'top',
    position: 'end',
    stopOnHover: true,
    ariaLive: 'polite',
};
const NgpToastConfigToken = new InjectionToken('NgpToastConfigToken');
/**
 * Provide the default Toast configuration
 * @param config The Toast configuration
 * @returns The provider
 */
function provideToastConfig(config) {
    return [
        {
            provide: NgpToastConfigToken,
            useValue: { ...defaultToastConfig, ...config },
        },
    ];
}
/**
 * Inject the Toast configuration
 * @returns The global Toast configuration
 */
function injectToastConfig() {
    return inject(NgpToastConfigToken, { optional: true }) ?? defaultToastConfig;
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpToastRef {
    /** Get the toast height */
    get height() {
        return this.toastElement.offsetHeight;
    }
    constructor(
    /** Store the toast element */
    toastElement, 
    /** Store the duration */
    duration, 
    /** The position of the toast */
    position, 
    /** The gravity of the toast */
    gravity, 
    /** Whether we should stop on focus */
    stopOnHover, 
    /** The aria live setting */
    ariaLive, onDismiss) {
        this.toastElement = toastElement;
        this.duration = duration;
        this.position = position;
        this.gravity = gravity;
        this.stopOnHover = stopOnHover;
        this.ariaLive = ariaLive;
        this.onDismiss = onDismiss;
        /** Store the current timeout */
        this.timeoutId = null;
        this.toastElement.setAttribute('data-toast', 'visible');
        this.setPosition(position);
        this.setGravity(gravity);
        this.setAriaLive(ariaLive);
        this.setupTimeouts();
        this.setupListeners();
    }
    dismiss() {
        // determine if there is a transition on the element
        const transitionDuration = parseFloat(getComputedStyle(this.toastElement).transitionDuration);
        // if there is no transition, dismiss immediately
        if (transitionDuration === 0) {
            this.removeElement();
            return;
        }
        // wait for the transition to end
        this.toastElement.addEventListener('transitionend', () => this.removeElement());
        this.toastElement.setAttribute('data-toast', 'hidden');
    }
    removeElement() {
        this.toastElement.parentNode?.removeChild(this.toastElement);
        this.onDismiss();
    }
    /** Setup duration timeouts */
    setupTimeouts() {
        // if the duration is 0 skip
        if (this.duration === 0) {
            return;
        }
        this.timeoutId = window.setTimeout(() => this.dismiss(), this.duration);
    }
    setupListeners() {
        if (!this.stopOnHover) {
            return;
        }
        // setup event listeners if we should stop on focus
        this.toastElement.addEventListener('mouseover', () => {
            window.clearTimeout(this.timeoutId);
            this.timeoutId = null;
        });
        this.toastElement.addEventListener('mouseleave', () => this.setupTimeouts());
    }
    /** Set the position attribute */
    setPosition(position) {
        this.toastElement.setAttribute('data-position', position);
    }
    /** Set the gravity attribute */
    setGravity(gravity) {
        this.toastElement.setAttribute('data-gravity', gravity);
    }
    /** Set the aria live attribute */
    setAriaLive(ariaLive) {
        this.toastElement.setAttribute('aria-live', ariaLive);
    }
    /**
     * @internal
     */
    setInset(property, value) {
        this.toastElement.style[property] = value;
    }
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpToastToken = new InjectionToken('NgpToastToken');
/**
 * Inject the Toast directive instance
 */
function injectToast() {
    return inject(NgpToastToken);
}

class NgpToast {
    constructor() {
        this.config = injectToastConfig();
        /** Access the ng-template */
        this.template = inject(TemplateRef);
        /** Access the view container */
        this.viewContainer = inject(ViewContainerRef);
        /** Access the injector */
        this.injector = inject(Injector);
        /** Access the document */
        this.document = inject(DOCUMENT);
        this.duration = input(this.config.duration, {
            alias: 'ngpToastDuration',
            transform: numberAttribute,
        });
        this.gravity = input(this.config.gravity, {
            alias: 'ngpToastGravity',
        });
        this.position = input(this.config.position, {
            alias: 'ngpToastPosition',
        });
        this.stopOnHover = input(this.config.stopOnHover, {
            alias: 'ngpToastStopOnHover',
            transform: booleanAttribute,
        });
        this.ariaLive = input(this.config.ariaLive, {
            alias: 'ngpToastAriaLive',
        });
        /** Store the list of toasts */
        this.toasts = [];
    }
    /** Show the toast. */
    show() {
        this.createToast();
        this.reposition();
    }
    /** Build the toast */
    createToast() {
        const portal = new TemplatePortal(this.template, this.viewContainer, {
            dismiss: () => toastRef.dismiss(),
        }, this.injector);
        const domOutlet = new DomPortalOutlet(this.document.body, undefined, undefined, Injector.create({
            parent: this.injector,
            providers: [],
        }));
        const viewRef = domOutlet.attach(portal);
        viewRef.detectChanges();
        const toastElement = viewRef.rootNodes[0];
        const toastRef = new NgpToastRef(toastElement, this.duration(), this.position(), this.gravity(), this.stopOnHover(), this.ariaLive(), () => {
            this.toasts = this.toasts.filter(t => t !== toastRef);
            this.reposition();
        });
        this.toasts = [...this.toasts, toastRef];
    }
    /** Position the toast on the DOM */
    reposition() {
        const topStartOffsetSize = {
            top: this.config.gap,
            bottom: this.config.gap,
        };
        const topEndOffsetSize = {
            top: this.config.gap,
            bottom: this.config.gap,
        };
        let position;
        // update the position of the toasts
        for (const toast of this.toasts) {
            // Getting the applied gravity
            position = toast.gravity;
            const height = toast.height;
            if (toast.position === 'start') {
                toast.setInset(position, `${topStartOffsetSize[position]}px`);
                topStartOffsetSize[position] += height + this.config.gap;
            }
            else {
                toast.setInset(position, `${topEndOffsetSize[position]}px`);
                topEndOffsetSize[position] += height + this.config.gap;
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpToast, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpToast, isStandalone: true, selector: "[ngpToast]", inputs: { duration: { classPropertyName: "duration", publicName: "ngpToastDuration", isSignal: true, isRequired: false, transformFunction: null }, gravity: { classPropertyName: "gravity", publicName: "ngpToastGravity", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "ngpToastPosition", isSignal: true, isRequired: false, transformFunction: null }, stopOnHover: { classPropertyName: "stopOnHover", publicName: "ngpToastStopOnHover", isSignal: true, isRequired: false, transformFunction: null }, ariaLive: { classPropertyName: "ariaLive", publicName: "ngpToastAriaLive", isSignal: true, isRequired: false, transformFunction: null } }, providers: [{ provide: NgpToastToken, useExisting: NgpToast }], exportAs: ["ngpToast"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpToast, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpToast]',
                    exportAs: 'ngpToast',
                    providers: [{ provide: NgpToastToken, useExisting: NgpToast }],
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpToast, NgpToastRef, NgpToastToken, provideToastConfig };
//# sourceMappingURL=ng-primitives-toast.mjs.map
