import * as i0 from '@angular/core';
import { InjectionToken, inject, signal, contentChild, Directive, ElementRef, input, computed, effect, HostListener } from '@angular/core';
import { NgControl } from '@angular/forms';
import { onChange, uniqueId, onBooleanChange } from 'ng-primitives/utils';
import { injectDisabled } from 'ng-primitives/internal';

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpFormFieldToken = new InjectionToken('NgpFormFieldToken');
/**
 * Inject the FormField directive instance
 * @param primitive
 */
function injectFormField() {
    return inject(NgpFormFieldToken, { optional: true });
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpFormField {
    constructor() {
        /**
         * Store the form label.
         * @internal
         */
        this.labels = signal([]);
        /**
         * Store the form descriptions.
         * @internal
         */
        this.descriptions = signal([]);
        /**
         * Store the id of the associated form control.
         * @internal
         */
        this.formControl = signal(null);
        /**
         * Find any NgControl within the form field.
         * @internal
         */
        this.ngControl = contentChild(NgControl);
        /**
         * Store the validation error messages.
         * @internal
         */
        this.errors = signal([]);
        /**
         * Whether the control is pristine.
         * @internal
         */
        this.pristine = signal(null);
        /**
         * Whether the control is touched.
         * @internal
         */
        this.touched = signal(null);
        /**
         * Whether the control is dirty.
         * @internal
         */
        this.dirty = signal(null);
        /**
         * Whether the control is valid.
         */
        this.valid = signal(null);
        /**
         * Whether the control is invalid.
         * @internal
         */
        this.invalid = signal(null);
        /**
         * Whether the control is pending.
         * @internal
         */
        this.pending = signal(null);
        /**
         * Whether the control is disabled.
         * @internal
         */
        this.disabled = signal(null);
        // any time the ngControl changes, setup the subscriptions.
        onChange(this.ngControl, this.setupSubscriptions.bind(this));
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
    /**
     * Setup a listener for the form control status.
     * @param control
     */
    setupSubscriptions(control) {
        // Unsubscribe from the previous subscriptions.
        this.subscription?.unsubscribe();
        // set the initial values
        this.updateStatus();
        // Listen for changes to the form control.
        this.subscription = control?.valueChanges?.subscribe(this.updateStatus.bind(this));
    }
    updateStatus() {
        const control = this.ngControl();
        if (!control) {
            return;
        }
        this.pristine.set(control.pristine);
        this.touched.set(control.touched);
        this.dirty.set(control.dirty);
        this.valid.set(control.valid);
        this.invalid.set(control.invalid);
        this.pending.set(control.pending);
        this.disabled.set(control.disabled);
        this.errors.set(control?.errors ? Object.keys(control.errors) : []);
    }
    /**
     * Register the id of the associated form control.
     * @param id
     * @internal
     */
    setFormControl(id) {
        this.formControl.set(id);
    }
    /**
     * Register a label with the form field.
     * @param label
     * @internal
     */
    addLabel(label) {
        this.labels.update(labels => [...labels, label]);
    }
    /**
     * Register a description with the form field.
     * @param description
     * @internal
     */
    addDescription(description) {
        this.descriptions.update(descriptions => [...descriptions, description]);
    }
    /**
     * Remove the associated form control.
     * @internal
     */
    removeFormControl() {
        this.formControl.set(null);
    }
    /**
     * Remove a label from the form field.
     * @param label
     * @internal
     */
    removeLabel(label) {
        this.labels.update(labels => labels.filter(l => l !== label));
    }
    /**
     * Remove a description from the form field.
     * @param description
     * @internal
     */
    removeDescription(description) {
        this.descriptions.update(descriptions => descriptions.filter(d => d !== description));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFormField, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "18.2.13", type: NgpFormField, isStandalone: true, selector: "[ngpFormField]", host: { properties: { "attr.data-invalid": "invalid() ? \"\" : null", "attr.data-valid": "valid() ? \"\" : null", "attr.data-touched": "touched() ? \"\" : null", "attr.data-pristine": "pristine() ? \"\" : null", "attr.data-dirty": "dirty() ? \"\" : null", "attr.data-pending": "pending() ? \"\" : null", "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [{ provide: NgpFormFieldToken, useExisting: NgpFormField }], queries: [{ propertyName: "ngControl", first: true, predicate: NgControl, descendants: true, isSignal: true }], exportAs: ["ngpFormField"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFormField, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpFormField]',
                    exportAs: 'ngpFormField',
                    providers: [{ provide: NgpFormFieldToken, useExisting: NgpFormField }],
                    host: {
                        '[attr.data-invalid]': 'invalid() ? "" : null',
                        '[attr.data-valid]': 'valid() ? "" : null',
                        '[attr.data-touched]': 'touched() ? "" : null',
                        '[attr.data-pristine]': 'pristine() ? "" : null',
                        '[attr.data-dirty]': 'dirty() ? "" : null',
                        '[attr.data-pending]': 'pending() ? "" : null',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpLabelToken = new InjectionToken('NgpLabelToken');
/**
 * Inject the Label directive instance
 */
function injectLabel() {
    return inject(NgpLabelToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpLabel {
    constructor() {
        /**
         * Access the element that the label is associated with.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access the form field that the label is associated with.
         */
        this.formField = injectFormField();
        /**
         * The id of the label. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-label'));
        /**
         * Determine if the label is an HTML label element.
         */
        this.isLabel = this.elementRef.nativeElement instanceof HTMLLabelElement;
        /**
         * Derive the for attribute value if the label is an HTML label element.
         */
        this.htmlFor = computed(() => this.formField?.formControl());
        effect(onCleanup => {
            this.formField?.addLabel(this.id());
            onCleanup(() => this.formField?.removeLabel(this.id()));
        }, { allowSignalWrites: true });
    }
    onClick(event) {
        // by default a label will perform a click on the associated form control, however
        // this only works if the associated form control is an input element which may not always
        // be the case, so we prevent the default behavior and handle the click event ourselves.
        // This was inspired by the HeadlessUI approach:
        // https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-react/src/components/label/label.tsx#L58
        if (this.isLabel) {
            event.preventDefault();
        }
        // to find the associated form control we can lookup via the known id
        const targetId = this.htmlFor();
        if (!targetId) {
            return;
        }
        const target = document.getElementById(targetId);
        if (!target) {
            return;
        }
        // if the target is disabled then do nothing
        const disabled = target.getAttribute('disabled');
        const ariaDisabled = target.getAttribute('aria-disabled');
        if (disabled === '' || disabled === 'true' || ariaDisabled === 'true') {
            return;
        }
        // radio buttons, checkboxes and switches should all be clicked immediately as they require state changes
        if ((target instanceof HTMLInputElement &&
            (target.type === 'radio' || target.type === 'checkbox')) ||
            target.role === 'radio' ||
            target.role === 'checkbox' ||
            target.role === 'switch') {
            target.click();
        }
        // Move focus to the element, this allows you to start using keyboard shortcuts since the
        // bound element is now focused.
        target.focus({ preventScroll: true });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpLabel, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpLabel, isStandalone: true, selector: "[ngpLabel]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)" }, properties: { "attr.id": "id()", "attr.for": "htmlFor()", "attr.data-invalid": "formField?.invalid() ? \"\" : null", "attr.data-valid": "formField?.valid() ? \"\" : null", "attr.data-touched": "formField?.touched() ? \"\" : null", "attr.data-pristine": "formField?.pristine() ? \"\" : null", "attr.data-dirty": "formField?.dirty() ? \"\" : null", "attr.data-pending": "formField?.pending() ? \"\" : null", "attr.data-disabled": "formField?.disabled() ? \"\" : null" } }, providers: [{ provide: NgpLabelToken, useExisting: NgpLabel }], exportAs: ["ngpLabel"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpLabel, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpLabel]',
                    exportAs: 'ngpLabel',
                    providers: [{ provide: NgpLabelToken, useExisting: NgpLabel }],
                    host: {
                        '[attr.id]': 'id()',
                        '[attr.for]': 'htmlFor()',
                        '[attr.data-invalid]': 'formField?.invalid() ? "" : null',
                        '[attr.data-valid]': 'formField?.valid() ? "" : null',
                        '[attr.data-touched]': 'formField?.touched() ? "" : null',
                        '[attr.data-pristine]': 'formField?.pristine() ? "" : null',
                        '[attr.data-dirty]': 'formField?.dirty() ? "" : null',
                        '[attr.data-pending]': 'formField?.pending() ? "" : null',
                        '[attr.data-disabled]': 'formField?.disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpDescriptionToken = new InjectionToken('NgpDescriptionToken');
/**
 * Inject the Description directive instance
 */
function injectDescription() {
    return inject(NgpDescriptionToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpDescription {
    constructor() {
        /**
         * Access the form field that the description is associated with.
         */
        this.formField = injectFormField();
        /**
         * The id of the description. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-description'));
        effect(onCleanup => {
            this.formField?.addDescription(this.id());
            onCleanup(() => this.formField?.removeDescription(this.id()));
        }, { allowSignalWrites: true });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDescription, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpDescription, isStandalone: true, selector: "[ngpDescription]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.id": "id()", "attr.data-invalid": "formField?.invalid() ? \"\" : null", "attr.data-valid": "formField?.valid() ? \"\" : null", "attr.data-touched": "formField?.touched() ? \"\" : null", "attr.data-pristine": "formField?.pristine() ? \"\" : null", "attr.data-dirty": "formField?.dirty() ? \"\" : null", "attr.data-pending": "formField?.pending() ? \"\" : null", "attr.data-disabled": "formField?.disabled() ? \"\" : null" } }, providers: [{ provide: NgpDescriptionToken, useExisting: NgpDescription }], exportAs: ["ngpDescription"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpDescription, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpDescription]',
                    exportAs: 'ngpDescription',
                    providers: [{ provide: NgpDescriptionToken, useExisting: NgpDescription }],
                    host: {
                        '[attr.id]': 'id()',
                        '[attr.data-invalid]': 'formField?.invalid() ? "" : null',
                        '[attr.data-valid]': 'formField?.valid() ? "" : null',
                        '[attr.data-touched]': 'formField?.touched() ? "" : null',
                        '[attr.data-pristine]': 'formField?.pristine() ? "" : null',
                        '[attr.data-dirty]': 'formField?.dirty() ? "" : null',
                        '[attr.data-pending]': 'formField?.pending() ? "" : null',
                        '[attr.data-disabled]': 'formField?.disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpFormControlToken = new InjectionToken('NgpFormControlToken');
/**
 * Inject the FormControl directive instance
 */
function injectFormControl() {
    return inject(NgpFormControlToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpFormControl {
    constructor() {
        /**
         * Access the form field that the form control is associated with.
         */
        this.formField = injectFormField();
        /**
         * Whether the form control is disabled by a parent.
         */
        this.disabled = injectDisabled();
        /**
         * The id of the form control. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-form-control'));
        /**
         * Determine the aria-labelledby attribute value.
         */
        this.ariaLabelledBy = computed(() => this.formField?.labels().join(' '));
        /**
         * Determine the aria-describedby attribute value.
         */
        this.ariaDescribedBy = computed(() => this.formField?.descriptions().join(' '));
        effect(onCleanup => {
            this.formField?.setFormControl(this.id());
            onCleanup(() => this.formField?.removeFormControl());
        }, { allowSignalWrites: true });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFormControl, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpFormControl, isStandalone: true, selector: "[ngpFormControl]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "id": "id()", "attr.aria-labelledby": "ariaLabelledBy()", "attr.aria-describedby": "ariaDescribedBy()", "attr.data-invalid": "formField?.invalid() ? \"\" : null", "attr.data-valid": "formField?.valid() ? \"\" : null", "attr.data-touched": "formField?.touched() ? \"\" : null", "attr.data-pristine": "formField?.pristine() ? \"\" : null", "attr.data-dirty": "formField?.dirty() ? \"\" : null", "attr.data-pending": "formField?.pending() ? \"\" : null", "attr.data-disabled": "formField?.disabled() || disabled() ? \"\" : null" } }, providers: [{ provide: NgpFormControlToken, useExisting: NgpFormControl }], exportAs: ["ngpFormControl"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpFormControl, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpFormControl]',
                    exportAs: 'ngpFormControl',
                    providers: [{ provide: NgpFormControlToken, useExisting: NgpFormControl }],
                    host: {
                        '[id]': 'id()',
                        '[attr.aria-labelledby]': 'ariaLabelledBy()',
                        '[attr.aria-describedby]': 'ariaDescribedBy()',
                        '[attr.data-invalid]': 'formField?.invalid() ? "" : null',
                        '[attr.data-valid]': 'formField?.valid() ? "" : null',
                        '[attr.data-touched]': 'formField?.touched() ? "" : null',
                        '[attr.data-pristine]': 'formField?.pristine() ? "" : null',
                        '[attr.data-dirty]': 'formField?.dirty() ? "" : null',
                        '[attr.data-pending]': 'formField?.pending() ? "" : null',
                        '[attr.data-disabled]': 'formField?.disabled() || disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpErrorToken = new InjectionToken('NgpErrorToken');
/**
 * Inject the Error directive instance
 */
function injectError() {
    return inject(NgpErrorToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpError {
    constructor() {
        /**
         * Access the form field that the description is associated with.
         */
        this.formField = injectFormField();
        /**
         * The id of the error message. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-error'));
        /**
         * The validator associated with the error message.
         */
        this.validator = input(null, {
            alias: 'ngpErrorValidator',
        });
        /**
         * Determine if there is an error message.
         */
        this.hasError = computed(() => {
            const errors = this.formField?.errors() ?? [];
            const validator = this.validator();
            return validator ? errors?.includes(validator) : errors?.length > 0;
        });
        /**
         * Determine whether the validator associated with this error is failing.
         */
        this.state = computed(() => (this.hasError() ? 'fail' : 'pass'));
        // add or remove the error message when the error state changes
        onBooleanChange(this.hasError, () => this.formField?.addDescription(this.id()), () => this.formField?.removeDescription(this.id()));
    }
    ngOnChanges(changes) {
        if ('id' in changes) {
            this.formField?.removeDescription(changes['id'].previousValue);
        }
    }
    ngOnDestroy() {
        this.formField?.removeDescription(this.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpError, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpError, isStandalone: true, selector: "[ngpError]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, validator: { classPropertyName: "validator", publicName: "ngpErrorValidator", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.id": "id()", "attr.data-invalid": "formField?.invalid() ? \"\" : null", "attr.data-valid": "formField?.valid() ? \"\" : null", "attr.data-touched": "formField?.touched() ? \"\" : null", "attr.data-pristine": "formField?.pristine() ? \"\" : null", "attr.data-dirty": "formField?.dirty() ? \"\" : null", "attr.data-pending": "formField?.pending() ? \"\" : null", "attr.data-disabled": "formField?.disabled() ? \"\" : null", "attr.data-validator": "state()" } }, providers: [{ provide: NgpErrorToken, useExisting: NgpError }], exportAs: ["ngpError"], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpError, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpError]',
                    exportAs: 'ngpError',
                    providers: [{ provide: NgpErrorToken, useExisting: NgpError }],
                    host: {
                        '[attr.id]': 'id()',
                        '[attr.data-invalid]': 'formField?.invalid() ? "" : null',
                        '[attr.data-valid]': 'formField?.valid() ? "" : null',
                        '[attr.data-touched]': 'formField?.touched() ? "" : null',
                        '[attr.data-pristine]': 'formField?.pristine() ? "" : null',
                        '[attr.data-dirty]': 'formField?.dirty() ? "" : null',
                        '[attr.data-pending]': 'formField?.pending() ? "" : null',
                        '[attr.data-disabled]': 'formField?.disabled() ? "" : null',
                        '[attr.data-validator]': 'state()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpDescription, NgpDescriptionToken, NgpError, NgpErrorToken, NgpFormControl, NgpFormControlToken, NgpFormField, NgpFormFieldToken, NgpLabel, NgpLabelToken };
//# sourceMappingURL=ng-primitives-form-field.mjs.map
