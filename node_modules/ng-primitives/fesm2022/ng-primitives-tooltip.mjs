import * as i0 from '@angular/core';
import { InjectionToken, inject, ElementRef, ViewContainerRef, Injector, input, model, booleanAttribute, numberAttribute, computed, signal, Directive, PLATFORM_ID, isDevMode } from '@angular/core';
import { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { offset, shift, flip, autoUpdate, computePosition } from '@floating-ui/dom';
import { injectDisposables, onBooleanChange } from 'ng-primitives/utils';

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const defaultTooltipConfig = {
    offset: 4,
    placement: 'top',
    showDelay: 0,
    hideDelay: 0,
    flip: true,
    container: null,
};
const NgpTooltipConfigToken = new InjectionToken('NgpTooltipConfigToken');
/**
 * Provide the default Tooltip configuration
 * @param config The Tooltip configuration
 * @returns The provider
 */
function provideTooltipConfig(config) {
    return [
        {
            provide: NgpTooltipConfigToken,
            useValue: { ...defaultTooltipConfig, ...config },
        },
    ];
}
/**
 * Inject the Tooltip configuration
 * @returns The global Tooltip configuration
 */
function injectTooltipConfig() {
    return inject(NgpTooltipConfigToken, { optional: true }) ?? defaultTooltipConfig;
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpTooltipTriggerToken = new InjectionToken('NgpTooltipTriggerToken');
/**
 * Inject the TooltipTrigger directive instance
 */
function injectTooltipTrigger() {
    return inject(NgpTooltipTriggerToken);
}
/**
 * Provides the TooltipTrigger directive instance
 * @param trigger
 */
function provideTooltipTrigger(trigger) {
    return { provide: NgpTooltipTriggerToken, useValue: trigger };
}

class NgpTooltipTrigger {
    constructor() {
        /**
         * Access the trigger element
         */
        this.trigger = inject((ElementRef));
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the document.
         */
        this.document = inject(DOCUMENT);
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the global tooltip configuration.
         */
        this.config = injectTooltipConfig();
        /**
         * Access the disposable utilities
         */
        this.disposables = injectDisposables();
        /**
         * Access the tooltip template ref.
         */
        this.tooltip = input.required({
            alias: 'ngpTooltipTrigger',
        });
        /**
         * The open state of the tooltip.
         * @default false
         */
        this.open = model(false, {
            alias: 'ngpTooltipTriggerOpen',
        });
        /**
         * Define if the trigger should be disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpTooltipTriggerDisabled',
            transform: booleanAttribute,
        });
        /**
         * Define the placement of the tooltip relative to the trigger.
         * @default 'top'
         */
        this.placement = input(this.config.placement, {
            alias: 'ngpTooltipTriggerPlacement',
        });
        /**
         * Define the offset of the tooltip relative to the trigger.
         * @default 0
         */
        this.offset = input(this.config.offset, {
            alias: 'ngpTooltipTriggerOffset',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the tooltip is displayed.
         * @default 0
         */
        this.showDelay = input(this.config.showDelay, {
            alias: 'ngpTooltipTriggerShowDelay',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the tooltip is hidden.
         * @default 0
         */
        this.hideDelay = input(this.config.hideDelay, {
            alias: 'ngpTooltipTriggerHideDelay',
            transform: numberAttribute,
        });
        /**
         * Define whether the tooltip should flip when there is not enough space for the tooltip.
         * @default true
         */
        this.flip = input(this.config.flip, {
            alias: 'ngpTooltipTriggerFlip',
            transform: booleanAttribute,
        });
        /**
         * Define the container in which the tooltip should be attached.
         * @default document.body
         */
        this.container = input(this.config.container, {
            alias: 'ngpTooltipTriggerContainer',
        });
        /**
         * Store the tooltip view ref.
         */
        this.viewRef = null;
        /**
         * Derive the tooltip middleware from the provided configuration.
         */
        this.middleware = computed(() => {
            const middleware = [offset(this.offset()), shift()];
            if (this.flip()) {
                middleware.push(flip());
            }
            return middleware;
        });
        /**
         * Store the computed position of the tooltip.
         * @internal
         */
        this.position = signal({
            x: 0,
            y: 0,
        });
        /**
         * Store the state of the tooltip.
         * @internal
         */
        this.state = signal('closed');
        // any time the open state changes then show or hide the tooltip
        onBooleanChange(this.open, this.show.bind(this), this.hide.bind(this));
    }
    ngOnDestroy() {
        this.destroyTooltip();
    }
    show() {
        // if the trigger is disabled or the tooltip is already open then do not show the tooltip
        if (this.disabled() || this.state() === 'open' || this.state() === 'opening') {
            return;
        }
        this.state.set('opening');
        this.disposables.setTimeout(() => this.createTooltip(), this.showDelay());
    }
    hide() {
        // if the trigger is disabled or the tooltip is already closed then do not hide the tooltip
        if (this.disabled() || this.state() === 'closed' || this.state() === 'closing') {
            return;
        }
        this.state.set('closing');
        this.disposables.setTimeout(() => this.destroyTooltip(), this.hideDelay());
    }
    createTooltip() {
        const portal = new TemplatePortal(this.tooltip(), this.viewContainerRef, undefined, this.injector);
        const domOutlet = new DomPortalOutlet(this.container() ?? this.document.body, undefined, undefined, Injector.create({
            parent: this.injector,
            providers: [provideTooltipTrigger(this)],
        }));
        this.viewRef = domOutlet.attach(portal);
        this.viewRef.detectChanges();
        const outletElement = this.viewRef.rootNodes[0];
        this.dispose = autoUpdate(this.trigger.nativeElement, outletElement, async () => {
            const position = await computePosition(this.trigger.nativeElement, outletElement, {
                placement: this.placement(),
                middleware: this.middleware(),
            });
            this.position.set({ x: position.x, y: position.y });
        });
        this.state.set('open');
    }
    destroyTooltip() {
        this.viewRef?.destroy();
        this.viewRef = null;
        this.dispose?.();
        this.state.set('closed');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpTooltipTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.13", type: NgpTooltipTrigger, isStandalone: true, selector: "[ngpTooltipTrigger]", inputs: { tooltip: { classPropertyName: "tooltip", publicName: "ngpTooltipTrigger", isSignal: true, isRequired: true, transformFunction: null }, open: { classPropertyName: "open", publicName: "ngpTooltipTriggerOpen", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpTooltipTriggerDisabled", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpTooltipTriggerPlacement", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "ngpTooltipTriggerOffset", isSignal: true, isRequired: false, transformFunction: null }, showDelay: { classPropertyName: "showDelay", publicName: "ngpTooltipTriggerShowDelay", isSignal: true, isRequired: false, transformFunction: null }, hideDelay: { classPropertyName: "hideDelay", publicName: "ngpTooltipTriggerHideDelay", isSignal: true, isRequired: false, transformFunction: null }, flip: { classPropertyName: "flip", publicName: "ngpTooltipTriggerFlip", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "ngpTooltipTriggerContainer", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { open: "ngpTooltipTriggerOpenChange" }, host: { listeners: { "mouseenter": "open.set(true)", "mouseleave": "open.set(false)", "focus": "open.set(true)", "blur": "open.set(false)" }, properties: { "attr.data-state": "state()", "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [{ provide: NgpTooltipTriggerToken, useExisting: NgpTooltipTrigger }], exportAs: ["ngpTooltipTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpTooltipTrigger, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpTooltipTrigger]',
                    exportAs: 'ngpTooltipTrigger',
                    providers: [{ provide: NgpTooltipTriggerToken, useExisting: NgpTooltipTrigger }],
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                        '(mouseenter)': 'open.set(true)',
                        '(mouseleave)': 'open.set(false)',
                        '(focus)': 'open.set(true)',
                        '(blur)': 'open.set(false)',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const NgpTooltipToken = new InjectionToken('NgpTooltipToken');
/**
 * Inject the Tooltip directive instance
 */
function injectTooltip() {
    return inject(NgpTooltipToken);
}

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
class NgpTooltip {
    constructor() {
        /**
         * Access the tooltip element.
         */
        this.tooltip = inject((ElementRef));
        /**
         * Access the platform.
         */
        this.platform = inject(PLATFORM_ID);
        /**
         * Access the trigger instance.
         */
        this.trigger = injectTooltipTrigger();
        /**
         * Compute the x position of the tooltip.
         */
        this.x = computed(() => this.trigger.position().x);
        /**
         * Compute the y position of the tooltip.
         */
        this.y = computed(() => this.trigger.position().y);
    }
    ngOnInit() {
        // if the element does not have a fixed position then throw a warning in dev mode
        if (isDevMode() && isPlatformBrowser(this.platform)) {
            const { position } = getComputedStyle(this.tooltip.nativeElement);
            if (position !== 'absolute') {
                console.warn(`The tooltip element must have an absolute position. The current position is ${position}.`);
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpTooltip, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: NgpTooltip, isStandalone: true, selector: "[ngpTooltip]", host: { attributes: { "role": "tooltip" }, properties: { "style.left.px": "x()", "style.top.px": "y()" } }, providers: [{ provide: NgpTooltipToken, useExisting: NgpTooltip }], exportAs: ["ngpTooltip"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgpTooltip, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngpTooltip]',
                    exportAs: 'ngpTooltip',
                    providers: [{ provide: NgpTooltipToken, useExisting: NgpTooltip }],
                    host: {
                        role: 'tooltip',
                        '[style.left.px]': 'x()',
                        '[style.top.px]': 'y()',
                    },
                }]
        }] });

/**
 * Copyright © 2024 Angular Primitives.
 * https://github.com/ng-primitives/ng-primitives
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpTooltip, NgpTooltipToken, NgpTooltipTrigger, NgpTooltipTriggerToken, provideTooltipConfig };
//# sourceMappingURL=ng-primitives-tooltip.mjs.map
