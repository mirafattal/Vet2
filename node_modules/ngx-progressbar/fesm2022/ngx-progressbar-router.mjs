import * as i0 from '@angular/core';
import { InjectionToken, inject, effect, untracked, Directive } from '@angular/core';
import { NavigationStart, NavigationEnd, NavigationCancel, NavigationError, Router } from '@angular/router';
import { toSignal } from '@angular/core/rxjs-interop';
import { filter, map } from 'rxjs';
import * as i1 from 'ngx-progressbar';
import { NgProgressRef } from 'ngx-progressbar';

const defaultRouterOptions = {
    minDuration: 0,
    startEvents: [NavigationStart],
    completeEvents: [NavigationEnd, NavigationCancel, NavigationError]
};

const NG_PROGRESS_ROUTER_OPTIONS = new InjectionToken('NG_PROGRESS_ROUTER_OPTIONS', {
    providedIn: 'root',
    factory: () => defaultRouterOptions
});
function provideNgProgressRouter(options) {
    return {
        provide: NG_PROGRESS_ROUTER_OPTIONS,
        useValue: { ...defaultRouterOptions, ...options },
    };
}

/**
 * Check if a router event type exists in an array of router event types
 */
function eventExists(routerEvent, events) {
    return events.some((e) => routerEvent instanceof e);
}
class NgProgressRouterBase {
    constructor() {
        this.router = inject(Router);
        this.config = inject(NG_PROGRESS_ROUTER_OPTIONS);
        this.progressRef = inject(NgProgressRef, { host: true, self: true });
        this.routerToggleEvent = toSignal(this.router.events.pipe(filter((event) => eventExists(event, [...this.config.startEvents, ...this.config.completeEvents])), map((event) => eventExists(event, this.config.startEvents))));
        effect((onCleanup) => {
            const toggle = this.routerToggleEvent();
            let completeTimeout;
            untracked(() => {
                if (toggle) {
                    this.progressRef.start();
                }
                else {
                    completeTimeout = setTimeout(() => {
                        this.progressRef.complete();
                    }, this.config.minDuration);
                }
                onCleanup(() => clearTimeout(completeTimeout));
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterBase, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressRouterBase, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterBase, decorators: [{
            type: Directive
        }], ctorParameters: () => [] });
class NgProgressRouter extends NgProgressRouterBase {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouter, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressRouter, isStandalone: true, selector: "ng-progress[ngProgressRouter]", usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouter, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: 'ng-progress[ngProgressRouter]'
                }]
        }] });
class NgProgressRouterRef extends NgProgressRouterBase {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterRef, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressRouterRef, isStandalone: true, selector: "[ngProgressRouter]:not(ng-progress)", usesInheritance: true, hostDirectives: [{ directive: i1.NgProgressRef }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterRef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngProgressRouter]:not(ng-progress)',
                    hostDirectives: [NgProgressRef]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NG_PROGRESS_ROUTER_OPTIONS, NgProgressRouter, NgProgressRouterRef, provideNgProgressRouter };
//# sourceMappingURL=ngx-progressbar-router.mjs.map
