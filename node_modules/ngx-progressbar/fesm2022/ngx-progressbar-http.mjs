import * as i0 from '@angular/core';
import { InjectionToken, signal, inject, computed, Injectable, effect, untracked, Directive } from '@angular/core';
import * as i1 from 'ngx-progressbar';
import { NgProgressRef } from 'ngx-progressbar';
import { finalize } from 'rxjs';

const NG_PROGRESS_HTTP_OPTIONS = new InjectionToken('NG_PROGRESS_HTTP_OPTIONS', {
    providedIn: 'root',
    factory: () => null
});
function provideNgProgressHttp(options) {
    return [
        {
            provide: NG_PROGRESS_HTTP_OPTIONS,
            useValue: options
        }
    ];
}

const NgProgressHttpCounter = new InjectionToken('NgProgressHttpCounter', {
    providedIn: 'root',
    factory: () => signal(0),
});

class NgProgressHttpManager {
    constructor() {
        this.inProgressCount = inject(NgProgressHttpCounter);
        this.requestsCount = computed(() => this.inProgressCount());
        this.requestsLoading = computed(() => !!this.inProgressCount());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttpManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttpManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttpManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class NgProgressHttpBase {
    constructor() {
        this.manager = inject(NgProgressHttpManager);
        this.progressRef = inject(NgProgressRef, { host: true, self: true });
        let initial = true;
        effect(() => {
            const requestLoading = this.manager.requestsLoading();
            // Ignore the initial execution if loading state is false
            if (initial) {
                initial = false;
                if (!requestLoading)
                    return;
            }
            untracked(() => {
                if (requestLoading) {
                    this.progressRef.start();
                }
                else if (this.progressRef.active()) {
                    this.progressRef.complete();
                }
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttpBase, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressHttpBase, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttpBase, decorators: [{
            type: Directive
        }], ctorParameters: () => [] });
class NgProgressHttp extends NgProgressHttpBase {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttp, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressHttp, isStandalone: true, selector: "ng-progress[ngProgressHttp]", usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttp, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: 'ng-progress[ngProgressHttp]'
                }]
        }] });
class NgProgressHttpRef extends NgProgressHttpBase {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttpRef, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressHttpRef, isStandalone: true, selector: "[ngProgressHttp]:not(ng-progress)", usesInheritance: true, hostDirectives: [{ directive: i1.NgProgressRef }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressHttpRef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngProgressHttp]:not(ng-progress)',
                    hostDirectives: [NgProgressRef]
                }]
        }] });

function progressInterceptor(req, next) {
    const config = inject(NG_PROGRESS_HTTP_OPTIONS);
    const inProgressCount = inject(NgProgressHttpCounter);
    // Ignore by request headers
    if (req.headers.has('ignoreProgressBar')) {
        return next(req.clone({ headers: req.headers.delete('ignoreProgressBar') }));
    }
    // Ignore silent api requests
    if (config && checkUrl(req, config)) {
        return next(req);
    }
    inProgressCount.set(inProgressCount() + 1);
    return next(req).pipe(finalize(() => {
        inProgressCount.set(inProgressCount() - 1);
    }));
}
/**
 * Check if request is silent.
 */
function checkUrl(req, config) {
    const url = req.url.toLowerCase();
    if (config.matcher && config.silentApis?.length) {
        return checkForMatcher(url, config.matcher) && checkForSilentApis(url, config.silentApis);
    }
    if (config.silentApis?.length) {
        return checkForSilentApis(url, config.silentApis);
    }
    if (config.matcher) {
        return checkForMatcher(url, config.matcher);
    }
    return false;
}
function checkForSilentApis(url, silentApis) {
    return !!silentApis.find((u) => url.includes(u.toLowerCase()));
}
function checkForMatcher(url, matcher) {
    return !!url.match(matcher);
}

/**
 * Generated bundle index. Do not edit.
 */

export { NG_PROGRESS_HTTP_OPTIONS, NgProgressHttp, NgProgressHttpRef, progressInterceptor, provideNgProgressHttp };
//# sourceMappingURL=ngx-progressbar-http.mjs.map
