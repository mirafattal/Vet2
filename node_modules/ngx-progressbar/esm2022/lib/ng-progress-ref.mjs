import { Directive, inject, signal, effect, output, computed, untracked, numberAttribute, input } from '@angular/core';
import { outputToObservable } from '@angular/core/rxjs-interop';
import { BehaviorSubject, of, tap, delay, timer, filter, finalize, switchMap, takeUntil, EMPTY } from 'rxjs';
import { NG_PROGRESS_OPTIONS } from './ng-progress.model';
import * as i0 from "@angular/core";
var TriggerType;
(function (TriggerType) {
    TriggerType["START"] = "START";
    TriggerType["COMPLETE"] = "COMPLETE";
})(TriggerType || (TriggerType = {}));
function minAttribute(value) {
    const min = numberAttribute(value) || 0;
    return (min < 100 && min >= 0) ? min : 0;
}
function maxAttribute(value) {
    const max = numberAttribute(value) || 100;
    return (max > 0 && max <= 100) ? max : 100;
}
export class NgProgressRef {
    constructor() {
        this.defaultOptions = inject(NG_PROGRESS_OPTIONS);
        this.min = input(this.defaultOptions.min, { transform: minAttribute });
        this.max = input(this.defaultOptions.max, { transform: maxAttribute });
        this.speed = input(this.defaultOptions.speed, { transform: numberAttribute });
        this.trickleSpeed = input(this.defaultOptions.trickleSpeed, { transform: numberAttribute });
        this.fadeOutSpeed = input(this.defaultOptions.fadeOutSpeed, { transform: numberAttribute });
        this.debounceTime = input(this.defaultOptions.debounceTime, { transform: numberAttribute });
        this.trickleFunc = input(this.defaultOptions.trickleFunc);
        this.config = computed(() => {
            return {
                max: this.max(),
                min: this.min(),
                speed: this.speed(),
                trickleSpeed: this.trickleSpeed(),
                fadeOutSpeed: this.fadeOutSpeed(),
                trickleFunc: this.trickleFunc(),
                debounceTime: this.debounceTime()
            };
        });
        this._progress = signal(0);
        this._active = signal(false);
        this.active = computed(() => this._active());
        this.progress = computed(() => this._progress());
        // Progress start source event (used to cancel onComplete delays)
        this.started = output();
        // Progress ended source event
        this.completed = output();
        this._trigger = new BehaviorSubject(null);
        let sub$;
        effect((onCleanup) => {
            const config = this.config();
            untracked(() => {
                sub$ = this._trigger.pipe(filter((trigger) => !!trigger), switchMap((trigger) => {
                    if (trigger === TriggerType.START) {
                        return timer(config.debounceTime).pipe(switchMap(() => this.onTrickling(config)));
                    }
                    return this.onComplete(config);
                })).subscribe();
                onCleanup(() => sub$?.unsubscribe());
            });
        });
    }
    /**
     * Start the progress
     */
    start() {
        this.started.emit();
        this._trigger.next(TriggerType.START);
        this._active.set(true);
    }
    /**
     * Complete the progress
     */
    complete() {
        this._trigger.next(TriggerType.COMPLETE);
    }
    /**
     * Increment the progress
     */
    inc(amount) {
        const n = this.progress();
        if (!this.active()) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this.config().trickleFunc(n);
            }
            this.set(n + amount);
        }
    }
    /**
     * Set the progress
     */
    set(n) {
        this._active.set(true);
        this._progress.set(this.clamp(n));
    }
    /**
     * Clamps a value to be between min and max
     */
    clamp(n) {
        return Math.max(this.config().min, Math.min(this.config().max, n));
    }
    /**
     * Keeps incrementing the progress
     */
    onTrickling(config) {
        if (!this.active()) {
            this.set(config.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(() => this.inc()));
    }
    /**
     * Completes then resets the progress
     */
    onComplete(config) {
        // If it's not active no need to complete
        if (!this.active()) {
            return EMPTY;
        }
        // Emit completed
        this.completed.emit();
        return of({}).pipe(
        // Complete the progress
        tap(() => this._progress.set(100)), 
        // Deactivate the progress after a tiny delay
        delay(config.speed + 140), tap(() => this._active.set(false)), 
        // Use a tiny delay before resetting
        delay(config.fadeOutSpeed), 
        // Force the progress to reset even it got cancelled
        finalize(() => this._progress.set(0)), 
        // Cancel any of the finalizing delays if the progress has started again
        takeUntil(outputToObservable(this.started)));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRef, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.12", type: NgProgressRef, isStandalone: true, selector: "[ngProgressRef]", inputs: { min: { classPropertyName: "min", publicName: "min", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "max", isSignal: true, isRequired: false, transformFunction: null }, speed: { classPropertyName: "speed", publicName: "speed", isSignal: true, isRequired: false, transformFunction: null }, trickleSpeed: { classPropertyName: "trickleSpeed", publicName: "trickleSpeed", isSignal: true, isRequired: false, transformFunction: null }, fadeOutSpeed: { classPropertyName: "fadeOutSpeed", publicName: "fadeOutSpeed", isSignal: true, isRequired: false, transformFunction: null }, debounceTime: { classPropertyName: "debounceTime", publicName: "debounceTime", isSignal: true, isRequired: false, transformFunction: null }, trickleFunc: { classPropertyName: "trickleFunc", publicName: "trickleFunc", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { started: "started", completed: "completed" }, exportAs: ["ngProgressRef"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngProgressRef]',
                    exportAs: 'ngProgressRef'
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MtcmVmLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXByb2dyZXNzYmFyL3NyYy9saWIvbmctcHJvZ3Jlc3MtcmVmLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsTUFBTSxFQUNOLE1BQU0sRUFDTixNQUFNLEVBQ04sTUFBTSxFQUNOLFFBQVEsRUFDUixTQUFTLEVBQ1QsZUFBZSxFQUNmLEtBQUssRUFPTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBR0wsZUFBZSxFQUNmLEVBQUUsRUFDRixHQUFHLEVBQ0gsS0FBSyxFQUNMLEtBQUssRUFDTCxNQUFNLEVBQ04sUUFBUSxFQUNSLFNBQVMsRUFDVCxTQUFTLEVBQ1QsS0FBSyxFQUNOLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUFxQixtQkFBbUIsRUFBd0IsTUFBTSxxQkFBcUIsQ0FBQzs7QUFFbkcsSUFBSyxXQUdKO0FBSEQsV0FBSyxXQUFXO0lBQ2QsOEJBQWUsQ0FBQTtJQUNmLG9DQUFxQixDQUFBO0FBQ3ZCLENBQUMsRUFISSxXQUFXLEtBQVgsV0FBVyxRQUdmO0FBRUQsU0FBUyxZQUFZLENBQUMsS0FBc0I7SUFDMUMsTUFBTSxHQUFHLEdBQVcsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxPQUFPLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxLQUFzQjtJQUMxQyxNQUFNLEdBQUcsR0FBVyxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDO0lBQ2xELE9BQU8sQ0FBQyxHQUFHLEdB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LENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSTtRQUNoQix3QkFBd0I7UUFDeEIsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xDLDZDQUE2QztRQUM3QyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsRUFDekIsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWxDLG9DQUFvQztRQUNwQyxLQUFLLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUMxQixvREFBb0Q7UUFDcEQsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLHdFQUF3RTtRQUN4RSxTQUFTLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQzVDLENBQUM7SUFDSixDQUFDOytHQWpKVSxhQUFhO21HQUFiLGFBQWE7OzRGQUFiLGFBQWE7a0JBTHpCLFNBQVM7bUJBQUM7b0JBQ1QsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFFBQVEsRUFBRSxlQUFlO2lCQUMxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIGluamVjdCxcclxuICBzaWduYWwsXHJcbiAgZWZmZWN0LFxyXG4gIG91dHB1dCxcclxuICBjb21wdXRlZCxcclxuICB1bnRyYWNrZWQsXHJcbiAgbnVtYmVyQXR0cmlidXRlLFxyXG4gIGlucHV0LFxyXG4gIFNpZ25hbCxcclxuICBJbnB1dFNpZ25hbCxcclxuICBXcml0YWJsZVNpZ25hbCxcclxuICBPdXRwdXRFbWl0dGVyUmVmLFxyXG4gIEVmZmVjdENsZWFudXBSZWdpc3RlckZuLFxyXG4gIElucHV0U2lnbmFsV2l0aFRyYW5zZm9ybVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBvdXRwdXRUb09ic2VydmFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XHJcbmltcG9ydCB7XHJcbiAgT2JzZXJ2YWJsZSxcclxuICBTdWJzY3JpcHRpb24sXHJcbiAgQmVoYXZpb3JTdWJqZWN0LFxyXG4gIG9mLFxyXG4gIHRhcCxcclxuICBkZWxheSxcclxuICB0aW1lcixcclxuICBmaWx0ZXIsXHJcbiAgZmluYWxpemUsXHJcbiAgc3dpdGNoTWFwLFxyXG4gIHRha2VVbnRpbCxcclxuICBFTVBUWVxyXG59IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzT3B0aW9ucywgTkdfUFJPR1JFU1NfT1BUSU9OUywgTmdQcm9ncmVzc1JlZk9wdGlvbnMgfSBmcm9tICcuL25nLXByb2dyZXNzLm1vZGVsJztcclxuXHJcbmVudW0gVHJpZ2dlclR5cGUge1xyXG4gIFNUQVJUID0gJ1NUQVJUJyxcclxuICBDT01QTEVURSA9ICdDT01QTEVURSdcclxufVxyXG5cclxuZnVuY3Rpb24gbWluQXR0cmlidXRlKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIge1xyXG4gIGNvbnN0IG1pbjogbnVtYmVyID0gbnVtYmVyQXR0cmlidXRlKHZhbHVlKSB8fCAwO1xyXG4gIHJldHVybiAobWluIDwgMTAwICYmIG1pbiA+PSAwKSA/IG1pbiA6IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1heEF0dHJpYnV0ZSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcclxuICBjb25zdCBtYXg6IG51bWJlciA9IG51bWJlckF0dHJpYnV0ZSh2YWx1ZSkgfHwgMTAwO1xyXG4gIHJldHVybiAobWF4ID4gMCAmJiBtYXggPD0gMTAwKSA/IG1heCA6IDEwMDtcclxufVxyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcclxuICBzZWxlY3RvcjogJ1tuZ1Byb2dyZXNzUmVmXScsXHJcbiAgZXhwb3J0QXM6ICduZ1Byb2dyZXNzUmVmJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc1JlZiB7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdE9wdGlvbnM6IE5nUHJvZ3Jlc3NPcHRpb25zID0gaW5qZWN0KE5HX1BST0dSRVNTX09QVElPTlMpO1xyXG5cclxuICBtaW46IElucHV0U2lnbmFsV2l0aFRyYW5zZm9ybTxudW1iZXIsIG51bWJlciB8IHN0cmluZz4gPSBpbnB1dDxudW1iZXIsIG51bWJlciB8IHN0cmluZz4odGhpcy5kZWZhdWx0T3B0aW9ucy5taW4sIHsgdHJhbnNmb3JtOiBtaW5BdHRyaWJ1dGUgfSk7XHJcbiAgbWF4OiBJbnB1dFNpZ25hbFdpdGhUcmFuc2Zvcm08bnVtYmVyLCBudW1iZXIgfCBzdHJpbmc+ID0gaW5wdXQ8bnVtYmVyLCBudW1iZXIgfCBzdHJpbmc+KHRoaXMuZGVmYXVsdE9wdGlvbnMubWF4LCB7IHRyYW5zZm9ybTogbWF4QXR0cmlidXRlIH0pO1xyXG4gIHNwZWVkOiBJbnB1dFNpZ25hbFdpdGhUcmFuc2Zvcm08bnVtYmVyLCBudW1iZXIgfCBzdHJpbmc+ID0gaW5wdXQ8bnVtYmVyLCBudW1iZXIgfCBzdHJpbmc+KHRoaXMuZGVmYXVsdE9wdGlvbnMuc3BlZWQsIHsgdHJhbnNmb3JtOiBudW1iZXJBdHRyaWJ1dGUgfSk7XHJcbiAgdHJpY2tsZVNwZWVkOiBJbnB1dFNpZ25hbFdpdGhUcmFuc2Zvcm08bnVtYmVyLCBudW1iZXIgfCBzdHJpbmc+ID0gaW5wdXQ8bnVtYmVyLCBudW1iZXIgfCBzdHJpbmc+KHRoaXMuZGVmYXVsdE9wdGlvbnMudHJpY2tsZVNwZWVkLCB7IHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlIH0pO1xyXG4gIGZhZGVPdXRTcGVlZDogSW5wdXRTaWduYWxXaXRoVHJhbnNmb3JtPG51bWJlciwgbnVtYmVyIHwgc3RyaW5nPiA9IGlucHV0PG51bWJlciwgbnVtYmVyIHwgc3RyaW5nPih0aGlzLmRlZmF1bHRPcHRpb25zLmZhZGVPdXRTcGVlZCwgeyB0cmFuc2Zvcm06IG51bWJlckF0dHJpYnV0ZSB9KTtcclxuICBkZWJvdW5jZVRpbWU6IElucHV0U2lnbmFsV2l0aFRyYW5zZm9ybTxudW1iZXIsIG51bWJlciB8IHN0cmluZz4gPSBpbnB1dDxudW1iZXIsIG51bWJlciB8IHN0cmluZz4odGhpcy5kZWZhdWx0T3B0aW9ucy5kZWJvdW5jZVRpbWUsIHsgdHJhbnNmb3JtOiBudW1iZXJBdHRyaWJ1dGUgfSk7XHJcbiAgdHJpY2tsZUZ1bmM6IElucHV0U2lnbmFsPChuOiBudW1iZXIpID0+IG51bWJlcj4gPSBpbnB1dCh0aGlzLmRlZmF1bHRPcHRpb25zLnRyaWNrbGVGdW5jKTtcclxuXHJcbiAgY29uZmlnOiBTaWduYWw8TmdQcm9ncmVzc1JlZk9wdGlvbnM+ID0gY29tcHV0ZWQoKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbWF4OiB0aGlzLm1heCgpLFxyXG4gICAgICBtaW46IHRoaXMubWluKCksXHJcbiAgICAgIHNwZWVkOiB0aGlzLnNwZWVkKCksXHJcbiAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQoKSxcclxuICAgICAgZmFkZU91dFNwZWVkOiB0aGlzLmZhZGVPdXRTcGVlZCgpLFxyXG4gICAgICB0cmlja2xlRnVuYzogdGhpcy50cmlja2xlRnVuYygpLFxyXG4gICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lKClcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcHJpdmF0ZSBfcHJvZ3Jlc3M6IFdyaXRhYmxlU2lnbmFsPG51bWJlcj4gPSBzaWduYWw8bnVtYmVyPigwKTtcclxuXHJcbiAgcHJpdmF0ZSBfYWN0aXZlOiBXcml0YWJsZVNpZ25hbDxib29sZWFuPiA9IHNpZ25hbDxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIGFjdGl2ZTogU2lnbmFsPGJvb2xlYW4+ID0gY29tcHV0ZWQoKCkgPT4gdGhpcy5fYWN0aXZlKCkpO1xyXG5cclxuICBwcm9ncmVzczogU2lnbmFsPG51bWJlcj4gPSBjb21wdXRlZCgoKSA9PiB0aGlzLl9wcm9ncmVzcygpKTtcclxuXHJcbiAgLy8gUHJvZ3Jlc3Mgc3RhcnQgc291cmNlIGV2ZW50ICh1c2VkIHRvIGNhbmNlbCBvbkNvbXBsZXRlIGRlbGF5cylcclxuICBzdGFydGVkOiBPdXRwdXRFbWl0dGVyUmVmPHZvaWQ+ID0gb3V0cHV0PHZvaWQ+KCk7XHJcblxyXG4gIC8vIFByb2dyZXNzIGVuZGVkIHNvdXJjZSBldmVudFxyXG4gIGNvbXBsZXRlZDogT3V0cHV0RW1pdHRlclJlZjx2b2lkPiA9IG91dHB1dDx2b2lkPigpO1xyXG5cclxuICBwcml2YXRlIF90cmlnZ2VyOiBCZWhhdmlvclN1YmplY3Q8VHJpZ2dlclR5cGU+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUcmlnZ2VyVHlwZT4obnVsbCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgbGV0IHN1YiQ6IFN1YnNjcmlwdGlvbjtcclxuICAgIGVmZmVjdCgob25DbGVhbnVwOiBFZmZlY3RDbGVhbnVwUmVnaXN0ZXJGbikgPT4ge1xyXG4gICAgICBjb25zdCBjb25maWc6IE5nUHJvZ3Jlc3NPcHRpb25zID0gdGhpcy5jb25maWcoKTtcclxuXHJcbiAgICAgIHVudHJhY2tlZCgoKSA9PiB7XHJcbiAgICAgICAgc3ViJCA9IHRoaXMuX3RyaWdnZXIucGlwZShcclxuICAgICAgICAgIGZpbHRlcigodHJpZ2dlcjogVHJpZ2dlclR5cGUpID0+ICEhdHJpZ2dlciksXHJcbiAgICAgICAgICBzd2l0Y2hNYXAoKHRyaWdnZXI6IFRyaWdnZXJUeXBlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyID09PSBUcmlnZ2VyVHlwZS5TVEFSVCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aW1lcihjb25maWcuZGVib3VuY2VUaW1lKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMub25Ucmlja2xpbmcoY29uZmlnKSlcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uQ29tcGxldGUoY29uZmlnKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgKS5zdWJzY3JpYmUoKTtcclxuXHJcbiAgICAgICAgb25DbGVhbnVwKCgpID0+IHN1YiQ/LnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgc3RhcnQoKTogdm9pZCB7XHJcbiAgICB0aGlzLnN0YXJ0ZWQuZW1pdCgpO1xyXG4gICAgdGhpcy5fdHJpZ2dlci5uZXh0KFRyaWdnZXJUeXBlLlNUQVJUKTtcclxuICAgIHRoaXMuX2FjdGl2ZS5zZXQodHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wbGV0ZSB0aGUgcHJvZ3Jlc3NcclxuICAgKi9cclxuICBjb21wbGV0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3RyaWdnZXIubmV4dChUcmlnZ2VyVHlwZS5DT01QTEVURSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmNyZW1lbnQgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgaW5jKGFtb3VudD86IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3QgbjogbnVtYmVyID0gdGhpcy5wcm9ncmVzcygpO1xyXG4gICAgaWYgKCF0aGlzLmFjdGl2ZSgpKSB7XHJcbiAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGFtb3VudCA9IHRoaXMuY29uZmlnKCkudHJpY2tsZUZ1bmMobik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZXQobiArIGFtb3VudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgc2V0KG46IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5fYWN0aXZlLnNldCh0cnVlKTtcclxuICAgIHRoaXMuX3Byb2dyZXNzLnNldCh0aGlzLmNsYW1wKG4pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYW1wcyBhIHZhbHVlIHRvIGJlIGJldHdlZW4gbWluIGFuZCBtYXhcclxuICAgKi9cclxuICBwcml2YXRlIGNsYW1wKG46IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5jb25maWcoKS5taW4sIE1hdGgubWluKHRoaXMuY29uZmlnKCkubWF4LCBuKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBLZWVwcyBpbmNyZW1lbnRpbmcgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvblRyaWNrbGluZyhjb25maWc6IE5nUHJvZ3Jlc3NPcHRpb25zKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgIGlmICghdGhpcy5hY3RpdmUoKSkge1xyXG4gICAgICB0aGlzLnNldChjb25maWcubWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lcigwLCBjb25maWcudHJpY2tsZVNwZWVkKS5waXBlKHRhcCgoKSA9PiB0aGlzLmluYygpKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wbGV0ZXMgdGhlbiByZXNldHMgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvbkNvbXBsZXRlKGNvbmZpZzogTmdQcm9ncmVzc09wdGlvbnMpOiBPYnNlcnZhYmxlPHVua25vd24+IHtcclxuICAgIC8vIElmIGl0J3Mgbm90IGFjdGl2ZSBubyBuZWVkIHRvIGNvbXBsZXRlXHJcbiAgICBpZiAoIXRoaXMuYWN0aXZlKCkpIHtcclxuICAgICAgcmV0dXJuIEVNUFRZO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVtaXQgY29tcGxldGVkXHJcbiAgICB0aGlzLmNvbXBsZXRlZC5lbWl0KCk7XHJcblxyXG4gICAgcmV0dXJuIG9mKHt9KS5waXBlKFxyXG4gICAgICAvLyBDb21wbGV0ZSB0aGUgcHJvZ3Jlc3NcclxuICAgICAgdGFwKCgpID0+IHRoaXMuX3Byb2dyZXNzLnNldCgxMDApKSxcclxuICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgcHJvZ3Jlc3MgYWZ0ZXIgYSB0aW55IGRlbGF5XHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCArIDE0MCksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLl9hY3RpdmUuc2V0KGZhbHNlKSksXHJcblxyXG4gICAgICAvLyBVc2UgYSB0aW55IGRlbGF5IGJlZm9yZSByZXNldHRpbmdcclxuICAgICAgZGVsYXkoY29uZmlnLmZhZGVPdXRTcGVlZCksXHJcbiAgICAgIC8vIEZvcmNlIHRoZSBwcm9ncmVzcyB0byByZXNldCBldmVuIGl0IGdvdCBjYW5jZWxsZWRcclxuICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5fcHJvZ3Jlc3Muc2V0KDApKSxcclxuICAgICAgLy8gQ2FuY2VsIGFueSBvZiB0aGUgZmluYWxpemluZyBkZWxheXMgaWYgdGhlIHByb2dyZXNzIGhhcyBzdGFydGVkIGFnYWluXHJcbiAgICAgIHRha2VVbnRpbChvdXRwdXRUb09ic2VydmFibGUodGhpcy5zdGFydGVkKSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdfQ==