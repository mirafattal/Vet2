import { Directive, inject, effect, untracked } from '@angular/core';
import { Router } from '@angular/router';
import { toSignal } from '@angular/core/rxjs-interop';
import { filter, map } from 'rxjs';
import { NgProgressRef } from 'ngx-progressbar';
import { NG_PROGRESS_ROUTER_OPTIONS } from './ng-progress-router.model';
import * as i0 from "@angular/core";
import * as i1 from "ngx-progressbar";
/**
 * Check if a router event type exists in an array of router event types
 */
function eventExists(routerEvent, events) {
    return events.some((e) => routerEvent instanceof e);
}
class NgProgressRouterBase {
    constructor() {
        this.router = inject(Router);
        this.config = inject(NG_PROGRESS_ROUTER_OPTIONS);
        this.progressRef = inject(NgProgressRef, { host: true, self: true });
        this.routerToggleEvent = toSignal(this.router.events.pipe(filter((event) => eventExists(event, [...this.config.startEvents, ...this.config.completeEvents])), map((event) => eventExists(event, this.config.startEvents))));
        effect((onCleanup) => {
            const toggle = this.routerToggleEvent();
            let completeTimeout;
            untracked(() => {
                if (toggle) {
                    this.progressRef.start();
                }
                else {
                    completeTimeout = setTimeout(() => {
                        this.progressRef.complete();
                    }, this.config.minDuration);
                }
                onCleanup(() => clearTimeout(completeTimeout));
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterBase, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressRouterBase, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterBase, decorators: [{
            type: Directive
        }], ctorParameters: () => [] });
export class NgProgressRouter extends NgProgressRouterBase {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouter, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressRouter, isStandalone: true, selector: "ng-progress[ngProgressRouter]", usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouter, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: 'ng-progress[ngProgressRouter]'
                }]
        }] });
export class NgProgressRouterRef extends NgProgressRouterBase {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterRef, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.12", type: NgProgressRouterRef, isStandalone: true, selector: "[ngProgressRouter]:not(ng-progress)", usesInheritance: true, hostDirectives: [{ directive: i1.NgProgressRef }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.12", ngImport: i0, type: NgProgressRouterRef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[ngProgressRouter]:not(ng-progress)',
                    hostDirectives: [NgProgressRef]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3Mtcm91dGVyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1wcm9ncmVzc2Jhci9yb3V0ZXIvc3JjL25nLXByb2dyZXNzLXJvdXRlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQVEsTUFBTSxFQUFFLFNBQVMsRUFBbUMsTUFBTSxlQUFlLENBQUM7QUFDNUcsT0FBTyxFQUFTLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLDBCQUEwQixFQUEyQixNQUFNLDRCQUE0QixDQUFDOzs7QUFFakc7O0dBRUc7QUFDSCxTQUFTLFdBQVcsQ0FBQyxXQUFrQixFQUFFLE1BQXFCO0lBQzVELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQWMsRUFBRSxFQUFFLENBQUMsV0FBVyxZQUFZLENBQUMsQ0FBQyxDQUFDO0FBQ25FLENBQUM7QUFFRCxNQUNNLG9CQUFvQjtJQWV4QjtRQWJpQixXQUFNLEdBQVcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWhDLFdBQU0sR0FBNEIsTUFBTSxDQUFDLDBCQUEwQixDQUFDLENBQUM7UUFFN0UsZ0JBQVcsR0FBa0IsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFFdkUsc0JBQWlCLEdBQW9CLFFBQVEsQ0FDNUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUNyQixNQUFNLENBQUMsQ0FBQyxLQUFZLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQ3pHLEdBQUcsQ0FBQyxDQUFDLEtBQVksRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQ25FLENBQ0YsQ0FBQztRQUdBLE1BQU0sQ0FBQyxDQUFDLFNBQWtDLEVBQUUsRUFBRTtZQUM1QyxNQUFNLE1BQU0sR0FBWSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUNqRCxJQUFJLGVBQThDLENBQUM7WUFFbkQsU0FBUyxDQUFDLEdBQUcsRUFBRTtnQkFDYixJQUFJLE1BQU0sRUFBRSxDQUFDO29CQUNYLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQzNCLENBQUM7cUJBQU0sQ0FBQztvQkFDTixlQUFlLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTt3QkFDaEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDOUIsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQzlCLENBQUM7Z0JBRUQsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1lBQ2pELENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOytHQWhDRyxvQkFBb0I7bUdBQXBCLG9CQUFvQjs7NEZBQXBCLG9CQUFvQjtrQkFEekIsU0FBUzs7QUF3Q1YsTUFBTSxPQUFPLGdCQUFpQixTQUFRLG9CQUFvQjsrR0FBN0MsZ0JBQWdCO21HQUFoQixnQkFBZ0I7OzRGQUFoQixnQkFBZ0I7a0JBSjVCLFNBQVM7bUJBQUM7b0JBQ1QsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSwrQkFBK0I7aUJBQzFDOztBQVNELE1BQU0sT0FBTyxtQkFBb0IsU0FBUSxvQkFBb0I7K0dBQWhELG1CQUFtQjttR0FBbkIsbUJBQW1COzs0RkFBbkIsbUJBQW1CO2tCQUwvQixTQUFTO21CQUFDO29CQUNULFVBQVUsRUFBRSxJQUFJO29CQUNoQixRQUFRLEVBQUUscUNBQXFDO29CQUMvQyxjQUFjLEVBQUUsQ0FBQyxhQUFhLENBQUM7aUJBQ2hDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBpbmplY3QsIFR5cGUsIGVmZmVjdCwgdW50cmFja2VkLCBTaWduYWwsIEVmZmVjdENsZWFudXBSZWdpc3RlckZuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEV2ZW50LCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyB0b1NpZ25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcclxuaW1wb3J0IHsgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJ25neC1wcm9ncmVzc2Jhcic7XHJcbmltcG9ydCB7IE5HX1BST0dSRVNTX1JPVVRFUl9PUFRJT05TLCBOZ1Byb2dyZXNzUm91dGVyT3B0aW9ucyB9IGZyb20gJy4vbmctcHJvZ3Jlc3Mtcm91dGVyLm1vZGVsJztcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHJvdXRlciBldmVudCB0eXBlIGV4aXN0cyBpbiBhbiBhcnJheSBvZiByb3V0ZXIgZXZlbnQgdHlwZXNcclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50RXhpc3RzKHJvdXRlckV2ZW50OiBFdmVudCwgZXZlbnRzOiBUeXBlPEV2ZW50PltdKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIGV2ZW50cy5zb21lKChlOiBUeXBlPEV2ZW50PikgPT4gcm91dGVyRXZlbnQgaW5zdGFuY2VvZiBlKTtcclxufVxyXG5cclxuQERpcmVjdGl2ZSgpXHJcbmNsYXNzIE5nUHJvZ3Jlc3NSb3V0ZXJCYXNlIHtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSByb3V0ZXI6IFJvdXRlciA9IGluamVjdChSb3V0ZXIpO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogTmdQcm9ncmVzc1JvdXRlck9wdGlvbnMgPSBpbmplY3QoTkdfUFJPR1JFU1NfUk9VVEVSX09QVElPTlMpO1xyXG5cclxuICByZWFkb25seSBwcm9ncmVzc1JlZjogTmdQcm9ncmVzc1JlZiA9IGluamVjdChOZ1Byb2dyZXNzUmVmLCB7IGhvc3Q6IHRydWUsIHNlbGY6IHRydWUgfSk7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgcm91dGVyVG9nZ2xlRXZlbnQ6IFNpZ25hbDxib29sZWFuPiA9IHRvU2lnbmFsPGJvb2xlYW4+KFxyXG4gICAgdGhpcy5yb3V0ZXIuZXZlbnRzLnBpcGUoXHJcbiAgICAgIGZpbHRlcigoZXZlbnQ6IEV2ZW50KSA9PiBldmVudEV4aXN0cyhldmVudCwgWy4uLnRoaXMuY29uZmlnLnN0YXJ0RXZlbnRzLCAuLi50aGlzLmNvbmZpZy5jb21wbGV0ZUV2ZW50c10pKSxcclxuICAgICAgbWFwKChldmVudDogRXZlbnQpID0+IGV2ZW50RXhpc3RzKGV2ZW50LCB0aGlzLmNvbmZpZy5zdGFydEV2ZW50cykpXHJcbiAgICApXHJcbiAgKTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBlZmZlY3QoKG9uQ2xlYW51cDogRWZmZWN0Q2xlYW51cFJlZ2lzdGVyRm4pID0+IHtcclxuICAgICAgY29uc3QgdG9nZ2xlOiBib29sZWFuID0gdGhpcy5yb3V0ZXJUb2dnbGVFdmVudCgpO1xyXG4gICAgICBsZXQgY29tcGxldGVUaW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PjtcclxuXHJcbiAgICAgIHVudHJhY2tlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRvZ2dsZSkge1xyXG4gICAgICAgICAgdGhpcy5wcm9ncmVzc1JlZi5zdGFydCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb21wbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgfSwgdGhpcy5jb25maWcubWluRHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb25DbGVhbnVwKCgpID0+IGNsZWFyVGltZW91dChjb21wbGV0ZVRpbWVvdXQpKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHN0YW5kYWxvbmU6IHRydWUsXHJcbiAgc2VsZWN0b3I6ICduZy1wcm9ncmVzc1tuZ1Byb2dyZXNzUm91dGVyXSdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3NSb3V0ZXIgZXh0ZW5kcyBOZ1Byb2dyZXNzUm91dGVyQmFzZSB7XHJcbn1cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHN0YW5kYWxvbmU6IHRydWUsXHJcbiAgc2VsZWN0b3I6ICdbbmdQcm9ncmVzc1JvdXRlcl06bm90KG5nLXByb2dyZXNzKScsXHJcbiAgaG9zdERpcmVjdGl2ZXM6IFtOZ1Byb2dyZXNzUmVmXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc1JvdXRlclJlZiBleHRlbmRzIE5nUHJvZ3Jlc3NSb3V0ZXJCYXNlIHtcclxufVxyXG4iXX0=