/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Input } from '@angular/core';
import * as d3 from 'd3';
import { Colors } from '@ngx-chart/common';
import { CircularGraphs } from './circular-graphs.class';
/**
 * @abstract
 */
var DoughnutGraph = /** @class */ (function (_super) {
    tslib_1.__extends(DoughnutGraph, _super);
    function DoughnutGraph() {
        return _super.call(this) || this;
    }
    /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param data array of values
     * @returns Array
     */
    /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param {?} data array of values
     * @return {?} Array
     */
    DoughnutGraph.prototype.scaleData = /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param {?} data array of values
     * @return {?} Array
     */
    function (data) {
        /** @type {?} */
        var sumData = data.reduce((/**
         * @param {?} prev
         * @param {?} curr
         * @return {?}
         */
        function (prev, curr) {
            return prev + curr;
        }));
        /** @type {?} */
        var interValue = d3.scaleLinear()
            .domain([0, sumData])
            .range([0, 100]);
        return data.map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return interValue(value); }));
    };
    /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @returns Doughnut['colors']
     */
    /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @return {?} Doughnut['colors']
     */
    DoughnutGraph.prototype.checkGraphDataColors = /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @return {?} Doughnut['colors']
     */
    function () {
        /** @type {?} */
        var colors = new Colors();
        return this.graphData.colors
            ? this.graphData.colors.length === this.graphData.values.length
                ? this.graphData.colors
                : tslib_1.__spread(this.graphData.colors, colors.generateRandomPallete(this.graphData.values.length - this.graphData.colors.length || 0))
            : colors.generateRandomPallete(this.graphData.values.length);
    };
    /**
     * drawSegment
     *
     * Draw circular segment
     * @param startAngle start angle of arc
     * @param endAngle end angle of arc
     * @param idx index of arc
     */
    /**
     * drawSegment
     *
     * Draw circular segment
     * @param {?} startAngle start angle of arc
     * @param {?} endAngle end angle of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    DoughnutGraph.prototype.drawSegment = /**
     * drawSegment
     *
     * Draw circular segment
     * @param {?} startAngle start angle of arc
     * @param {?} endAngle end angle of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    function (startAngle, endAngle, idx) {
        /** @type {?} */
        var currenData = {
            id: this.graphElement.uid + "__" + idx,
            radius: this.minSize / 2,
            startAngle: startAngle,
            endAngle: endAngle,
            color: this.graphData.colors[idx],
            padding: this.graphData.padding
        };
        /** @type {?} */
        var arc = this.drawCircle(currenData, this.graphElement);
        if (this.graphData.labels && this.graphData.labels.position === 'internal') {
            this.appendIntLabels(this.graphElement.uid + "__" + idx, arc.centroid(), idx);
        }
        if (this.graphData.labels && this.graphData.labels.position === 'external') {
            this.appendExtLabels(currenData, this.graphElement.uid + "__" + idx, arc.centroid(), idx);
        }
    };
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param arcId arc id
     * @param centro center of arc
     * @param idx index of arc
     */
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    DoughnutGraph.prototype.appendIntLabels = /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    function (arcId, centro, idx) {
        this.graphElement.svgContainer
            .select("#" + arcId)
            .append('text')
            .attr('x', centro[0])
            .attr('y', centro[1])
            .attr('dy', '0.33em')
            .attr('dx', '-0.33em')
            .style('fill', 'white')
            .text(this.graphData.labels.titles[idx]);
    };
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param arcId arc id
     * @param centro center of arc
     * @param idx index of arc
     */
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} data
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    DoughnutGraph.prototype.appendExtLabels = /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} data
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    function (data, arcId, centro, idx) {
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateEdgePos(dataArc) {
            /** @type {?} */
            var edgeCircle = d3.arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return edgeCircle.centroid();
        }
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateExternalPos(dataArc) {
            /** @type {?} */
            var extCircle = d3.arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius + 20)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return extCircle.centroid();
        }
        /** @type {?} */
        var edgeCentro = calculateEdgePos.call(this, data);
        /** @type {?} */
        var extCentro = calculateExternalPos.call(this, data);
        /** @type {?} */
        var paddingHorizontalLabel = extCentro[0] >= 0 ? extCentro[0] + 4 : extCentro[0] - 4;
        /** @type {?} */
        var paddingVerticalLabel = extCentro[1] + 4;
        // Draw line
        this.graphElement.svgContainer
            .select("#" + arcId)
            .append('line')
            .style('stroke', 'black')
            .style('opacity', .7)
            .attr('x1', edgeCentro[0])
            .attr('y1', edgeCentro[1])
            .attr('x2', extCentro[0])
            .attr('y2', extCentro[1]);
        this.graphElement.svgContainer
            .select("#" + arcId)
            .append('text')
            .attr('text-anchor', (/**
         * @return {?}
         */
        function () { return extCentro[0] > 0 ? 'start' : 'end'; }))
            .attr('transform', "translate(" + paddingHorizontalLabel + ", " + paddingVerticalLabel + ")")
            .text(this.graphData.labels.titles[idx]);
    };
    DoughnutGraph.propDecorators = {
        graphData: [{ type: Input }]
    };
    return DoughnutGraph;
}(CircularGraphs));
export { DoughnutGraph };
if (false) {
    /** @type {?} */
    DoughnutGraph.prototype.graphData;
    /**
     * @type {?}
     * @protected
     */
    DoughnutGraph.prototype.graphElement;
    /**
     * @type {?}
     * @protected
     */
    DoughnutGraph.prototype.minSize;
    /**
     * @type {?}
     * @protected
     */
    DoughnutGraph.prototype.segmentsDegree;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG91Z2hudXQuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4LWNoYXJ0L2RvdWdobnV0LyIsInNvdXJjZXMiOlsibGliL2RvdWdobnV0LmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdEMsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7OztBQUt6RDtJQUE0Qyx5Q0FBYztJQVF4RDtlQUNFLGlCQUFPO0lBQ1QsQ0FBQztJQUdEOzs7Ozs7T0FNRzs7Ozs7Ozs7SUFDSCxpQ0FBUzs7Ozs7OztJQUFULFVBQVUsSUFBbUI7O1lBQ3JCLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTTs7Ozs7UUFBRSxVQUFDLElBQUksRUFBRSxJQUFJO1lBQ3RDLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNyQixDQUFDLEVBQUM7O1lBRUksVUFBVSxHQUFHLEVBQUUsQ0FBQyxXQUFXLEVBQUU7YUFDaEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ3BCLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVsQixPQUFPLElBQUksQ0FBQyxHQUFHOzs7O1FBQUUsVUFBQSxLQUFLLElBQUksT0FBQSxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQWpCLENBQWlCLEVBQUMsQ0FBQztJQUMvQyxDQUFDO0lBSUQ7Ozs7OztPQU1HOzs7Ozs7OztJQUNILDRDQUFvQjs7Ozs7OztJQUFwQjs7WUFDUSxNQUFNLEdBQUcsSUFBSSxNQUFNLEVBQUU7UUFDM0IsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU07WUFDMUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENB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QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IENvbG9ycyB9IGZyb20gJ0BuZ3gtY2hhcnQvY29tbW9uJztcbmltcG9ydCB7IENpcmN1bGFyR3JhcGhzIH0gZnJvbSAnLi9jaXJjdWxhci1ncmFwaHMuY2xhc3MnO1xuXG5pbXBvcnQgeyBEb3VnaG51dCB9IGZyb20gJy4vaURvdWdobnV0JztcbmltcG9ydCB7IENpcmN1bGFyR3JhcGggfSBmcm9tICcuL2lDaXJjdWxhci1ncmFwaHMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRG91Z2hudXRHcmFwaCBleHRlbmRzIENpcmN1bGFyR3JhcGhzIHtcblxuICBASW5wdXQoKSBncmFwaERhdGE6IERvdWdobnV0O1xuXG4gIHByb3RlY3RlZCBncmFwaEVsZW1lbnQ7XG4gIHByb3RlY3RlZCBtaW5TaXplOiBudW1iZXI7XG4gIHByb3RlY3RlZCBzZWdtZW50c0RlZ3JlZTogQXJyYXk8bnVtYmVyPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cblxuICAvKipcbiAgICogc2NhbGVEYXRhXG4gICAqXG4gICAqIENvbnZlcnQgdGhlIGRhdGEgdmFsdWVzIHRvIGFycmF5IG9mIHZhbHVlcyBpbiBwZXJjZW50YWdlIHNjYWxlXG4gICAqIEBwYXJhbSBkYXRhIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAcmV0dXJucyBBcnJheVxuICAgKi9cbiAgc2NhbGVEYXRhKGRhdGE6IEFycmF5PG51bWJlcj4pOiBBcnJheTxudW1iZXI+IHtcbiAgICBjb25zdCBzdW1EYXRhID0gZGF0YS5yZWR1Y2UoIChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICByZXR1cm4gcHJldiArIGN1cnI7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnRlclZhbHVlID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgc3VtRGF0YV0pXG4gICAgICAucmFuZ2UoWzAsIDEwMF0pO1xuXG4gICAgcmV0dXJuIGRhdGEubWFwKCB2YWx1ZSA9PiBpbnRlclZhbHVlKHZhbHVlKSk7XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIGNoZWNrR3JhcGhEYXRhQ29sb3JzXG4gICAqXG4gICAqXG4gICAqIENoZWNrIGlmIHRoZSBudW1iZXIgb2YgY29sb3JzIGlzIHRoZSBzYW1lIGluIHRoZSB2YWx1ZXMuIElmIGl0IGlzIGRpZmZlcmVudCwgaXQgZ2VuZXJhdGVzIGEgcmFuZG9tIGNvbG9yIHBhbGV0dGVcbiAgICogQHJldHVybnMgRG91Z2hudXRbJ2NvbG9ycyddXG4gICAqL1xuICBjaGVja0dyYXBoRGF0YUNvbG9ycygpOiBEb3VnaG51dFsnY29sb3JzJ10ge1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBDb2xvcnMoKTtcbiAgICByZXR1cm4gdGhpcy5ncmFwaERhdGEuY29sb3JzXG4gICAgICA/IHRoaXMuZ3JhcGhEYXRhLmNvbG9ycy5sZW5ndGggPT09IHRoaXMuZ3JhcGhEYXRhLnZhbHVlcy5sZW5ndGhcbiAgICAgICAgPyB0aGlzLmdyYXBoRGF0YS5jb2xvcnNcbiAgICAgICAgOiBbLi4udGhpcy5ncmFwaERhdGEuY29sb3JzLCAuLi5jb2xvcnMuZ2VuZXJhdGVSYW5kb21QYWxsZXRlKHRoaXMuZ3JhcGhEYXRhLnZhbHVlcy5sZW5ndGggLSB0aGlzLmdyYXBoRGF0YS5jb2xvcnMubGVuZ3RoIHx8IDAgKV1cbiAgICAgIDogY29sb3JzLmdlbmVyYXRlUmFuZG9tUGFsbGV0ZSh0aGlzLmdyYXBoRGF0YS52YWx1ZXMubGVuZ3RoKTtcbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBkcmF3U2VnbWVudFxuICAgKlxuICAgKiBEcmF3IGNpcmN1bGFyIHNlZ21lbnRcbiAgICogQHBhcmFtIHN0YXJ0QW5nbGUgc3RhcnQgYW5nbGUgb2YgYXJjXG4gICAqIEBwYXJhbSBlbmRBbmdsZSBlbmQgYW5nbGUgb2YgYXJjXG4gICAqIEBwYXJhbSBpZHggaW5kZXggb2YgYXJjXG4gICAqL1xuICBkcmF3U2VnbWVudChzdGFydEFuZ2xlOiBudW1iZXIsIGVuZEFuZ2xlOiBudW1iZXIsIGlkeDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVuRGF0YSA9IHtcbiAgICAgIGlkOiBgJHt0aGlzLmdyYXBoRWxlbWVudC51aWR9X18ke2lkeH1gLFxuICAgICAgcmFkaXVzOiB0aGlzLm1pblNpemUgLyAyLFxuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgY29sb3I6IHRoaXMuZ3JhcGhEYXRhLmNvbG9yc1tpZHhdLFxuICAgICAgcGFkZGluZzogdGhpcy5ncmFwaERhdGEucGFkZGluZ1xuICAgIH07XG5cbiAgICBjb25zdCBhcmMgPSB0aGlzLmRyYXdDaXJjbGUoY3VycmVuRGF0YSwgdGhpcy5ncmFwaEVsZW1lbnQpO1xuXG4gICAgaWYgKCB0aGlzLmdyYXBoRGF0YS5sYWJlbHMgJiYgdGhpcy5ncmFwaERhdGEubGFiZWxzLnBvc2l0aW9uID09PSAnaW50ZXJuYWwnKSB7XG4gICAgICB0aGlzLmFwcGVuZEludExhYmVscyhgJHt0aGlzLmdyYXBoRWxlbWVudC51aWR9X18ke2lkeH1gLCBhcmMuY2VudHJvaWQoKSwgaWR4KTtcbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuZ3JhcGhEYXRhLmxhYmVscyAmJiB0aGlzLmdyYXBoRGF0YS5sYWJlbHMucG9zaXRpb24gPT09ICdleHRlcm5hbCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kRXh0TGFiZWxzKGN1cnJlbkRhdGEsIGAke3RoaXMuZ3JhcGhFbGVtZW50LnVpZH1fXyR7aWR4fWAsIGFyYy5jZW50cm9pZCgpLCBpZHgpO1xuICAgIH1cbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBhcHBlbmRFeHRMYWJlbHNcbiAgICpcbiAgICogQXBwZW5kIGV4dGVybmFsIGxhYmVsc1xuICAgKiBAcGFyYW0gYXJjSWQgYXJjIGlkXG4gICAqIEBwYXJhbSBjZW50cm8gY2VudGVyIG9mIGFyY1xuICAgKiBAcGFyYW0gaWR4IGluZGV4IG9mIGFyY1xuICAgKi9cbiAgYXBwZW5kSW50TGFiZWxzKGFyY0lkOiBzdHJpbmcsIGNlbnRybzogQXJyYXk8bnVtYmVyPiwgaWR4OiBudW1iZXIpOiB2b2lkIHtcblxuICAgIHRoaXMuZ3JhcGhFbGVtZW50LnN2Z0NvbnRhaW5lclxuICAgICAgLnNlbGVjdChgIyR7YXJjSWR9YClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5hdHRyKCd4JywgY2VudHJvWzBdKVxuICAgICAgICAuYXR0cigneScsIGNlbnRyb1sxXSlcbiAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzNlbScpXG4gICAgICAgIC5hdHRyKCdkeCcsICctMC4zM2VtJylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcbiAgICAgICAgLnRleHQodGhpcy5ncmFwaERhdGEubGFiZWxzLnRpdGxlc1tpZHhdKTtcbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBhcHBlbmRFeHRMYWJlbHNcbiAgICpcbiAgICogQXBwZW5kIGV4dGVybmFsIGxhYmVsc1xuICAgKiBAcGFyYW0gYXJjSWQgYXJjIGlkXG4gICAqIEBwYXJhbSBjZW50cm8gY2VudGVyIG9mIGFyY1xuICAgKiBAcGFyYW0gaWR4IGluZGV4IG9mIGFyY1xuICAgKi9cbiAgYXBwZW5kRXh0TGFiZWxzKGRhdGE6IENpcmN1bGFyR3JhcGgsIGFyY0lkOiBzdHJpbmcsIGNlbnRybzogQXJyYXk8bnVtYmVyPiwgaWR4OiBudW1iZXIpOiB2b2lkIHtcblxuXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVFeHRlcm5hbFBvc1xuICAgICAqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiBleHRlcm5hbCBwb3MgdG8gZHJhdyBkaWFnb25hbCBsaW5lLlxuICAgICAqIEBwYXJhbSAgZGF0YUFyYyBkYXRhIG9mIGFyY1xuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlRWRnZVBvcyhkYXRhQXJjOiBDaXJjdWxhckdyYXBoKTogQXJyYXk8bnVtYmVyPiB7XG4gICAgICBjb25zdCBlZGdlQ2lyY2xlID0gZDMuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGRhdGFBcmMucmFkaXVzKVxuICAgICAgICAub3V0ZXJSYWRpdXMoZGF0YUFyYy5yYWRpdXMpXG4gICAgICAgIC5zdGFydEFuZ2xlKHRoaXMuY2lyY3VsYXJNZWFzdXJlcy50b1JhZGlhbnMoZGF0YUFyYy5zdGFydEFuZ2xlKSlcbiAgICAgICAgLmVuZEFuZ2xlKHRoaXMuY2lyY3VsYXJNZWFzdXJlcy50b1JhZGlhbnMoZGF0YUFyYy5lbmRBbmdsZSkpO1xuXG4gICAgICByZXR1cm4gZWRnZUNpcmNsZS5jZW50cm9pZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZUV4dGVybmFsUG9zXG4gICAgICpcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIGV4dGVybmFsIHBvcyB0byBkcmF3IGRpYWdvbmFsIGxpbmUuXG4gICAgICogQHBhcmFtICBkYXRhQXJjIGRhdGEgb2YgYXJjXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVFeHRlcm5hbFBvcyhkYXRhQXJjOiBDaXJjdWxhckdyYXBoKTogQXJyYXk8bnVtYmVyPiB7XG4gICAgICBjb25zdCBleHRDaXJjbGUgPSBkMy5hcmMoKVxuICAgICAgICAuaW5uZXJSYWRpdXMoZGF0YUFyYy5yYWRpdXMpXG4gICAgICAgIC5vdXRlclJhZGl1cyhkYXRhQXJjLnJhZGl1cyArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSh0aGlzLmNpcmN1bGFyTWVhc3VyZXMudG9SYWRpYW5zKGRhdGFBcmMuc3RhcnRBbmdsZSkpXG4gICAgICAgIC5lbmRBbmdsZSh0aGlzLmNpcmN1bGFyTWVhc3VyZXMudG9SYWRpYW5zKGRhdGFBcmMuZW5kQW5nbGUpKTtcblxuICAgICAgcmV0dXJuIGV4dENpcmNsZS5jZW50cm9pZCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVkZ2VDZW50cm8gPSBjYWxjdWxhdGVFZGdlUG9zLmNhbGwodGhpcywgZGF0YSk7XG4gICAgY29uc3QgZXh0Q2VudHJvID0gY2FsY3VsYXRlRXh0ZXJuYWxQb3MuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgIGNvbnN0IHBhZGRpbmdIb3Jpem9udGFsTGFiZWwgPSBleHRDZW50cm9bMF0gPj0gMCA/IGV4dENlbnRyb1swXSArIDQgOiBleHRDZW50cm9bMF0gLSA0O1xuICAgIGNvbnN0IHBhZGRpbmdWZXJ0aWNhbExhYmVsID0gZXh0Q2VudHJvWzFdICsgNDtcblxuICAgIC8vIERyYXcgbGluZVxuICAgIHRoaXMuZ3JhcGhFbGVtZW50LnN2Z0NvbnRhaW5lclxuICAgICAgLnNlbGVjdChgIyR7YXJjSWR9YClcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgLjcpXG4gICAgICAgIC5hdHRyKCd4MScsIGVkZ2VDZW50cm9bMF0pXG4gICAgICAgIC5hdHRyKCd5MScsIGVkZ2VDZW50cm9bMV0pXG4gICAgICAgIC5hdHRyKCd4MicsIGV4dENlbnRyb1swXSlcbiAgICAgICAgLmF0dHIoJ3kyJywgZXh0Q2VudHJvWzFdKTtcblxuXG4gICAgdGhpcy5ncmFwaEVsZW1lbnQuc3ZnQ29udGFpbmVyXG4gICAgICAuc2VsZWN0KGAjJHthcmNJZH1gKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgKCkgPT4gZXh0Q2VudHJvWzBdID4gMCA/ICdzdGFydCcgOiAnZW5kJylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtwYWRkaW5nSG9yaXpvbnRhbExhYmVsfSwgJHtwYWRkaW5nVmVydGljYWxMYWJlbH0pYClcbiAgICAgICAgLnRleHQodGhpcy5ncmFwaERhdGEubGFiZWxzLnRpdGxlc1tpZHhdKTtcbiAgfVxuXG59XG4iXX0=