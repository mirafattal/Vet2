/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Input } from '@angular/core';
import * as d3 from 'd3';
import { Colors } from '@ngx-chart/common';
import { CircularGraphs } from './circular-graphs.class';
/**
 * @abstract
 */
export class DoughnutGraph extends CircularGraphs {
    constructor() {
        super();
    }
    /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param {?} data array of values
     * @return {?} Array
     */
    scaleData(data) {
        /** @type {?} */
        const sumData = data.reduce((/**
         * @param {?} prev
         * @param {?} curr
         * @return {?}
         */
        (prev, curr) => {
            return prev + curr;
        }));
        /** @type {?} */
        const interValue = d3.scaleLinear()
            .domain([0, sumData])
            .range([0, 100]);
        return data.map((/**
         * @param {?} value
         * @return {?}
         */
        value => interValue(value)));
    }
    /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @return {?} Doughnut['colors']
     */
    checkGraphDataColors() {
        /** @type {?} */
        const colors = new Colors();
        return this.graphData.colors
            ? this.graphData.colors.length === this.graphData.values.length
                ? this.graphData.colors
                : [...this.graphData.colors, ...colors.generateRandomPallete(this.graphData.values.length - this.graphData.colors.length || 0)]
            : colors.generateRandomPallete(this.graphData.values.length);
    }
    /**
     * drawSegment
     *
     * Draw circular segment
     * @param {?} startAngle start angle of arc
     * @param {?} endAngle end angle of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    drawSegment(startAngle, endAngle, idx) {
        /** @type {?} */
        const currenData = {
            id: `${this.graphElement.uid}__${idx}`,
            radius: this.minSize / 2,
            startAngle,
            endAngle,
            color: this.graphData.colors[idx],
            padding: this.graphData.padding
        };
        /** @type {?} */
        const arc = this.drawCircle(currenData, this.graphElement);
        if (this.graphData.labels && this.graphData.labels.position === 'internal') {
            this.appendIntLabels(`${this.graphElement.uid}__${idx}`, arc.centroid(), idx);
        }
        if (this.graphData.labels && this.graphData.labels.position === 'external') {
            this.appendExtLabels(currenData, `${this.graphElement.uid}__${idx}`, arc.centroid(), idx);
        }
    }
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    appendIntLabels(arcId, centro, idx) {
        this.graphElement.svgContainer
            .select(`#${arcId}`)
            .append('text')
            .attr('x', centro[0])
            .attr('y', centro[1])
            .attr('dy', '0.33em')
            .attr('dx', '-0.33em')
            .style('fill', 'white')
            .text(this.graphData.labels.titles[idx]);
    }
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} data
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    appendExtLabels(data, arcId, centro, idx) {
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateEdgePos(dataArc) {
            /** @type {?} */
            const edgeCircle = d3.arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return edgeCircle.centroid();
        }
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateExternalPos(dataArc) {
            /** @type {?} */
            const extCircle = d3.arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius + 20)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return extCircle.centroid();
        }
        /** @type {?} */
        const edgeCentro = calculateEdgePos.call(this, data);
        /** @type {?} */
        const extCentro = calculateExternalPos.call(this, data);
        /** @type {?} */
        const paddingHorizontalLabel = extCentro[0] >= 0 ? extCentro[0] + 4 : extCentro[0] - 4;
        /** @type {?} */
        const paddingVerticalLabel = extCentro[1] + 4;
        // Draw line
        this.graphElement.svgContainer
            .select(`#${arcId}`)
            .append('line')
            .style('stroke', 'black')
            .style('opacity', .7)
            .attr('x1', edgeCentro[0])
            .attr('y1', edgeCentro[1])
            .attr('x2', extCentro[0])
            .attr('y2', extCentro[1]);
        this.graphElement.svgContainer
            .select(`#${arcId}`)
            .append('text')
            .attr('text-anchor', (/**
         * @return {?}
         */
        () => extCentro[0] > 0 ? 'start' : 'end'))
            .attr('transform', `translate(${paddingHorizontalLabel}, ${paddingVerticalLabel})`)
            .text(this.graphData.labels.titles[idx]);
    }
}
DoughnutGraph.propDecorators = {
    graphData: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DoughnutGraph.prototype.graphData;
    /**
     * @type {?}
     * @protected
     */
    DoughnutGraph.prototype.graphElement;
    /**
     * @type {?}
     * @protected
     */
    DoughnutGraph.prototype.minSize;
    /**
     * @type {?}
     * @protected
     */
    DoughnutGraph.prototype.segmentsDegree;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG91Z2hudXQuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4LWNoYXJ0L2RvdWdobnV0LyIsInNvdXJjZXMiOlsibGliL2RvdWdobnV0LmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV0QyxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7O0FBS3pELE1BQU0sT0FBZ0IsYUFBYyxTQUFRLGNBQWM7SUFReEQ7UUFDRSxLQUFLLEVBQUUsQ0FBQztJQUNWLENBQUM7Ozs7Ozs7O0lBVUQsU0FBUyxDQUFDLElBQW1COztjQUNyQixPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU07Ozs7O1FBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDMUMsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLENBQUMsRUFBQzs7Y0FFSSxVQUFVLEdBQUcsRUFBRSxDQUFDLFdBQVcsRUFBRTthQUNoQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDcEIsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLE9BQU8sSUFBSSxDQUFDLEdBQUc7Ozs7UUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDO0lBQy9DLENBQUM7Ozs7Ozs7O0lBV0Qsb0JBQW9COztjQUNaLE1BQU0sR0FBRyxJQUFJLE1BQU0sRUFBRTtRQUMzQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTTtZQUMxQixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxT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LElBQUksS0FBSyxFQUFFLENBQUM7YUFDakIsTUFBTSxDQUFDLE1BQU0sQ0FBQzthQUNkLEtBQUssQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDO2FBQ3hCLEtBQUssQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDO2FBQ3BCLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3pCLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3pCLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3hCLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFHOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZO2FBQzNCLE1BQU0sQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDO2FBQ2pCLE1BQU0sQ0FBQyxNQUFNLENBQUM7YUFDZCxJQUFJLENBQUMsYUFBYTs7O1FBQUUsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUM7YUFDN0QsSUFBSSxDQUFDLFdBQVcsRUFBRSxhQUFhLHNCQUFzQixLQUFLLG9CQUFvQixHQUFHLENBQUM7YUFDbEYsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9DLENBQUM7Ozt3QkFqTEEsS0FBSzs7OztJQUFOLGtDQUE2Qjs7Ozs7SUFFN0IscUNBQXVCOzs7OztJQUN2QixnQ0FBMEI7Ozs7O0lBQzFCLHVDQUF3QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IENvbG9ycyB9IGZyb20gJ0BuZ3gtY2hhcnQvY29tbW9uJztcbmltcG9ydCB7IENpcmN1bGFyR3JhcGhzIH0gZnJvbSAnLi9jaXJjdWxhci1ncmFwaHMuY2xhc3MnO1xuXG5pbXBvcnQgeyBEb3VnaG51dCB9IGZyb20gJy4vaURvdWdobnV0JztcbmltcG9ydCB7IENpcmN1bGFyR3JhcGggfSBmcm9tICcuL2lDaXJjdWxhci1ncmFwaHMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRG91Z2hudXRHcmFwaCBleHRlbmRzIENpcmN1bGFyR3JhcGhzIHtcblxuICBASW5wdXQoKSBncmFwaERhdGE6IERvdWdobnV0O1xuXG4gIHByb3RlY3RlZCBncmFwaEVsZW1lbnQ7XG4gIHByb3RlY3RlZCBtaW5TaXplOiBudW1iZXI7XG4gIHByb3RlY3RlZCBzZWdtZW50c0RlZ3JlZTogQXJyYXk8bnVtYmVyPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cblxuICAvKipcbiAgICogc2NhbGVEYXRhXG4gICAqXG4gICAqIENvbnZlcnQgdGhlIGRhdGEgdmFsdWVzIHRvIGFycmF5IG9mIHZhbHVlcyBpbiBwZXJjZW50YWdlIHNjYWxlXG4gICAqIEBwYXJhbSBkYXRhIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAcmV0dXJucyBBcnJheVxuICAgKi9cbiAgc2NhbGVEYXRhKGRhdGE6IEFycmF5PG51bWJlcj4pOiBBcnJheTxudW1iZXI+IHtcbiAgICBjb25zdCBzdW1EYXRhID0gZGF0YS5yZWR1Y2UoIChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICByZXR1cm4gcHJldiArIGN1cnI7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnRlclZhbHVlID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgc3VtRGF0YV0pXG4gICAgICAucmFuZ2UoWzAsIDEwMF0pO1xuXG4gICAgcmV0dXJuIGRhdGEubWFwKCB2YWx1ZSA9PiBpbnRlclZhbHVlKHZhbHVlKSk7XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIGNoZWNrR3JhcGhEYXRhQ29sb3JzXG4gICAqXG4gICAqXG4gICAqIENoZWNrIGlmIHRoZSBudW1iZXIgb2YgY29sb3JzIGlzIHRoZSBzYW1lIGluIHRoZSB2YWx1ZXMuIElmIGl0IGlzIGRpZmZlcmVudCwgaXQgZ2VuZXJhdGVzIGEgcmFuZG9tIGNvbG9yIHBhbGV0dGVcbiAgICogQHJldHVybnMgRG91Z2hudXRbJ2NvbG9ycyddXG4gICAqL1xuICBjaGVja0dyYXBoRGF0YUNvbG9ycygpOiBEb3VnaG51dFsnY29sb3JzJ10ge1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBDb2xvcnMoKTtcbiAgICByZXR1cm4gdGhpcy5ncmFwaERhdGEuY29sb3JzXG4gICAgICA/IHRoaXMuZ3JhcGhEYXRhLmNvbG9ycy5sZW5ndGggPT09IHRoaXMuZ3JhcGhEYXRhLnZhbHVlcy5sZW5ndGhcbiAgICAgICAgPyB0aGlzLmdyYXBoRGF0YS5jb2xvcnNcbiAgICAgICAgOiBbLi4udGhpcy5ncmFwaERhdGEuY29sb3JzLCAuLi5jb2xvcnMuZ2VuZXJhdGVSYW5kb21QYWxsZXRlKHRoaXMuZ3JhcGhEYXRhLnZhbHVlcy5sZW5ndGggLSB0aGlzLmdyYXBoRGF0YS5jb2xvcnMubGVuZ3RoIHx8IDAgKV1cbiAgICAgIDogY29sb3JzLmdlbmVyYXRlUmFuZG9tUGFsbGV0ZSh0aGlzLmdyYXBoRGF0YS52YWx1ZXMubGVuZ3RoKTtcbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBkcmF3U2VnbWVudFxuICAgKlxuICAgKiBEcmF3IGNpcmN1bGFyIHNlZ21lbnRcbiAgICogQHBhcmFtIHN0YXJ0QW5nbGUgc3RhcnQgYW5nbGUgb2YgYXJjXG4gICAqIEBwYXJhbSBlbmRBbmdsZSBlbmQgYW5nbGUgb2YgYXJjXG4gICAqIEBwYXJhbSBpZHggaW5kZXggb2YgYXJjXG4gICAqL1xuICBkcmF3U2VnbWVudChzdGFydEFuZ2xlOiBudW1iZXIsIGVuZEFuZ2xlOiBudW1iZXIsIGlkeDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVuRGF0YSA9IHtcbiAgICAgIGlkOiBgJHt0aGlzLmdyYXBoRWxlbWVudC51aWR9X18ke2lkeH1gLFxuICAgICAgcmFkaXVzOiB0aGlzLm1pblNpemUgLyAyLFxuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgY29sb3I6IHRoaXMuZ3JhcGhEYXRhLmNvbG9yc1tpZHhdLFxuICAgICAgcGFkZGluZzogdGhpcy5ncmFwaERhdGEucGFkZGluZ1xuICAgIH07XG5cbiAgICBjb25zdCBhcmMgPSB0aGlzLmRyYXdDaXJjbGUoY3VycmVuRGF0YSwgdGhpcy5ncmFwaEVsZW1lbnQpO1xuXG4gICAgaWYgKCB0aGlzLmdyYXBoRGF0YS5sYWJlbHMgJiYgdGhpcy5ncmFwaERhdGEubGFiZWxzLnBvc2l0aW9uID09PSAnaW50ZXJuYWwnKSB7XG4gICAgICB0aGlzLmFwcGVuZEludExhYmVscyhgJHt0aGlzLmdyYXBoRWxlbWVudC51aWR9X18ke2lkeH1gLCBhcmMuY2VudHJvaWQoKSwgaWR4KTtcbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuZ3JhcGhEYXRhLmxhYmVscyAmJiB0aGlzLmdyYXBoRGF0YS5sYWJlbHMucG9zaXRpb24gPT09ICdleHRlcm5hbCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kRXh0TGFiZWxzKGN1cnJlbkRhdGEsIGAke3RoaXMuZ3JhcGhFbGVtZW50LnVpZH1fXyR7aWR4fWAsIGFyYy5jZW50cm9pZCgpLCBpZHgpO1xuICAgIH1cbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBhcHBlbmRFeHRMYWJlbHNcbiAgICpcbiAgICogQXBwZW5kIGV4dGVybmFsIGxhYmVsc1xuICAgKiBAcGFyYW0gYXJjSWQgYXJjIGlkXG4gICAqIEBwYXJhbSBjZW50cm8gY2VudGVyIG9mIGFyY1xuICAgKiBAcGFyYW0gaWR4IGluZGV4IG9mIGFyY1xuICAgKi9cbiAgYXBwZW5kSW50TGFiZWxzKGFyY0lkOiBzdHJpbmcsIGNlbnRybzogQXJyYXk8bnVtYmVyPiwgaWR4OiBudW1iZXIpOiB2b2lkIHtcblxuICAgIHRoaXMuZ3JhcGhFbGVtZW50LnN2Z0NvbnRhaW5lclxuICAgICAgLnNlbGVjdChgIyR7YXJjSWR9YClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5hdHRyKCd4JywgY2VudHJvWzBdKVxuICAgICAgICAuYXR0cigneScsIGNlbnRyb1sxXSlcbiAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzNlbScpXG4gICAgICAgIC5hdHRyKCdkeCcsICctMC4zM2VtJylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcbiAgICAgICAgLnRleHQodGhpcy5ncmFwaERhdGEubGFiZWxzLnRpdGxlc1tpZHhdKTtcbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBhcHBlbmRFeHRMYWJlbHNcbiAgICpcbiAgICogQXBwZW5kIGV4dGVybmFsIGxhYmVsc1xuICAgKiBAcGFyYW0gYXJjSWQgYXJjIGlkXG4gICAqIEBwYXJhbSBjZW50cm8gY2VudGVyIG9mIGFyY1xuICAgKiBAcGFyYW0gaWR4IGluZGV4IG9mIGFyY1xuICAgKi9cbiAgYXBwZW5kRXh0TGFiZWxzKGRhdGE6IENpcmN1bGFyR3JhcGgsIGFyY0lkOiBzdHJpbmcsIGNlbnRybzogQXJyYXk8bnVtYmVyPiwgaWR4OiBudW1iZXIpOiB2b2lkIHtcblxuXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVFeHRlcm5hbFBvc1xuICAgICAqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiBleHRlcm5hbCBwb3MgdG8gZHJhdyBkaWFnb25hbCBsaW5lLlxuICAgICAqIEBwYXJhbSAgZGF0YUFyYyBkYXRhIG9mIGFyY1xuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlRWRnZVBvcyhkYXRhQXJjOiBDaXJjdWxhckdyYXBoKTogQXJyYXk8bnVtYmVyPiB7XG4gICAgICBjb25zdCBlZGdlQ2lyY2xlID0gZDMuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGRhdGFBcmMucmFkaXVzKVxuICAgICAgICAub3V0ZXJSYWRpdXMoZGF0YUFyYy5yYWRpdXMpXG4gICAgICAgIC5zdGFydEFuZ2xlKHRoaXMuY2lyY3VsYXJNZWFzdXJlcy50b1JhZGlhbnMoZGF0YUFyYy5zdGFydEFuZ2xlKSlcbiAgICAgICAgLmVuZEFuZ2xlKHRoaXMuY2lyY3VsYXJNZWFzdXJlcy50b1JhZGlhbnMoZGF0YUFyYy5lbmRBbmdsZSkpO1xuXG4gICAgICByZXR1cm4gZWRnZUNpcmNsZS5jZW50cm9pZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZUV4dGVybmFsUG9zXG4gICAgICpcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIGV4dGVybmFsIHBvcyB0byBkcmF3IGRpYWdvbmFsIGxpbmUuXG4gICAgICogQHBhcmFtICBkYXRhQXJjIGRhdGEgb2YgYXJjXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVFeHRlcm5hbFBvcyhkYXRhQXJjOiBDaXJjdWxhckdyYXBoKTogQXJyYXk8bnVtYmVyPiB7XG4gICAgICBjb25zdCBleHRDaXJjbGUgPSBkMy5hcmMoKVxuICAgICAgICAuaW5uZXJSYWRpdXMoZGF0YUFyYy5yYWRpdXMpXG4gICAgICAgIC5vdXRlclJhZGl1cyhkYXRhQXJjLnJhZGl1cyArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSh0aGlzLmNpcmN1bGFyTWVhc3VyZXMudG9SYWRpYW5zKGRhdGFBcmMuc3RhcnRBbmdsZSkpXG4gICAgICAgIC5lbmRBbmdsZSh0aGlzLmNpcmN1bGFyTWVhc3VyZXMudG9SYWRpYW5zKGRhdGFBcmMuZW5kQW5nbGUpKTtcblxuICAgICAgcmV0dXJuIGV4dENpcmNsZS5jZW50cm9pZCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVkZ2VDZW50cm8gPSBjYWxjdWxhdGVFZGdlUG9zLmNhbGwodGhpcywgZGF0YSk7XG4gICAgY29uc3QgZXh0Q2VudHJvID0gY2FsY3VsYXRlRXh0ZXJuYWxQb3MuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgIGNvbnN0IHBhZGRpbmdIb3Jpem9udGFsTGFiZWwgPSBleHRDZW50cm9bMF0gPj0gMCA/IGV4dENlbnRyb1swXSArIDQgOiBleHRDZW50cm9bMF0gLSA0O1xuICAgIGNvbnN0IHBhZGRpbmdWZXJ0aWNhbExhYmVsID0gZXh0Q2VudHJvWzFdICsgNDtcblxuICAgIC8vIERyYXcgbGluZVxuICAgIHRoaXMuZ3JhcGhFbGVtZW50LnN2Z0NvbnRhaW5lclxuICAgICAgLnNlbGVjdChgIyR7YXJjSWR9YClcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgLjcpXG4gICAgICAgIC5hdHRyKCd4MScsIGVkZ2VDZW50cm9bMF0pXG4gICAgICAgIC5hdHRyKCd5MScsIGVkZ2VDZW50cm9bMV0pXG4gICAgICAgIC5hdHRyKCd4MicsIGV4dENlbnRyb1swXSlcbiAgICAgICAgLmF0dHIoJ3kyJywgZXh0Q2VudHJvWzFdKTtcblxuXG4gICAgdGhpcy5ncmFwaEVsZW1lbnQuc3ZnQ29udGFpbmVyXG4gICAgICAuc2VsZWN0KGAjJHthcmNJZH1gKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgKCkgPT4gZXh0Q2VudHJvWzBdID4gMCA/ICdzdGFydCcgOiAnZW5kJylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtwYWRkaW5nSG9yaXpvbnRhbExhYmVsfSwgJHtwYWRkaW5nVmVydGljYWxMYWJlbH0pYClcbiAgICAgICAgLnRleHQodGhpcy5ncmFwaERhdGEubGFiZWxzLnRpdGxlc1tpZHhdKTtcbiAgfVxuXG59XG4iXX0=