import { arc, scaleLinear, select } from 'd3';
import { CircularMeasures, Colors, WrapperComponentD3 } from '@ngx-chart/common';
import { Input, Component, ElementRef, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/circular-graphs.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CircularGraphs {
    constructor() {
        this.circularMeasures = new CircularMeasures();
    }
    /**
     * drawCircle
     *
     * Draw Circle
     * @param {?} data
     * @param {?} graphElement
     * @return {?}
     */
    drawCircle(data, graphElement) {
        data = this.defaultValues(data);
        /** @type {?} */
        const circle = arc()
            .innerRadius(data.radius * 3 / 5)
            .outerRadius(data.radius)
            .startAngle(this.circularMeasures.toRadians(data.startAngle))
            .endAngle(this.circularMeasures.toRadians(data.endAngle))
            .padAngle((/**
         * @return {?}
         */
        () => data.padding ? 0.03 : 0));
        graphElement.svgContainer
            .append('g')
            // Center of wrapper
            .attr('transform', `translate(${graphElement.width / 2}, ${graphElement.height / 2})`)
            .attr('id', data.id)
            .append('path')
            .attr('fill', data.color)
            .style('opacity', data.opacity)
            .attr('d', circle);
        return circle;
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    defaultValues(data) {
        data.opacity = !data.opacity ? 1 : data.opacity;
        return data;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class DoughnutGraph extends CircularGraphs {
    constructor() {
        super();
    }
    /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param {?} data array of values
     * @return {?} Array
     */
    scaleData(data) {
        /** @type {?} */
        const sumData = data.reduce((/**
         * @param {?} prev
         * @param {?} curr
         * @return {?}
         */
        (prev, curr) => {
            return prev + curr;
        }));
        /** @type {?} */
        const interValue = scaleLinear()
            .domain([0, sumData])
            .range([0, 100]);
        return data.map((/**
         * @param {?} value
         * @return {?}
         */
        value => interValue(value)));
    }
    /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @return {?} Doughnut['colors']
     */
    checkGraphDataColors() {
        /** @type {?} */
        const colors = new Colors();
        return this.graphData.colors
            ? this.graphData.colors.length === this.graphData.values.length
                ? this.graphData.colors
                : [...this.graphData.colors, ...colors.generateRandomPallete(this.graphData.values.length - this.graphData.colors.length || 0)]
            : colors.generateRandomPallete(this.graphData.values.length);
    }
    /**
     * drawSegment
     *
     * Draw circular segment
     * @param {?} startAngle start angle of arc
     * @param {?} endAngle end angle of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    drawSegment(startAngle, endAngle, idx) {
        /** @type {?} */
        const currenData = {
            id: `${this.graphElement.uid}__${idx}`,
            radius: this.minSize / 2,
            startAngle,
            endAngle,
            color: this.graphData.colors[idx],
            padding: this.graphData.padding
        };
        /** @type {?} */
        const arc$$1 = this.drawCircle(currenData, this.graphElement);
        if (this.graphData.labels && this.graphData.labels.position === 'internal') {
            this.appendIntLabels(`${this.graphElement.uid}__${idx}`, arc$$1.centroid(), idx);
        }
        if (this.graphData.labels && this.graphData.labels.position === 'external') {
            this.appendExtLabels(currenData, `${this.graphElement.uid}__${idx}`, arc$$1.centroid(), idx);
        }
    }
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    appendIntLabels(arcId, centro, idx) {
        this.graphElement.svgContainer
            .select(`#${arcId}`)
            .append('text')
            .attr('x', centro[0])
            .attr('y', centro[1])
            .attr('dy', '0.33em')
            .attr('dx', '-0.33em')
            .style('fill', 'white')
            .text(this.graphData.labels.titles[idx]);
    }
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} data
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    appendExtLabels(data, arcId, centro, idx) {
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateEdgePos(dataArc) {
            /** @type {?} */
            const edgeCircle = arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return edgeCircle.centroid();
        }
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateExternalPos(dataArc) {
            /** @type {?} */
            const extCircle = arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius + 20)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return extCircle.centroid();
        }
        /** @type {?} */
        const edgeCentro = calculateEdgePos.call(this, data);
        /** @type {?} */
        const extCentro = calculateExternalPos.call(this, data);
        /** @type {?} */
        const paddingHorizontalLabel = extCentro[0] >= 0 ? extCentro[0] + 4 : extCentro[0] - 4;
        /** @type {?} */
        const paddingVerticalLabel = extCentro[1] + 4;
        // Draw line
        this.graphElement.svgContainer
            .select(`#${arcId}`)
            .append('line')
            .style('stroke', 'black')
            .style('opacity', .7)
            .attr('x1', edgeCentro[0])
            .attr('y1', edgeCentro[1])
            .attr('x2', extCentro[0])
            .attr('y2', extCentro[1]);
        this.graphElement.svgContainer
            .select(`#${arcId}`)
            .append('text')
            .attr('text-anchor', (/**
         * @return {?}
         */
        () => extCentro[0] > 0 ? 'start' : 'end'))
            .attr('transform', `translate(${paddingHorizontalLabel}, ${paddingVerticalLabel})`)
            .text(this.graphData.labels.titles[idx]);
    }
}
DoughnutGraph.propDecorators = {
    graphData: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut-graph.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DoughnutGraphComponent extends DoughnutGraph {
    /**
     * @param {?} elementRef
     * @param {?} circularMeasures
     */
    constructor(elementRef, circularMeasures) {
        super();
        this.elementRef = elementRef;
        this.circularMeasures = circularMeasures;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Remove previous graphs
        if (changes.graphData.previousValue) {
            select(`#svg-${this.currentElementId}`).remove();
        }
        this.graphElement = new WrapperComponentD3(this.elementRef);
        this.currentElementId = this.graphElement.uid;
        this.minSize = this.circularMeasures.calcRadius(this.graphElement.width, this.graphElement.height);
        // If graph has labels and the position of if are extenal reduce radius in 25 points.
        this.minSize = this.graphData.labels && this.graphData.labels.position === 'external'
            ? this.minSize - 25
            : this.minSize;
        this.segmentsDegree = this.scaleData(this.graphData.values).map((/**
         * @param {?} value
         * @return {?}
         */
        value => this.circularMeasures.arcValue(value)));
        this.graphData.colors = this.checkGraphDataColors();
        this.segmentsDegree.map((/**
         * @param {?} arc
         * @param {?} idx
         * @return {?}
         */
        (arc$$1, idx) => {
            /** @type {?} */
            const startAngle = idx === 0
                ? 0
                : this.segmentsDegree.slice(0, idx).reduce((/**
                 * @param {?} curr
                 * @param {?} prev
                 * @return {?}
                 */
                (curr, prev) => curr + prev));
            /** @type {?} */
            const endAngle = idx === this.segmentsDegree.length
                ? 360
                : this.segmentsDegree.slice(0, idx + 1).reduce((/**
                 * @param {?} curr
                 * @param {?} prev
                 * @return {?}
                 */
                (curr, prev) => curr + prev));
            this.drawSegment(startAngle, endAngle, idx);
        }));
    }
}
DoughnutGraphComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngl-doughnut',
                template: ``,
                providers: [
                    CircularMeasures
                ]
            }] }
];
/** @nocollapse */
DoughnutGraphComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CircularMeasures }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut-graph.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DoughnutGraphModule {
}
DoughnutGraphModule.decorators = [
    { type: NgModule, args: [{
                declarations: [DoughnutGraphComponent],
                imports: [],
                exports: [DoughnutGraphComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-chart-doughnut.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DoughnutGraphComponent, DoughnutGraphModule, CircularGraphs as ɵb, DoughnutGraph as ɵa };

//# sourceMappingURL=ngx-chart-doughnut.js.map