import { __extends, __spread } from 'tslib';
import { arc, scaleLinear, select } from 'd3';
import { CircularMeasures, Colors, WrapperComponentD3 } from '@ngx-chart/common';
import { Input, Component, ElementRef, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/circular-graphs.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
CircularGraphs = /** @class */ (function () {
    function CircularGraphs() {
        this.circularMeasures = new CircularMeasures();
    }
    /**
     * drawCircle
     *
     * Draw Circle
     */
    /**
     * drawCircle
     *
     * Draw Circle
     * @param {?} data
     * @param {?} graphElement
     * @return {?}
     */
    CircularGraphs.prototype.drawCircle = /**
     * drawCircle
     *
     * Draw Circle
     * @param {?} data
     * @param {?} graphElement
     * @return {?}
     */
    function (data, graphElement) {
        data = this.defaultValues(data);
        /** @type {?} */
        var circle = arc()
            .innerRadius(data.radius * 3 / 5)
            .outerRadius(data.radius)
            .startAngle(this.circularMeasures.toRadians(data.startAngle))
            .endAngle(this.circularMeasures.toRadians(data.endAngle))
            .padAngle((/**
         * @return {?}
         */
        function () { return data.padding ? 0.03 : 0; }));
        graphElement.svgContainer
            .append('g')
            // Center of wrapper
            .attr('transform', "translate(" + graphElement.width / 2 + ", " + graphElement.height / 2 + ")")
            .attr('id', data.id)
            .append('path')
            .attr('fill', data.color)
            .style('opacity', data.opacity)
            .attr('d', circle);
        return circle;
    };
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    CircularGraphs.prototype.defaultValues = /**
     * @private
     * @param {?} data
     * @return {?}
     */
    function (data) {
        data.opacity = !data.opacity ? 1 : data.opacity;
        return data;
    };
    return CircularGraphs;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var DoughnutGraph = /** @class */ (function (_super) {
    __extends(DoughnutGraph, _super);
    function DoughnutGraph() {
        return _super.call(this) || this;
    }
    /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param data array of values
     * @returns Array
     */
    /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param {?} data array of values
     * @return {?} Array
     */
    DoughnutGraph.prototype.scaleData = /**
     * scaleData
     *
     * Convert the data values to array of values in percentage scale
     * @param {?} data array of values
     * @return {?} Array
     */
    function (data) {
        /** @type {?} */
        var sumData = data.reduce((/**
         * @param {?} prev
         * @param {?} curr
         * @return {?}
         */
        function (prev, curr) {
            return prev + curr;
        }));
        /** @type {?} */
        var interValue = scaleLinear()
            .domain([0, sumData])
            .range([0, 100]);
        return data.map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return interValue(value); }));
    };
    /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @returns Doughnut['colors']
     */
    /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @return {?} Doughnut['colors']
     */
    DoughnutGraph.prototype.checkGraphDataColors = /**
     * checkGraphDataColors
     *
     *
     * Check if the number of colors is the same in the values. If it is different, it generates a random color palette
     * @return {?} Doughnut['colors']
     */
    function () {
        /** @type {?} */
        var colors = new Colors();
        return this.graphData.colors
            ? this.graphData.colors.length === this.graphData.values.length
                ? this.graphData.colors
                : __spread(this.graphData.colors, colors.generateRandomPallete(this.graphData.values.length - this.graphData.colors.length || 0))
            : colors.generateRandomPallete(this.graphData.values.length);
    };
    /**
     * drawSegment
     *
     * Draw circular segment
     * @param startAngle start angle of arc
     * @param endAngle end angle of arc
     * @param idx index of arc
     */
    /**
     * drawSegment
     *
     * Draw circular segment
     * @param {?} startAngle start angle of arc
     * @param {?} endAngle end angle of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    DoughnutGraph.prototype.drawSegment = /**
     * drawSegment
     *
     * Draw circular segment
     * @param {?} startAngle start angle of arc
     * @param {?} endAngle end angle of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    function (startAngle, endAngle, idx) {
        /** @type {?} */
        var currenData = {
            id: this.graphElement.uid + "__" + idx,
            radius: this.minSize / 2,
            startAngle: startAngle,
            endAngle: endAngle,
            color: this.graphData.colors[idx],
            padding: this.graphData.padding
        };
        /** @type {?} */
        var arc$$1 = this.drawCircle(currenData, this.graphElement);
        if (this.graphData.labels && this.graphData.labels.position === 'internal') {
            this.appendIntLabels(this.graphElement.uid + "__" + idx, arc$$1.centroid(), idx);
        }
        if (this.graphData.labels && this.graphData.labels.position === 'external') {
            this.appendExtLabels(currenData, this.graphElement.uid + "__" + idx, arc$$1.centroid(), idx);
        }
    };
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param arcId arc id
     * @param centro center of arc
     * @param idx index of arc
     */
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    DoughnutGraph.prototype.appendIntLabels = /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    function (arcId, centro, idx) {
        this.graphElement.svgContainer
            .select("#" + arcId)
            .append('text')
            .attr('x', centro[0])
            .attr('y', centro[1])
            .attr('dy', '0.33em')
            .attr('dx', '-0.33em')
            .style('fill', 'white')
            .text(this.graphData.labels.titles[idx]);
    };
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param arcId arc id
     * @param centro center of arc
     * @param idx index of arc
     */
    /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} data
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    DoughnutGraph.prototype.appendExtLabels = /**
     * appendExtLabels
     *
     * Append external labels
     * @param {?} data
     * @param {?} arcId arc id
     * @param {?} centro center of arc
     * @param {?} idx index of arc
     * @return {?}
     */
    function (data, arcId, centro, idx) {
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateEdgePos(dataArc) {
            /** @type {?} */
            var edgeCircle = arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return edgeCircle.centroid();
        }
        /**
         * calculateExternalPos
         *
         * Calculate the position of external pos to draw diagonal line.
         * @param {?} dataArc data of arc
         * @return {?} Array
         */
        function calculateExternalPos(dataArc) {
            /** @type {?} */
            var extCircle = arc()
                .innerRadius(dataArc.radius)
                .outerRadius(dataArc.radius + 20)
                .startAngle(this.circularMeasures.toRadians(dataArc.startAngle))
                .endAngle(this.circularMeasures.toRadians(dataArc.endAngle));
            return extCircle.centroid();
        }
        /** @type {?} */
        var edgeCentro = calculateEdgePos.call(this, data);
        /** @type {?} */
        var extCentro = calculateExternalPos.call(this, data);
        /** @type {?} */
        var paddingHorizontalLabel = extCentro[0] >= 0 ? extCentro[0] + 4 : extCentro[0] - 4;
        /** @type {?} */
        var paddingVerticalLabel = extCentro[1] + 4;
        // Draw line
        this.graphElement.svgContainer
            .select("#" + arcId)
            .append('line')
            .style('stroke', 'black')
            .style('opacity', .7)
            .attr('x1', edgeCentro[0])
            .attr('y1', edgeCentro[1])
            .attr('x2', extCentro[0])
            .attr('y2', extCentro[1]);
        this.graphElement.svgContainer
            .select("#" + arcId)
            .append('text')
            .attr('text-anchor', (/**
         * @return {?}
         */
        function () { return extCentro[0] > 0 ? 'start' : 'end'; }))
            .attr('transform', "translate(" + paddingHorizontalLabel + ", " + paddingVerticalLabel + ")")
            .text(this.graphData.labels.titles[idx]);
    };
    DoughnutGraph.propDecorators = {
        graphData: [{ type: Input }]
    };
    return DoughnutGraph;
}(CircularGraphs));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut-graph.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DoughnutGraphComponent = /** @class */ (function (_super) {
    __extends(DoughnutGraphComponent, _super);
    function DoughnutGraphComponent(elementRef, circularMeasures) {
        var _this = _super.call(this) || this;
        _this.elementRef = elementRef;
        _this.circularMeasures = circularMeasures;
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    DoughnutGraphComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        // Remove previous graphs
        if (changes.graphData.previousValue) {
            select("#svg-" + this.currentElementId).remove();
        }
        this.graphElement = new WrapperComponentD3(this.elementRef);
        this.currentElementId = this.graphElement.uid;
        this.minSize = this.circularMeasures.calcRadius(this.graphElement.width, this.graphElement.height);
        // If graph has labels and the position of if are extenal reduce radius in 25 points.
        this.minSize = this.graphData.labels && this.graphData.labels.position === 'external'
            ? this.minSize - 25
            : this.minSize;
        this.segmentsDegree = this.scaleData(this.graphData.values).map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return _this.circularMeasures.arcValue(value); }));
        this.graphData.colors = this.checkGraphDataColors();
        this.segmentsDegree.map((/**
         * @param {?} arc
         * @param {?} idx
         * @return {?}
         */
        function (arc$$1, idx) {
            /** @type {?} */
            var startAngle = idx === 0
                ? 0
                : _this.segmentsDegree.slice(0, idx).reduce((/**
                 * @param {?} curr
                 * @param {?} prev
                 * @return {?}
                 */
                function (curr, prev) { return curr + prev; }));
            /** @type {?} */
            var endAngle = idx === _this.segmentsDegree.length
                ? 360
                : _this.segmentsDegree.slice(0, idx + 1).reduce((/**
                 * @param {?} curr
                 * @param {?} prev
                 * @return {?}
                 */
                function (curr, prev) { return curr + prev; }));
            _this.drawSegment(startAngle, endAngle, idx);
        }));
    };
    DoughnutGraphComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngl-doughnut',
                    template: "",
                    providers: [
                        CircularMeasures
                    ]
                }] }
    ];
    /** @nocollapse */
    DoughnutGraphComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: CircularMeasures }
    ]; };
    return DoughnutGraphComponent;
}(DoughnutGraph));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/doughnut-graph.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DoughnutGraphModule = /** @class */ (function () {
    function DoughnutGraphModule() {
    }
    DoughnutGraphModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [DoughnutGraphComponent],
                    imports: [],
                    exports: [DoughnutGraphComponent]
                },] }
    ];
    return DoughnutGraphModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-chart-doughnut.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DoughnutGraphComponent, DoughnutGraphModule, CircularGraphs as ɵb, DoughnutGraph as ɵa };

//# sourceMappingURL=ngx-chart-doughnut.js.map